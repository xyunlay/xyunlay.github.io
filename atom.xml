<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xyun&#39;blog</title>
  <icon>https://www.gravatar.com/avatar/c30636a092062e3169373acffb4325c3</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xyunlay.github.io/"/>
  <updated>2021-01-25T07:24:27.712Z</updated>
  <id>http://xyunlay.github.io/</id>
  
  <author>
    <name>xyun</name>
    <email>1249921605@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Burp Suite抓https数据包及集成sqlmap</title>
    <link href="http://xyunlay.github.io/2020/07/03/%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Burp%20Suite%E6%8A%93%E5%8C%85%E5%8F%8A%E9%9B%86%E6%88%90sqlmap/"/>
    <id>http://xyunlay.github.io/2020/07/03/安全渗透测试工具Burp Suite抓包及集成sqlmap/</id>
    <published>2020-07-03T02:55:00.000Z</published>
    <updated>2021-01-25T07:24:27.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h2><p>JDK1.8<br>Burp Suite 1.7.26<br>Firefox 59.0.2<br>Python2.7　　64位安装包<br>sqlmap　　zip包</p><h2 id="一、burp介绍"><a href="#一、burp介绍" class="headerlink" title="一、burp介绍"></a>一、burp介绍</h2><p>请自行谷歌，这里不过多介绍</p><h2 id="二、配置HTTPS抓包方法【以Firefox为例】"><a href="#二、配置HTTPS抓包方法【以Firefox为例】" class="headerlink" title="二、配置HTTPS抓包方法【以Firefox为例】"></a>二、配置HTTPS抓包方法【以Firefox为例】</h2><p>通常情况下burp默认只抓HTTP的包，HTTPS因为含有证书，因而无法正常抓取，抓HTTPS数据包就需要设置可信证书。</p><p>配置方法：<br>第零步：配置火狐浏览器的网络代理（配置火狐浏览器的网络自行谷歌）<br>第一步：火狐访问<a href="http://burp，下载burp的内置证书保存到本地" target="_blank" rel="noopener">http://burp，下载burp的内置证书保存到本地</a><br><a id="more"></a><br><img src="/assets/blogImg/burp_suite1.jpg" alt="Burp Suite"><br><img src="/assets/blogImg/burp_suite2.jpg" alt="Burp Suite"><br>第二步：导入证书<br><img src="/assets/blogImg/burp_suite3.jpg" alt="Burp Suite"><br><img src="/assets/blogImg/burp_suite4.jpg" alt="Burp Suite"></p><p>第三步：信任此证书<br>在证书机构中导入刚才的PortSwiggerCA.crt文件，并选择【信任使用此CA标识的网站】<br><img src="/assets/blogImg/burp_suite5.jpg" alt="Burp Suite"></p><p>确定以后在代理的情况下浏览器就可以正常的访问HTTPS的包，burp就可以抓取到https的数据包了。</p><h2 id="三、启动burpsuite"><a href="#三、启动burpsuite" class="headerlink" title="三、启动burpsuite"></a>三、启动burpsuite</h2><p>启动burp：java -jar BurpUnlimited.jar<br><img src="/assets/blogImg/burp_suite6.jpg" alt="Burp Suite"></p><p>启动后就会看到抓取的https数据包了，如下<br><img src="/assets/blogImg/burp_suite7.jpg" alt="Burp Suite"></p><h2 id="四、Burp-Suite集成sqlmap"><a href="#四、Burp-Suite集成sqlmap" class="headerlink" title="四、Burp Suite集成sqlmap"></a>四、Burp Suite集成sqlmap</h2><h3 id="安装python及sqlmap"><a href="#安装python及sqlmap" class="headerlink" title="安装python及sqlmap"></a>安装python及sqlmap</h3><p>python下载下来默认安装即可，配置系统环境变量</p><p>sqlmap下载下来解压并配置进系统环境变量</p><p>burpsuite集成sqlmapjar包下载</p><h3 id="配置burpsuite"><a href="#配置burpsuite" class="headerlink" title="配置burpsuite"></a>配置burpsuite</h3><p>1、按照截图所示进行配置即可<br><img src="/assets/blogImg/burp_suite8.jpg" alt="Burp Suite"></p><p>2、验证是否配置成功</p><p>首先进行抓包然后右键发送给sqlmap<br><img src="/assets/blogImg/burp_suite9.jpg" alt="Burp Suite"></p><p>sqlmap窗口出现即为调用成功<br><img src="/assets/blogImg/burp_suite10.jpg" alt="Burp Suite"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;本地环境&quot;&gt;&lt;a href=&quot;#本地环境&quot; class=&quot;headerlink&quot; title=&quot;本地环境&quot;&gt;&lt;/a&gt;本地环境&lt;/h2&gt;&lt;p&gt;JDK1.8&lt;br&gt;Burp Suite 1.7.26&lt;br&gt;Firefox 59.0.2&lt;br&gt;Python2.7　　64位安装包&lt;br&gt;sqlmap　　zip包&lt;/p&gt;
&lt;h2 id=&quot;一、burp介绍&quot;&gt;&lt;a href=&quot;#一、burp介绍&quot; class=&quot;headerlink&quot; title=&quot;一、burp介绍&quot;&gt;&lt;/a&gt;一、burp介绍&lt;/h2&gt;&lt;p&gt;请自行谷歌，这里不过多介绍&lt;/p&gt;
&lt;h2 id=&quot;二、配置HTTPS抓包方法【以Firefox为例】&quot;&gt;&lt;a href=&quot;#二、配置HTTPS抓包方法【以Firefox为例】&quot; class=&quot;headerlink&quot; title=&quot;二、配置HTTPS抓包方法【以Firefox为例】&quot;&gt;&lt;/a&gt;二、配置HTTPS抓包方法【以Firefox为例】&lt;/h2&gt;&lt;p&gt;通常情况下burp默认只抓HTTP的包，HTTPS因为含有证书，因而无法正常抓取，抓HTTPS数据包就需要设置可信证书。&lt;/p&gt;
&lt;p&gt;配置方法：&lt;br&gt;第零步：配置火狐浏览器的网络代理（配置火狐浏览器的网络自行谷歌）&lt;br&gt;第一步：火狐访问&lt;a href=&quot;http://burp，下载burp的内置证书保存到本地&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://burp，下载burp的内置证书保存到本地&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="安全渗透测试" scheme="http://xyunlay.github.io/tags/%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试工具Nmap从初级到高级</title>
    <link href="http://xyunlay.github.io/2020/07/01/%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Nmap%E4%BB%8E%E5%88%9D%E7%BA%A7%E5%88%B0%E9%AB%98%E7%BA%A7/"/>
    <id>http://xyunlay.github.io/2020/07/01/安全渗透测试工具Nmap从初级到高级/</id>
    <published>2020-07-01T02:55:00.000Z</published>
    <updated>2021-01-26T03:15:33.476Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Nmap </strong>是一款网络扫描和主机检测的非常有用的工具。 Nmap是不局限于仅仅收集信息和枚举，同时可以用来作为一个漏洞探测器或安全扫描器。它可以适用于winodws,linux,mac等操作系统。Nmap是一款非常强大的实用工具,可用于：</p><ul><li>检测活在网络上的主机（主机发现）</li><li>检测主机上开放的端口（端口发现或枚举）</li><li>检测到相应的端口（服务发现）的软件和版本</li><li>检测操作系统，硬件地址，以及软件版本</li><li>检测脆弱性的漏洞（Nmap的脚本）<br>Nmap是一个非常普遍的工具，它有命令行界面和图形用户界面。<a id="more"></a>Nmap使用不同的技术来执行扫描，包括：TCP的connect（）扫描，TCP反向的ident扫描，FTP反弹扫描等。所有这些扫描的类型有自己的优点和缺点，我们接下来将讨论这些问题。</li></ul><p>Nmap的使用取决于目标主机,因为有一个简单的（基本）扫描和预先扫描之间的差异。我们需要使用一些先进的技术来绕过防火墙和入侵检测/防御系统，以获得正确的结果。下面是一些基本的命令和它们的用法的例子：</p><ul><li>扫描单一的一个主机，命令如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap cnblogs.com</span><br><span class="line"></span><br><span class="line">nmap 192.168.1.2</span><br></pre></td></tr></table></figure><ul><li>扫描整个子网,命令如下:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.1.1/24</span><br></pre></td></tr></table></figure><ul><li>扫描多个目标,命令如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.1.2 192.168.1.5</span><br></pre></td></tr></table></figure><ul><li>扫描一个范围内的目标,如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.1.1-100 (扫描IP地址为192.168.1.1-192.168.1.100内的所有主机)</span><br></pre></td></tr></table></figure><ul><li>如果你有一个ip地址列表，将这个保存为一个txt文件，和namp在同一目录下,扫描这个txt内的所有主机，命令如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -iL target.txt</span><br></pre></td></tr></table></figure><ul><li>如果你想看到你扫描的所有主机的列表，用以下命令:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sL 192.168.1.1/24</span><br></pre></td></tr></table></figure><ul><li>扫描除过某一个ip外的所有子网主机,命令：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.1.1/24 -exclude 192.168.1.1</span><br></pre></td></tr></table></figure><ul><li>扫描除过某一个文件中的ip外的子网主机命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.1.1/24 -exclude file xxx.txt  (xxx.txt中的文件将会从扫描的主机中排除)</span><br></pre></td></tr></table></figure><ul><li>扫描特定主机上的80,21,23端口,命令如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p80,21,23 192.168.1.1</span><br></pre></td></tr></table></figure><p><img src="/assets/blogImg/Nmap1.jpg" alt="nmap"><br>从上面我们已经了解了Nmap的基础知识，下面我们深入的探讨一下Nmap的扫描技术.</p><h3 id="Tcp-SYN-Scan-sS"><a href="#Tcp-SYN-Scan-sS" class="headerlink" title="Tcp SYN Scan (sS)"></a>Tcp SYN Scan (sS)</h3><p>这是一个基本的扫描方式,它被称为半开放扫描，因为这种技术使得Nmap不需要通过完整的握手，就能获得远程主机的信息。Nmap发送SYN包到远程主机，但是它不会产生任何会话.因此不会在目标主机上产生任何日志记录,因为没有形成会话。这个就是SYN扫描的优势.</p><p>如果Nmap命令中没有指出扫描类型,默认的就是Tcp SYN.但是它需要root/administrator权限.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS 192.168.1.1</span><br></pre></td></tr></table></figure><h3 id="Tcp-connect-scan-sT"><a href="#Tcp-connect-scan-sT" class="headerlink" title="Tcp connect() scan(sT)"></a>Tcp connect() scan(sT)</h3><p>如果不选择SYN扫描,TCP connect()扫描就是默认的扫描模式.不同于Tcp SYN扫描,Tcp connect()扫描需要完成三次握手,并且要求调用系统的connect().Tcp connect()扫描技术只适用于找出TCP和UDP端口.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sT 192.168.1.1</span><br></pre></td></tr></table></figure><h3 id="Udp-scan-sU"><a href="#Udp-scan-sU" class="headerlink" title="Udp scan(sU)"></a>Udp scan(sU)</h3><p>顾名思义,这种扫描技术用来寻找目标主机打开的UDP端口.它不需要发送任何的SYN包，因为这种技术是针对UDP端口的。UDP扫描发送UDP数据包到目标主机，并等待响应,如果返回ICMP不可达的错误消息，说明端口是关闭的，如果得到正确的适当的回应，说明端口是开放的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sU 192.168.1.1</span><br></pre></td></tr></table></figure><h3 id="FIN-scan-sF"><a href="#FIN-scan-sF" class="headerlink" title="FIN scan (sF)"></a>FIN scan (sF)</h3><p>有时候Tcp SYN扫描不是最佳的扫描模式,因为有防火墙的存在.目标主机有时候可能有IDS和IPS系统的存在,防火墙会阻止掉SYN数据包。发送一个设置了FIN标志的数据包并不需要完成TCP的握手.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@bt:~# nmap -sF 192.168.1.8</span><br><span class="line"></span><br><span class="line">Starting Nmap 5.51  at 2012-07-08 19:21 PKT</span><br><span class="line"></span><br><span class="line">Nmap scan report for 192.168.1.8</span><br><span class="line"></span><br><span class="line">Host is up (0.000026s latency).</span><br><span class="line"></span><br><span class="line">Not shown: 999 closed ports</span><br><span class="line"></span><br><span class="line">PORT STATE SERVICE</span><br><span class="line"></span><br><span class="line">111/tcp open|filtered rpcbind</span><br></pre></td></tr></table></figure></p><p>FIN扫描也不会在目标主机上创建日志(FIN扫描的优势之一).个类型的扫描都是具有差异性的,FIN扫描发送的包只包含FIN标识,NULL扫描不发送数据包上的任何字节,XMAS扫描发送FIN、PSH和URG标识的数据包.</p><h3 id="PING-Scan-sP"><a href="#PING-Scan-sP" class="headerlink" title="PING Scan (sP)"></a>PING Scan (sP)</h3><p>PING扫描不同于其它的扫描方式，因为它只用于找出主机是否是存在在网络中的.它不是用来发现是否开放端口的.PING扫描需要ROOT权限，如果用户没有ROOT权限,PING扫描将会使用connect()调用.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sP 192.168.1.1</span><br></pre></td></tr></table></figure><p>版本检测(sV)</p><p>版本检测是用来扫描目标主机和端口上运行的软件的版本.它不同于其它的扫描技术，它不是用来扫描目标主机上开放的端口，不过它需要从开放的端口获取信息来判断软件的版本.使用版本检测扫描之前需要先用TCP SYN扫描开放了哪些端口.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV 192.168.1.1</span><br></pre></td></tr></table></figure><h3 id="Idle-scan-sL"><a href="#Idle-scan-sL" class="headerlink" title="Idle scan (sL)"></a>Idle scan (sL)</h3><p>Idle scan是一种先进的扫描技术，它不是用你真实的主机Ip发送数据包，而是使用另外一个目标网络的主机发送数据包.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sL 192.168.1.6 192.168.1.1</span><br></pre></td></tr></table></figure><p>Idle scan是一种理想的匿名扫描技术,通过目标网络中的192.168.1.6向主机192.168.1.1发送数据，来获取192.168.1.1开放的端口</p><p>有需要其它的扫描技术，如 FTP bounce（FTP反弹）, fragmentation scan（碎片扫描）, IP protocol scan（IP协议扫描）,以上讨论的是几种最主要的扫描方式.</p><h3 id="Nmap的OS检测（O）"><a href="#Nmap的OS检测（O）" class="headerlink" title="Nmap的OS检测（O）"></a>Nmap的OS检测（O）</h3><p>Nmap最重要的特点之一是能够远程检测操作系统和软件，Nmap的OS检测技术在渗透测试中用来了解远程主机的操作系统和软件是非常有用的，通过获取的信息你可以知道已知的漏洞。Nmap有一个名为的nmap-OS-DB数据库，该数据库包含超过2600操作系统的信息。 Nmap把TCP和UDP数据包发送到目标机器上，然后检查结果和数据库对照。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Initiating SYN Stealth Scan at 10:21</span><br><span class="line">Scanning localhost (www.nxadmin.com) [1000 ports]</span><br><span class="line">Discovered open port 111/tcp on www.nxadmin.com</span><br><span class="line">Completed SYN Stealth Scan at 10:21, 0.08s elapsed (1000 total ports)</span><br><span class="line">Initiating OS detection (try #1) against localhost (www.nxadmin.com)</span><br><span class="line">Retrying OS detection (try #2) against localhost (www.nxadmin.com)</span><br></pre></td></tr></table></figure></p><p>上面的例子清楚地表明，Nmap的首次发现开放的端口，然后发送数据包发现远程操作系统。操作系统检测参数是O（大写O）<br><img src="/assets/blogImg/Nmap2.jpg" alt="nmap"></p><h3 id="Nmap的操作系统指纹识别技术："><a href="#Nmap的操作系统指纹识别技术：" class="headerlink" title="Nmap的操作系统指纹识别技术："></a>Nmap的操作系统指纹识别技术：</h3><ul><li>设备类型（路由器，工作组等）</li><li>运行（运行的操作系统）</li><li>操作系统的详细信息（操作系统的名称和版本）</li><li>网络距离（目标和攻击者之间的距离跳）</li></ul><p>如果远程主机有防火墙，IDS和IPS系统，你可以使用-PN命令来确保不ping远程主机，因为有时候防火墙会组织掉ping请求.-PN命令告诉Nmap不用ping远程主机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -O -PN 192.168.1.1/24</span><br></pre></td></tr></table></figure><p>以上命令告诉发信主机远程主机是存活在网络上的，所以没有必要发送ping请求,使用-PN参数可以绕过PING命令,但是不影响主机的系统的发现.</p><p>Nmap的操作系统检测的基础是有开放和关闭的端口，如果OS scan无法检测到至少一个开放或者关闭的端口，会返回以下错误：</p><p>Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port</p><p>OS Scan的结果是不可靠的，因为没有发现至少一个开放或者关闭的端口.</p><p><img src="/assets/blogImg/Nmap3.jpg" alt="nmap"></p><p>这种情况是非常不理想的，应该是远程主机做了针对操作系统检测的防范。如果Nmap不能检测到远程操作系统类型，那么就没有必要使用-osscan_limit检测。</p><p><img src="/assets/blogImg/Nmap4.jpg" alt="nmap"></p><p>想好通过Nmap准确的检测到远程操作系统是比较困难的，需要使用到Nmap的猜测功能选项, –osscan-guess 猜测认为最接近目标的匹配操作系统类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -O –osscan-guess 192.168.1.1</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Nmap是一个非常强大的工具，它具有覆盖渗透测试的第一方面的能力，其中包括信息的收集和统计</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Nmap &lt;/strong&gt;是一款网络扫描和主机检测的非常有用的工具。 Nmap是不局限于仅仅收集信息和枚举，同时可以用来作为一个漏洞探测器或安全扫描器。它可以适用于winodws,linux,mac等操作系统。Nmap是一款非常强大的实用工具,可用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检测活在网络上的主机（主机发现）&lt;/li&gt;
&lt;li&gt;检测主机上开放的端口（端口发现或枚举）&lt;/li&gt;
&lt;li&gt;检测到相应的端口（服务发现）的软件和版本&lt;/li&gt;
&lt;li&gt;检测操作系统，硬件地址，以及软件版本&lt;/li&gt;
&lt;li&gt;检测脆弱性的漏洞（Nmap的脚本）&lt;br&gt;Nmap是一个非常普遍的工具，它有命令行界面和图形用户界面。
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="安全渗透测试" scheme="http://xyunlay.github.io/tags/%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>安全测试流程与使用工具</title>
    <link href="http://xyunlay.github.io/2020/06/06/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <id>http://xyunlay.github.io/2020/06/06/安全测试流程与使用工具/</id>
    <published>2020-06-06T02:55:00.000Z</published>
    <updated>2021-01-26T02:28:42.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安全测试在做什么？"><a href="#1-安全测试在做什么？" class="headerlink" title="1.安全测试在做什么？"></a>1.安全测试在做什么？</h2><p>扫描？在很多人的眼中，做安全的就是整天拿个工具在哪里做扫描操作，使用各种不同的工具做扫描。是的，扫描是安全测试的很重要的一部分，扫描可以快速有效的发现问题。扫描工具的易用性、方便性决定了重要地位。但是扫描工具的局限性、程序的不够灵活等缺点也是显而易见的。不管是扫描报告的分析、漏洞的深度挖掘、测试的组织等等的工作都离不开安全测试人员，所以只能说扫描工具减轻了测试人员的工作量，是安全测试的一种手段。</p><h2 id="2-安全测试者是怎样定位自己的？"><a href="#2-安全测试者是怎样定位自己的？" class="headerlink" title="2.安全测试者是怎样定位自己的？"></a>2.安全测试者是怎样定位自己的？</h2><p>我们经常可以从身边的朋友口中听到一些有关安全的名称，向什么软件安全、信息安全、网络安全、计算机安全等一些词组，这些领域都是做安全的，那么我们是属于哪一个呢？<br>大家可以上百度百科查看下这些词组的概念。软件安全往小了说就是某一个软件产品，说大了除了硬件就是软件了啊。信息安全看名字我们就知道关键是信息两个字，但是什么是信息呢，客户的数据还是一切有用的数据？网络安全，什么是网络，网络系统硬件、软件这都是写模糊的可大可小的概念。在看计算机安全，PC？服务器？路由器？好吧我们可以看到这些概念往大了说就成了组成我们今天互联网的各种设备包括各种的嵌入式机器、外接USB、浴室柜尺寸价格专卖蓝牙等设备的共同体的硬软件，以及使用、维护、木桶箱子专卖厂家价格管理等这些东西的人的整个的安全问题。在看他们的区别，他们已不同的地方作为其主要关注点，或者说出发点，他们并没有明显的界线却有着自己的侧重点。而我们的侧重点是什么呢，我们产品是一个什么样的产品呢？我们有WEB服务、接口服务、文件服务、视屏等服务等我们把它们统一称为我们的系统，那么我们就是在做这个系统的安全测试，所以我觉得我们应该定位为系统安全测试。<br>当然我们的系统运行中也涉及到人、涉及到硬件，<br><a id="more"></a><br>此处都不是我们的关注点，我们只从软件技术的角度来识别它。那么，系统安全测试就成了区别于功能测试，和性能测试一样，单独列出来的专项测试了。</p><h2 id="3-安全的本质是什么？"><a href="#3-安全的本质是什么？" class="headerlink" title="3.安全的本质是什么？"></a>3.安全的本质是什么？</h2><p>信任、人性（网络安全的最大漏洞是人）、止损、攻防<br>以上是当前网上一些主要的论点，以信任或者不信任作为本质出发点的还是占据主流的。</p><h2 id="4-概念定义"><a href="#4-概念定义" class="headerlink" title="4.概念定义"></a>4.概念定义</h2><p>敏感数据：<br>敏感数据的具体范围取决于产品具体的应用场景，产品应根据风险进行分析和判断。典型的敏感数据包括口令、银行帐号、大批量个人数据、用户通信内容和密钥等。<br>个人数据：<br>指直接通过该数据或者结合该数据与其他的信息，可以识别出自然人的信息。<br>匿名化：<br>指对个人数据进行的更改（例如单向散列、截短、替换等，如需保留个人数据真实值与替换值之间的对应关系，可以使用对称加密或映射表方式，但密钥/映射表必须由数据所有者控制），使原来有关个人的信息不再能归属到一个可识别的自然人，或推理这种归属需要耗费过多、不相称的时间、费用和精力</p><h2 id="5-我们应该如何去着手"><a href="#5-我们应该如何去着手" class="headerlink" title="5.我们应该如何去着手"></a>5.我们应该如何去着手</h2><p>如何着手去做这个系统安全测试呢？作为一个测试人员要保证系统整体的安全，这就需要有一个整体的结构的框架，就像盖房子一样，先造钢筋混凝土框架，然后砖块去填充它。这里的钢筋混凝土框架就是安全特性方向，其实就是从整体方向上的一个划分，可以有如下简单的划分。</p><h3 id="5-1-测试的特性"><a href="#5-1-测试的特性" class="headerlink" title="5.1.测试的特性"></a>5.1.测试的特性</h3><p>安全特性：操作系统安全、数据库安全、WEB安全、软件的发布和安装安全、协议与接口攻防、敏感数据保护、手机端安全、静态代码分析。</p><h4 id="5-1-1-操作系统安全"><a href="#5-1-1-操作系统安全" class="headerlink" title="5.1.1.操作系统安全"></a>5.1.1.操作系统安全</h4><p>操作系统安全我们可以把它分为以下几块：<br>系统漏洞（操作系统补丁）、系统配置（安全加固）<br>业界权威工具Nessus，其他如retina、绿盟、天镜等。开源的工具可以使用OpenVAS。</p><h4 id="5-1-2-数据库"><a href="#5-1-2-数据库" class="headerlink" title="5.1.2.数据库"></a>5.1.2.数据库</h4><p>数据库安全我们可以把它分为以下几块：<br>数据库漏洞（补丁）、数据库配置特产（安全加固）<br>工具可以使用Ngs</p><h4 id="5-1-3-web安全"><a href="#5-1-3-web安全" class="headerlink" title="5.1.3.web安全"></a>5.1.3.web安全</h4><p>数据库安全我们可以把它分为以下几块：<br>身份验证、验证码、会话管理、权限管理、敏感信息传输、安全审计、信息泄露、输入校验、输出编码、上传下载、异常处理、注释代码等<br>容器的安全（tomcat）<br>应用软件安全（nginx、负载均衡软件、jquery等）<br>扫描工：appScan、awvs</p><h4 id="5-1-4-软件的发布与安装安全"><a href="#5-1-4-软件的发布与安装安全" class="headerlink" title="5.1.4.软件的发布与安装安全"></a>5.1.4.软件的发布与安装安全</h4><p>发布件的完整性校验（签名、哈希）<br>防病毒：需要安装的软件需要经过常用的杀毒软件（如360、卡巴斯基、金山毒霸等）的扫描，保证没有病毒特种码，以免被杀软处理掉。</p><h4 id="5-1-5-协议与接口攻防"><a href="#5-1-5-协议与接口攻防" class="headerlink" title="5.1.5.协议与接口攻防"></a>5.1.5.协议与接口攻防</h4><p>业务交互数据在网络中使用的协议安全性测试<br>协议测试工具：codenomical<br>对外开放的端口:系统对外开放的端口必须是必须的，禁止开放无用端口<br>端口扫描工具：Nmap，近端可以直接在服务器上使用命令查看<br>接口：接口接受的数据需要做严格的处理<br>接口数据严格校验测试</p><h4 id="5-1-6-敏感数据保护"><a href="#5-1-6-敏感数据保护" class="headerlink" title="5.1.6.敏感数据保护"></a>5.1.6.敏感数据保护</h4><p>识别敏感数据：密码、秘钥、会话标识；个人信息、商业机密、客户信息等<br>保护：加密、存储位置、传输方式；获取数据脱敏、匿名化</p><h4 id="5-1-7-手机端安全"><a href="#5-1-7-手机端安全" class="headerlink" title="5.1.7.手机端安全"></a>5.1.7.手机端安全</h4><p>1、app的签名、反逆向<br>2、用户隐私<br>3、文件权限<br>4、网络通讯<br>5、运行时解释保护<br>6、组件权限保护<br>7、升级<br>8、3rd库<br>移动APP测试要点：<a href="http://blog.nsfocus.net/mobile-app-security-security-test/" target="_blank" rel="noopener">http://blog.nsfocus.net/mobile-app-security-security-test/</a></p><h4 id="5-1-8-静态代码分析（纯白盒）"><a href="#5-1-8-静态代码分析（纯白盒）" class="headerlink" title="5.1.8.静态代码分析（纯白盒）"></a>5.1.8.静态代码分析（纯白盒）</h4><p>白盒测试主要是通过对代码的浏览来发现问题，当然问题的类型可能是跟我们黑灰盒总结的一致，拿出来单独讲是因为其不同于其他的测试方式。<br>1、危险函数、方法<br>2、工具检测<br>3、逻辑漏洞<br>灰盒<br>结合白盒和黑盒的一些思路，在实际的代码审计中建议采用灰盒的方式，在需要的地方对代码进行动态调试查看。审计中思路可以考虑如下这些部分：<br>1、涉及敏感数据的时候，检查是get、post哪种形式发送数据<br>Get传输的数据会被记录在代理、浏览器、web容器tomcat等的日志中<br>2、提交铭感数据的时候是否有防止csrf的token、refer、验证码等<br>3、sql注入<br>1）Statement和preparestatement<br>2）mybitas框架 #和$<br>4、XSS<br>我们用的antisamy只能过滤基于标签的XSS伪造，其他的无法过滤，需要做二次过滤<br>5、逻辑<br>此处是指，逻辑思路不合理，不符合安全的一些思想，如权限最小化等等<br>6、参数范围是否造成dos或者影响系统性能<br>7、权限校验、越权<br>1)横、纵、多步骤关联性<br>2）<br>8、session会话管理<br>1）常规cookie及session形式<br>2）把token作为session的形式，特别注入登录用户和token的绑定关系<br>9、参数是否是简单形式，是否可以造成遍历<br>10、代码中使用的第三方插件、开源软件是否是最新、是否有安全漏洞<br>11、代码中所使用的加密算法，是否是安全的<br>12、跳转中的redirect形式中不要带敏感信息，会被发回客户端重新请求的，相当于把这些参数放在了get请求中<br>13、SSRF服务端请求伪造，注意url中含有另外一个url的请求<br>1）源码中使用urlconnection 支持的协议除了http和https以外，还有file、ftp、jar、mailto等<br>request、httpurlconnecttion、httpClient、URL等发起网络请求<br>14、加密算法的使用，是否使用的是不合场景的弱算法<br>15、数据插入自增Id攻击<br>数据传入过来做插入动作，并且使用spring自动绑定对象方法获取数据，之后使用生成的插入sql<br>此时自动增长id不要写到更新语句中，如果写入可能造成恶意注入integer范围最大值2147483647，使功能不可用dos<br>16、Spring自动绑定参数，参数扩展攻击<br>后台使用的对象参数自动绑定获取，相应的sql使用了自动的if是否为null和为空的判断条件，前台可以根据猜测<br>注入队形的相应的属性实现非预料结果</p><h3 id="5-2-WEB安全测试"><a href="#5-2-WEB安全测试" class="headerlink" title="5.2.WEB安全测试"></a>5.2.WEB安全测试</h3><h4 id="5-2-1-身份验证"><a href="#5-2-1-身份验证" class="headerlink" title="5.2.1.身份验证"></a>5.2.1.身份验证</h4><p>为防止密码破解和猜测：<br>复杂度要求，必须由大写、小写、数字等组成；<br>时效性要求，建议用户3个月更改一次口令；<br>密码长度要求，最小8位，最大？位；<br>管理员重置密码后密码必须在下次登录更改；<br>强度要求，不能跟原密码一致，不能与用户名相似（如，不能包含用户名正写反写大小写等），<br>（最新也有说法不建议频繁修改<a href="http://www.secdoctor.cn/html/sec/35995.html）" target="_blank" rel="noopener">http://www.secdoctor.cn/html/sec/35995.html）</a><br>口令认证必须在服务端进行。<br>必须要有验证码机制。<br>登录锁定，登录需要有锁定机制即就是多次登录失败后锁定账号或者ip，在一段时间后自动解锁。<br>手机验证码轰炸<br>手机验证码超时机制<br>账户枚举测试<br>弱密码概念：<a href="https://help.aliyun.com/knowledge_detail/37509.html?spm=5176.7837442.2.5.ZotsLv" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/37509.html?spm=5176.7837442.2.5.ZotsLv</a></p><h4 id="5-2-2-验证码-（普通验证码、知识验证码、无需思考的滑动验证码）"><a href="#5-2-2-验证码-（普通验证码、知识验证码、无需思考的滑动验证码）" class="headerlink" title="5.2.2.验证码 （普通验证码、知识验证码、无需思考的滑动验证码）"></a>5.2.2.验证码 （普通验证码、知识验证码、无需思考的滑动验证码）</h4><p>验证码字符生成算法的安全随机数<br>验证码字符不能被验证码识别工具识别<br>验证码必须是一次性的<br>验证码超时（验证码有效期的意义：1、增加图片处理识别的难度；2、验证码没有有效期的话导致服务器验证码堆积）<br>在忘记密码处做安全问答测试</p><p>建议的验证码形式：<br>当前的最流行的滑动块验证码，有点用户无需动脑，不会打断用户的思考。<br>（验证码的前世今生：<a href="http://www.freebuf.com/articles/web/102276.html）" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/102276.html）</a></p><h4 id="5-2-3-会话管理"><a href="#5-2-3-会话管理" class="headerlink" title="5.2.3.会话管理"></a>5.2.3.会话管理</h4><p>登录前后会话标示要有变化<br>安全退出会话标示注销<br>会话标示安全随机<br>会话标示的长度适度<br>会话超时机制<br>会话标识的传输和存储<br>会话标识夸PC访问</p><h4 id="5-2-4-权限管理"><a href="#5-2-4-权限管理" class="headerlink" title="5.2.4.权限管理"></a>5.2.4.权限管理</h4><p>通过灰化（隐藏）使功能失效<br>纵向越权<br>横向越权<br>权限分离<br>（系统管理、安全管理、审计管理<br>系统管理员主要负责用户管理和系统日常运作相关的维护工作；<br>安全管理员负责安全策略的配置和系统资源安全属性的设定；<br>审计管理员则对系统审计信息进行管理）<br>参看《关于越权》</p><h4 id="5-2-5-敏感信息传输及存储"><a href="#5-2-5-敏感信息传输及存储" class="headerlink" title="5.2.5.敏感信息传输及存储"></a>5.2.5.敏感信息传输及存储</h4><p>敏感信息不能以get方式提交<br>传输通道使用https（关键数据提交服务端不接收http明文数据）<br>严格安全传输HSTS（确保从浏览器发出的请求就是https的）<br>在url中有session<br>对用户保密的信息不能传输到客户端<br>含有敏感信息的页面需要设置不缓存</p><h4 id="5-2-6-安全审计"><a href="#5-2-6-安全审计" class="headerlink" title="5.2.6.安全审计"></a>5.2.6.安全审计</h4><p>登录、退出、操作等都要有日志<br>日志格式标准（时间、谁、做了什么操作、结果怎样）<br>日志访问的限制<br>日志中的敏感信息<br>他们是如何迭代的？日志是否保存足够长的时间？<br>日志是如何被审查的？管理员能否通过审查出发现攻击行为？<br>日志备份如何保存？<br>日志记录数据前是否进行验证（最小最大长度，字符等）？</p><h4 id="5-2-7-信息泄露"><a href="#5-2-7-信息泄露" class="headerlink" title="5.2.7.信息泄露"></a>5.2.7.信息泄露</h4><p>数据库版本泄露<br>容器版本泄露<br>绝对路径泄露<br>异常信息泄露<br>泄露服务器路径<br>泄露容器版本<br>泄露程序详细堆栈信息<br>源代码泄露<br>检测Web网络是否存在源代码泄露漏洞，如果存在此漏洞，攻击者可直接下载网站的源代码。<br>管理地址泄露<br>网站管理地址属于内部使用的信息，公开增加了安全风险。<br>Bak信息泄露<br>搜索引擎发现和侦察信息泄露（暂时不涉及）<br>服务器指纹探测（使用指纹探测工具whatweb需要在linux上编译运行，httprint–最新的signatures.txt不然识别到不准确）</p><p>【其他关注项：】<br>枚举web服务器上存在的应用程序<br>Whois信息收集<br>识别Web应用框架<br>Owasp测试指南4中文：<a href="https://kennel209.gitbooks.io/owasp-testing-guide-v4/content/zh/web_application_security_testing/review_webserver_metafiles_for_information_leakage_otg-info-003.html" target="_blank" rel="noopener">https://kennel209.gitbooks.io/owasp-testing-guide-v4/content/zh/web_application_security_testing/review_webserver_metafiles_for_information_leakage_otg-info-003.html</a><br>拖库撞库<a href="http://blog.nsfocus.net/information-leakage-thinking-library-collision/" target="_blank" rel="noopener">http://blog.nsfocus.net/information-leakage-thinking-library-collision/</a></p><h4 id="5-2-8-输入校验"><a href="#5-2-8-输入校验" class="headerlink" title="5.2.8.输入校验"></a>5.2.8.输入校验</h4><p>前台后台都必须校验（“移除已知的恶意数据”不如移除“良好数据之外的所有数据”）</p><h5 id="5-2-8-1-XSS（跨站点脚本攻击）"><a href="#5-2-8-1-XSS（跨站点脚本攻击）" class="headerlink" title="5.2.8.1.XSS（跨站点脚本攻击）"></a>5.2.8.1.XSS（跨站点脚本攻击）</h5><p>XSS-1反射型跨站点脚本编制<br>XSS-2存储型跨站点脚本编制（<a href="http://xxxxx0000sssss.lofter.com/post/14b1dc_50023e）" target="_blank" rel="noopener">http://xxxxx0000sssss.lofter.com/post/14b1dc_50023e）</a><br>XSS-3 DOM型跨站点脚本编制<br>dom xss并不复杂，他也属于反射型xss的一种，domxss取决于输出位置，并不取决于输出环境，因此domxss既有可能是反射型的，也有可能是存储型的)，简单去理解就是因为他输出点在DOM，所以在道哥的《白帽子讲Web安全里》也有详细介绍。dom - xss是通过url传入参数去控制触发的。<br>HPP（HTTP参数污染[同名参数]<a href="http://blog.csdn.net/eatmilkboy/article/details/6761407）" target="_blank" rel="noopener">http://blog.csdn.net/eatmilkboy/article/details/6761407）</a><br>漏洞危害：<br>1、钓鱼欺骗：最典型的就是利用目标网站的反射型跨站脚本漏洞将目标网站重定向到钓鱼网站，或者注入钓鱼JavaScript以监控目标网站的表单输入，甚至发起基于DHTML更高级的钓鱼攻击方式。<br>2、网站挂马：跨站时利用IFrame嵌入隐藏的恶意网站或者将被攻击者定向到恶意网站上，或者弹出恶意网站窗口等方式都可以进行挂马攻击。<br>3、身份盗用：Cookie是用户对于特定网站的身份验证标志，XSS可以盗取到用户的Cookie，从而利用该Cookie盗取用户对该网站的操作权限。如果一个网站管理员用户Cookie被窃取，将会对网站引发巨大的危害。<br>4、盗取网站用户信息：当能够窃取到用户Cookie从而获取到用户身份使，攻击者可以获取到用户对网站的操作权限，从而查看用户隐私信息。<br>5、垃圾信息发送：比如在SNS社区中，利用XSS漏洞借用被攻击者的身份发送大量的垃圾信息给特定的目标群。<br>6、劫持用户Web行为：一些高级的XSS攻击甚至可以劫持用户的Web行为，监视用户的浏览历史，发送与接收的数据等等。<br>7、XSS蠕虫：XSS 蠕虫可以用来打广告、刷流量、挂马、恶作剧、破坏网上数据、实施DDoS攻击等。<br>参考：<br><a href="https://help.aliyun.com/knowledge_detail/37444.html?spm=5176.7837442.2.11.F8ceHg" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/37444.html?spm=5176.7837442.2.11.F8ceHg</a><br><a href="http://blog.csdn.net/change518/article/details/51024706" target="_blank" rel="noopener">http://blog.csdn.net/change518/article/details/51024706</a> 隐藏域XSS（借助accesskey属性）</p><h5 id="5-2-8-2-SQL注入"><a href="#5-2-8-2-SQL注入" class="headerlink" title="5.2.8.2.SQL注入"></a>5.2.8.2.SQL注入</h5><p>(1、java预处理preparestatement；2、正则表达式过滤参数；3、严格字符串过滤；4、参数化的sql)<br>例子：参数date=if(now()=sysdate(),sleep(0),0)/<em>‘XOR(if(now()=sysdate(),sleep(0),0))OR’”XOR(if(now()=sysdate(),sleep(0),0))OR”</em>/<br>Sql语句中的/斜杠：表示执行，把之前时间内的缓存中的语句再执行一遍<br>\斜杠：表示语句未完换行<br>单行注释：–<br>多行注释：/<em> </em>/<br>If(now()=sysdate(),sleep(2),0)表示如果now()=sysdate(),为真执行sleep(2),否则执行0<br>当前形势下，新开发的网站，大部分采用新框架都已经可以预防sql注入了，只有手动拼接的sql语句易被sql注入。<br>生成注入用例时注意：<br>1）’ 单引号闭合<br>2）‘OR 单引号也可以有结束开始下一元素的效果<br>3）– - 注释后面跟空格实现注释不跟后面语句连接，后面实际被注释掉效果<br>4）Select CONCAT_WS(0x3A, USER, PASSWORD) FROM mysql.user 获取数据库用户<br>5）union all 连接两个select查询结果，合union的区别不去重复；两个select查询的字段一样<br>6）insert into mysql.user(Host,User,Password) values(“%”,”Sectest”,password(“111111”)) 给数据库添加用户 %：远程用户，localhost：本地用户<br>系统使用了MyBatis动态SQL框架组装sql，注意配置文件中的$和#的使用，使用$可能导致sql注入<br>拼接后的语句再放入预编译对象是徒劳的，因为在预编译之前拼接的SQL语句执行逻辑已经被破坏，原 SQL语句的本意已经被改变了。<br>概念：<br><a href="https://help.aliyun.com/knowledge_detail/37450.html?spm=5176.7837442.2.10.ZotsLv" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/37450.html?spm=5176.7837442.2.10.ZotsLv</a><br>Sql注入常用语句：<br><a href="http://www.111cn.net/database/mysql/58518.htm" target="_blank" rel="noopener">http://www.111cn.net/database/mysql/58518.htm</a><br><a href="http://wenku.baidu.com/link?url=sK_daSqJFJt3KsCuYQOjCkuGldDJSJQbATiRX42UEocanxFejYSjVESnyHPhvDP___hGAbKSLMhh4020TOP9wItRr1YWiq8OQ1HzYItXc6q" target="_blank" rel="noopener">http://wenku.baidu.com/link?url=sK_daSqJFJt3KsCuYQOjCkuGldDJSJQbATiRX42UEocanxFejYSjVESnyHPhvDP___hGAbKSLMhh4020TOP9wItRr1YWiq8OQ1HzYItXc6q</a></p><h5 id="5-2-8-3-XML注入测试"><a href="#5-2-8-3-XML注入测试" class="headerlink" title="5.2.8.3.XML注入测试"></a>5.2.8.3.XML注入测试</h5><p>（借助XXE,攻击者可以实现任意文件读取,DOS拒绝服务攻击以及代理扫描内网等）<br>日志注入（\r,\n换行，伪造日志）<br>命令注入（操纵系统命令）<br>Email Header Injection(邮件标头注入)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*（我们在暂时不涉及）</span><br><span class="line">Email Header Injection：如果表单用于发送email,表单中可能包括“subject”输入项（邮件标题），我们要验证subject中应能escape掉“\n”标识。</span><br><span class="line">&lt;!--[if !supportLists]--&gt; &lt;!--[endif]--&gt;因为“\n”是新行，如果在subject中输入“hello\ncc:spamvictim@example.com”，可能会形成以下</span><br><span class="line">Subject: hello</span><br><span class="line">cc: spamvictim@example.com</span><br><span class="line">&lt;!--[if !supportLists]--&gt; &lt;!--[endif]--&gt;如果允许用户使用这样的subject，那他可能会给利用这个缺陷通过我们的平台给其它用户发送垃圾邮件。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><h5 id="5-2-8-4-代码执行"><a href="#5-2-8-4-代码执行" class="headerlink" title="5.2.8.4.代码执行"></a>5.2.8.4.代码执行</h5><p>代码执行是指应用程序对传入命令的参数过滤不严导致恶意用户能控制最终执行的命令，进而入侵系统，导致严重破坏的高危漏洞。<br><a href="https://help.aliyun.com/knowledge_detail/37446.html?spm=5176.7837442.2.2.nCzE5s" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/37446.html?spm=5176.7837442.2.2.nCzE5s</a></p><h5 id="5-2-8-5-CRLF漏洞"><a href="#5-2-8-5-CRLF漏洞" class="headerlink" title="5.2.8.5.CRLF漏洞"></a>5.2.8.5.CRLF漏洞</h5><p>CRLF，carriage-return-line-feed,回车换行漏洞。<br>案例参考：<a href="https://www.leavesongs.com/PENETRATION/Sina-CRLF-Injection.html（对header进行注入）" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/Sina-CRLF-Injection.html（对header进行注入）</a></p><h4 id="5-2-9-上传下载"><a href="#5-2-9-上传下载" class="headerlink" title="5.2.9.上传下载"></a>5.2.9.上传下载</h4><p>跨目录文件下载<br>任意文件下载<br>任意文件上传（后缀）<br>任意目录文件上传（目录）<br>超大文件上传（大小）<br>上传文件废弃后处理（堆积）<br>上传文件名xss（重命名）<br>上传文件名截断（0x00或者0x58,burp也可以修改二进制，url中%00）<br>上传文件权限限制<br>压缩炸弹<br>Include包含上传（shtml）<br>上传zip文件名中包含../<br>本地文件包含的概念：<br><a href="https://help.aliyun.com/knowledge_detail/37472.html?spm=5176.7837442.2.2.2NdNhY" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/37472.html?spm=5176.7837442.2.2.2NdNhY</a></p><h4 id="5-2-10-CSRF"><a href="#5-2-10-CSRF" class="headerlink" title="5.2.10.CSRF"></a>5.2.10.CSRF</h4><p>CSRF【cross site request forgery】跨站点请求伪造。<br>原理：利用浏览器内存共享原理，利用用户身份伪造用户动作发送到服务端。（从恶意站点模拟用户发送正常的请求携带cookie，见7.1）</p><h5 id="5-2-10-1-URL重定向（跳转）漏洞："><a href="#5-2-10-1-URL重定向（跳转）漏洞：" class="headerlink" title="5.2.10.1.URL重定向（跳转）漏洞："></a>5.2.10.1.URL重定向（跳转）漏洞：</h5><p>（参考<a href="http://drops.wooyun.org/papers/154）" target="_blank" rel="noopener">http://drops.wooyun.org/papers/154）</a><br>1、问题点<br>在页面跳转的地方，URL中包含另外的网址，例如：<br>第一类 简单URL过滤<br><a href="http://www.xxx.com?a=http://www.yyy.com" target="_blank" rel="noopener">www.xxx.com?a=http://www.yyy.com</a><br>第二类 底层操作类库支持其他协议导致读取本地或探测网络信息<br><a href="http://h2w.iask.cn/h5.php?u=file:///etc/passwd" target="_blank" rel="noopener">http://h2w.iask.cn/h5.php?u=file:///etc/passwd</a><br>由于底层适用类curl库,而没有正确过滤URL导致，可以读取内网诸多信息.还有其他类似的形式：<br>如file://, ftp://, telnet://等<br>第三类 不支持其他协议但是没有设置网络边界（SSRF漏洞的姿势啊）<br><a href="http://wap.sogou.com/tc?url=http%3A%2F%2Fno.sohu.com%2F" target="_blank" rel="noopener">http://wap.sogou.com/tc?url=http%3A%2F%2Fno.sohu.com%2F</a><br>使用域之间的信任，突破到系统的内网<br>2、分析<br>理论上讲，url跳转属于CSRF的一种，我们需要对传入的URL做有效性的认证，保证该URL来自于正确的地方，限制的方式同防止csrf一样可以包括：<br>1）referer的限制<br>2）加入有效性验证Token<br>3、对跳转的地址没有做严格的校验</p><h4 id="5-2-11-CORS漏洞"><a href="#5-2-11-CORS漏洞" class="headerlink" title="5.2.11.CORS漏洞"></a>5.2.11.CORS漏洞</h4><p>CORS【cross origin resouse-sharing】跨域资源共享。<br>工具：shell of the future<br>理解参考：<a href="http://www.2cto.com/Article/201209/154081.html" target="_blank" rel="noopener">http://www.2cto.com/Article/201209/154081.html</a></p><h4 id="5-2-12-SSRF漏洞（服务端请求伪造）"><a href="#5-2-12-SSRF漏洞（服务端请求伪造）" class="headerlink" title="5.2.12.SSRF漏洞（服务端请求伪造）"></a>5.2.12.SSRF漏洞（服务端请求伪造）</h4><p>行为特点：从其他服务器获取数据资源的功能，并且此功能获取资源的请求是从服务端发起的。<br>可以实现的攻击：<br>可以对服务器所在的内网、本地端口进行扫描、获取banner等<br>攻击运行在内网或者本地的应用程序（比如溢出）<br>对内网WEB应用进行指纹识别，访问默认文件的方式<br>攻击内网WEB服务器，get请求方式<br>利用file协议读取本地文件：例如<a href="http://192.168.1.119/pm/www/index.php?m=bug&amp;f=view&amp;bugID=4052" target="_blank" rel="noopener">http://192.168.1.119/pm/www/index.php?m=bug&amp;f=view&amp;bugID=4052</a></p><p><a href="http://netsecurity.51cto.com/art/201312/424038.htm" target="_blank" rel="noopener">http://netsecurity.51cto.com/art/201312/424038.htm</a></p><h4 id="5-2-13-Google黑客"><a href="#5-2-13-Google黑客" class="headerlink" title="5.2.13.Google黑客"></a>5.2.13.Google黑客</h4><p>1、搜索站点看是否能发现敏感的信息或不该公布的信息<br>搜索命令，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">site:yizhen.cn</span><br><span class="line">site:yizhen.cn yizhen.cn:password</span><br><span class="line">site:yizhen.cn inurl:session</span><br><span class="line">site:yizhen inanchor:修改密码</span><br><span class="line">cache：www.yizhen.cn</span><br></pre></td></tr></table></figure></p><p>参考：<a href="http://www.cnblogs.com/xuanhun/p/3910134.html" target="_blank" rel="noopener">http://www.cnblogs.com/xuanhun/p/3910134.html</a></p><h4 id="5-2-14-其他"><a href="#5-2-14-其他" class="headerlink" title="5.2.14.其他"></a>5.2.14.其他</h4><p>http开放方法测试<br>不安全的方法：put、delete、trace、connect<br>TRACE: 这个方法简单返回客户端发送给服务器的所有信息，主要用于调试目的。这个方法最初被认为没有危害，被Jermiah Grossman发现能被用于实施XST<br>CONNECT: 这个方法允许客户端使用web服务器作为代理。<br>DELETE: 这个方法允许客户端删除web服务器上的一个文件。攻击者能利用他简单直接破坏网站或者实施拒绝服务攻击。<br>这个方法允许客户端向web服务器上传新的文件。攻击者可以利用他来上传恶意文件（比如一个asp文件通过调用cmd.exe来执行命令），或者简单使用受害者服务器作为文件仓库。<br>banner信息检查<br>HTTP方法篡改(已验证，没有此问题；问题案例<a href="https://www.sobug.com/article/detail/25" target="_blank" rel="noopener">https://www.sobug.com/article/detail/25</a>)<br>JavaScript DDOS（切换https后问题解决）<br>缓冲器溢出漏洞，java的不涉及<br>管理接口暴力枚举（DirBuster）<br>测试HEAD访问控制绕过<br>跨域策略测试<br>数值溢出<br>不管整数，浮点数，长整数等都是有一个可以表示的最大值，如果一个该类型变量被赋予超过其最大值的时候就会出现溢出，而找出该变量的值异常。</p><h4 id="5-2-15-重放攻击"><a href="#5-2-15-重放攻击" class="headerlink" title="5.2.15.重放攻击"></a>5.2.15.重放攻击</h4><p>重放多次请求消耗系统资源的请求，造成dos。筛选出较为消耗资源的请求，检查系统是否有防重放策略或者机制。</p><h4 id="5-2-16-容器的安全"><a href="#5-2-16-容器的安全" class="headerlink" title="5.2.16.容器的安全"></a>5.2.16.容器的安全</h4><h5 id="5-2-16-1-Apache-tomcat"><a href="#5-2-16-1-Apache-tomcat" class="headerlink" title="5.2.16.1.Apache tomcat"></a>5.2.16.1.Apache tomcat</h5><p>1）官网公布的安全漏洞补丁升级<br><a href="http://tomcat.apache.org/security-7.html#Apache_Tomcat_7.x_vulnerabilities" target="_blank" rel="noopener">http://tomcat.apache.org/security-7.html#Apache_Tomcat_7.x_vulnerabilities</a><br>2）运行账户<br>建立独立用户，用户名和组名均为tomcat，不设置密码（即禁止SSH登录），tomcat进程以此帐号身份运行，严禁以root权限运行tomcat，禁止以个人帐号或其他有shell权限的帐号运行tomcat。<br>3）删除Tomcat自带项目<br>4）检查tomcat已知的带有风险的配置<br>a)禁用应用程序自动部署功能（待考虑）<br>b)禁用webdav<br>c)定制Tomcat出错信息<br>d)关闭Tomcat的目录列表功能<br>e)限制http请求的消息主体的大小<br>f)禁止配置Tomcat的网络连接超时时间为0或-1<br>g)可执行文件只能由Tomcat属主用户修改<br>h)配置文件只能由Tomcat属主用户修改<br>i)日志文件只能由Tomcat属主用户修改和执行<br>j)配置虚拟目录，用以隐藏后台路径<br>k)禁用SSI和CGI功能<br>l)不允许使用SetUID程序，尤其是root身份的SetUID程序<br>m)开启Tomcat的日志功能：正常的访问日志和错误请求日志。日志文件的记录中包含访问时间、内容、结果及请求用户的ip等关键信息<br>影响较大的漏洞：<br>CVE-2016-1240 tomcat地权用户提权漏洞。（2016-10）</p><h4 id="5-2-17-其他组件安全"><a href="#5-2-17-其他组件安全" class="headerlink" title="5.2.17.其他组件安全"></a>5.2.17.其他组件安全</h4><h5 id="5-2-17-1-Nginx"><a href="#5-2-17-1-Nginx" class="headerlink" title="5.2.17.1.Nginx"></a>5.2.17.1.Nginx</h5><p>官网安全漏洞先关链接：<a href="http://nginx.org/en/security_advisories.html" target="_blank" rel="noopener">http://nginx.org/en/security_advisories.html</a><br>影响较大的漏洞：<br>CVE-2016-1247 提权漏洞，借助nginx日志，提取到root。（2016-10）</p><h5 id="5-2-17-2-Jquery"><a href="#5-2-17-2-Jquery" class="headerlink" title="5.2.17.2.Jquery"></a>5.2.17.2.Jquery</h5><p><a href="http://192.168.1.120:8080/amol-hospital/js/jquery-1.9.1.min.js" target="_blank" rel="noopener">http://192.168.1.120:8080/amol-hospital/js/jquery-1.9.1.min.js</a><br><a href="http://192.168.1.120:8080/amol-hospital/js/ueditor/third-party/jquery-1.10.2.min.js" target="_blank" rel="noopener">http://192.168.1.120:8080/amol-hospital/js/ueditor/third-party/jquery-1.10.2.min.js</a><br>在官网上没有找到相应的安全漏洞列表<br><a href="https://blog.jquery.com/2013/02/04/jquery-1-9-1-released/" target="_blank" rel="noopener">https://blog.jquery.com/2013/02/04/jquery-1-9-1-released/</a><br>Jquery两个版本间更新日志，其中有两处vulnerable字样<br><a href="https://github.com/jquery/jquery/compare/1.9.1...1.12.3" target="_blank" rel="noopener">https://github.com/jquery/jquery/compare/1.9.1...1.12.3</a></p><h5 id="5-2-17-3-Java漏洞"><a href="#5-2-17-3-Java漏洞" class="headerlink" title="5.2.17.3.Java漏洞"></a>5.2.17.3.Java漏洞</h5><p>（放到操作系统部分，nessus可以很好的检查这个）</p><h5 id="5-2-17-4-百度Ueditor（1-4-3）"><a href="#5-2-17-4-百度Ueditor（1-4-3）" class="headerlink" title="5.2.17.4.百度Ueditor（1.4.3）"></a>5.2.17.4.百度Ueditor（1.4.3）</h5><h5 id="5-2-17-5-Node-js-超声视频使用"><a href="#5-2-17-5-Node-js-超声视频使用" class="headerlink" title="5.2.17.5.Node.js(超声视频使用)"></a>5.2.17.5.Node.js(超声视频使用)</h5><p>node -v<br>v0.10.42</p><h5 id="5-2-17-6-Spring"><a href="#5-2-17-6-Spring" class="headerlink" title="5.2.17.6.Spring"></a>5.2.17.6.Spring</h5><h5 id="5-2-17-7-Mybitas"><a href="#5-2-17-7-Mybitas" class="headerlink" title="5.2.17.7.Mybitas"></a>5.2.17.7.Mybitas</h5><h5 id="5-2-17-8-Druid"><a href="#5-2-17-8-Druid" class="headerlink" title="5.2.17.8.Druid"></a>5.2.17.8.Druid</h5><p>数据库连接池组件，包括四部分：DruidDriver、DruidDataSource、SQLParsr、扩展组件。<br>可以监控数据库访问性能，Druid内置提供了一个功能强大的StatFilter插件，能够详细统计SQL的执行性能，这对于线上分析数据库访问性能有帮助。替换DBCP和C3P0。Druid提供了一个高效、功能强大、可扩展性好的数据库连接池。SQL执行日志，Druid提供了不同的LogFilter，能够支持Common-Logging、Log4j和JdkLog，你可以按需要选择相应的LogFilter，监控你应用的数据库访问情况。扩展JDBC，如果你要对JDBC层有编程的需求，可以通过Druid提供的Filter机制，很方便编写JDBC层的扩展插件。<br>1、访问没有权限控制</p><h5 id="5-2-17-9-Turnserver"><a href="#5-2-17-9-Turnserver" class="headerlink" title="5.2.17.9.Turnserver"></a>5.2.17.9.Turnserver</h5><p>TurnServer 是一个TURN协议的开源实现。<br>该协议允许一个客户端以relay方式获得IP地址和端口。这对于symmetric 类型的NAT或者防火墙两边设备的通信非常有用。<br>TurnServer项目旨在兼容地处理 TURN 和 STUN请求 (RFC 5766 , RFC 5389)，同时也支持 RFC6156 即 TURN-IPV6 (relay between IPv4-IPv6, IPv6-IPv4 and IPv6-IPv6 addresses) 和 RFC6062 即TURN-TCP (relay data with TCP)</p><h5 id="5-2-17-10-Terracotta-session共享"><a href="#5-2-17-10-Terracotta-session共享" class="headerlink" title="5.2.17.10.Terracotta(session共享)"></a>5.2.17.10.Terracotta(session共享)</h5><h5 id="5-2-17-11-phpMyAdmin"><a href="#5-2-17-11-phpMyAdmin" class="headerlink" title="5.2.17.11.phpMyAdmin"></a>5.2.17.11.phpMyAdmin</h5><p><a href="http://www.phpmyadmin.net/security/" target="_blank" rel="noopener">http://www.phpmyadmin.net/security/</a></p><h5 id="5-2-17-12-Redis"><a href="#5-2-17-12-Redis" class="headerlink" title="5.2.17.12.Redis"></a>5.2.17.12.Redis</h5><p>1、指定redis服务使用的网卡 （需要重启redis才能生效）<br>在 redis.conf 文件中找到 “# bind 127.0.0.1” ，把前面的#号去掉，然后保存。注：修改后只有本机才能访问Redis。<br>2、设置访问密码 （需要重启redis才能生效）<br>在 redis.conf 中找到“requirepass”字段，在后面填上你需要的密码，Redis客户端也需要使用此密码来访问Redis服务。<br>3、修改Redis服务运行账号 （需要重启redis才能生效）<br>请以较低权限账号运行Redis服务，且禁用该账号的登录权限。另外可以限制攻击者往敏感写入文件，但是Redis数据还是能被黑客访问到，或者被黑客恶意删除。<br>4、设置防火墙策略<br>如果正常业务中Redis服务需要被其他服务器来访问，可以设置iptables策略仅允许指定的IP来访问Redis服务。<br>参考：<br><a href="https://help.aliyun.com/knowledge_detail/37447.html?spm=5176.7837442.2.10.nCzE5s" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/37447.html?spm=5176.7837442.2.10.nCzE5s</a></p><h5 id="5-2-17-13-Fastjson开源jar"><a href="#5-2-17-13-Fastjson开源jar" class="headerlink" title="5.2.17.13.Fastjson开源jar"></a>5.2.17.13.Fastjson开源jar</h5><p><a href="https://github.com/alibaba/fastjson/wiki/security_update_20170315" target="_blank" rel="noopener">https://github.com/alibaba/fastjson/wiki/security_update_20170315</a><br>fastjson最新远程代码执行高危安全漏洞，当前涉及1.2.24之前版本<br>我们用的1.1.41</p><h4 id="5-2-18-Web木马"><a href="#5-2-18-Web木马" class="headerlink" title="5.2.18.Web木马"></a>5.2.18.Web木马</h4><p>常见的简单形式–诱导优化打开具有网页木马的页面，一般是写入js引用大马的代码网页，用户打开诱导网页后在电脑上实际上已经默认运行了下载大马和执行大马的操作</p><h3 id="5-3-敏感数据保护"><a href="#5-3-敏感数据保护" class="headerlink" title="5.3.敏感数据保护"></a>5.3.敏感数据保护</h3><h4 id="5-3-1-加密算法"><a href="#5-3-1-加密算法" class="headerlink" title="5.3.1.加密算法"></a>5.3.1.加密算法</h4><p>算法列表能用，不能用<br>弱算法：md2，md4，md5（2004年的国际密码学会议（Crypto’2004）王小云证明了MD5可以被碰撞，至此，MD5不再安全） ，sha1，blowfish<br>推荐算法：sha256，aes128<br>可逆的加密算法：des 3des aes128<br>可逆加密算法又分为两大类：“对称式”和“非对称式”。<br>对称式加密特点：加密和解密使用同一个密钥，通常称之为“Session Key ”。<br>DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6和AES<br>非对称式加密特点：加密和解密所使用的不是同一个密钥，而是两个密钥：一个称为“公钥”，另一个称为“私钥”；它们两个必须配对使用，否则不能打开加密文件。这里的“公钥”是指可以对外公布的，“私钥”则只能由持有人本人知道。<br>常见的非对称加密算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）<br>不可逆加密算法：sha256 sha512 md5<br>不可逆加密算法的特征是，加密过程中不需要使用密钥，输入明文后由系统直接经过加密算法处理成密文。这种加密后的数据是无法被解密的，只有重新输入明文。<br>常见的Hash算法：MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1<br>参考：<br><a href="http://www.360doc.com/content/13/0402/15/3862791_275529254.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/13/0402/15/3862791_275529254.shtml</a><br><a href="http://book.51cto.com/art/201109/294599.htm" target="_blank" rel="noopener">http://book.51cto.com/art/201109/294599.htm</a><br>MD5输出128bit<br>SHA1输出160bit<br>SHA256输出256bit<br>另外还有SHA244,SHA512<br>分别输出244bit，512bit<br>问题分析<br>数据库中的密码的机密算法推荐：<br>1、使用不可逆加密算法<br>2、使用加盐（避免预先计算彩虹表）<br>建议的用户密码加密形式：<br>http：若通道未加密，密码在客户端使用可逆加密算法AES-256并加盐（从服务端获取挑战码即盐值），传输到服务端再解密。<br>https：服务端接受到明文密码后使用不可逆加密算法对密码进行哈希加密SHA256并加盐（使用安全随机盐值，长度建议跟密码最长一致），再存入密码密文和盐值到数据库。</p><h4 id="5-3-2-证书"><a href="#5-3-2-证书" class="headerlink" title="5.3.2.证书"></a>5.3.2.证书</h4><p>我们一般说的证书都是服务端证书，即浏览器使用的验证服务器身份的证书。<br>我们的证书是自生成的证书。<br>证书：证明身份的凭据，证书中心用自己的私钥对信息发送者的公钥和一些信息一起的加密，证书可以保证公钥的安全性和有效新，公钥可以验证私钥持有方的身份。常规信息有：颁发给的通用名、组织、组织单元、序列号和颁发者的通用名、组织、组织单元，有效时间开始于、过期时间，指纹SHA-256指纹和SHA1指纹。详细信息还有证书的签名算法、公钥算法、公钥等。<br>签名哈希算法：证书编码完整性保证的哈希算法<br>签名算法：私钥对证书编码的哈希加密的算法；证书签名使用的算法是发布者自己规定的<br>上面两个是发布机构搞得，用来CA验证的<br>指纹算法：计算出指纹的哈希的算法，就是哈希算法，一般就是sha1<br>指纹：证书的哈希值并用私钥加密。<br>鉴别用户的真伪可以通过鉴别用户的私钥的真伪来确认，就是看加密的信息服务端是否可以解密。<br>公钥：连接建立时浏览器端加密时使用的秘钥。<br>私钥：连接建立时服务器端加密时使用的秘钥。<br>使用时：<br>步骤一：<br>1、浏览器输入网址访问yizhen.cn（应用层的）<br>2、浏览器底层的TSL协议发送明文的Hello信息给服务器（网络层）<br>3、服务器响应一个Hello信息给浏览器<br>步骤二：<br>服务器端发送它的证书给浏览器（图中的三，图中的二是之前就生成好的，存储在服务端的公钥、私钥、证书）<br>步骤三：<br>1、客户端验证服务端发来的证书<br>2、验证证书的签名、完整性等信息<br>3、去浏览器证书管理中心验证证书是否可信，是否为可信机构的证书或者子证书<br>4、如果不可信，浏览器抛出警告，提示用户，需要用户确认选择是否继续<br>步骤四：<br>1、浏览器产生一个随机的值，作为秘钥，对称加密的秘钥，此处就称为秘钥。<br>2、使用证书中的公钥对产生的秘钥进行加密生成密文串<br>步骤五：<br>1、发送密文串给服务器<br>2、服务器接受到密文串，使用证书的私钥进行解密，获得对称加密的秘钥。<br>3、服务器使用对称秘钥加密响应报文内容发送给浏览器。<br>步骤六：<br>服务器和浏览器可以通讯了。<br>浏览器发送的数据都是公钥加密，使用对称秘钥解密收到的数据。<br>服务器发送的数据都是对称秘钥加密的，收到的数据使用私钥解密。<br>简单示意图如下：<br>证书介绍和攻击<br>Pem格式的证书详细信息查看：<br><a href="https://www.trustasia.com/tools/cert-decoder.htm" target="_blank" rel="noopener">https://www.trustasia.com/tools/cert-decoder.htm</a><br>SSL证书被攻击、假冒的风险分析<br><a href="http://wenku.baidu.com/link?url=LkghTfA11JWJBLFJrgBZfCrIBFJoqfcH1q4xBEbzt3xmGtkR7mdkV91mUnRobYQKYz2ekVTo7XNQdOMHIuOpWZv4TBDBVsBo52dYNeX1zRi" target="_blank" rel="noopener">http://wenku.baidu.com/link?url=LkghTfA11JWJBLFJrgBZfCrIBFJoqfcH1q4xBEbzt3xmGtkR7mdkV91mUnRobYQKYz2ekVTo7XNQdOMHIuOpWZv4TBDBVsBo52dYNeX1zRi</a><br>一个合法有效的SSL证书误签发给了假冒者（–）<br>破解SSL证书签发CA的私钥（关注签名算法）<br>SSL证书签发CA的私钥泄露（如果是自签名证书需要关注）<br>破解SSL证书的私钥（关注指纹算法）<br>SSL证书的私钥泄露（服务器端私钥的存贮）<br>认证机构主动为假冒网站签发合法有效的证书（–）<br>利用可信的SSL服务器证书进行中间人攻击（–）<br>在用户主机中植入伪造的根CA证书（或一个完整的CA证书链）（–）<br>旁路证书的可信性的验证（–浏览器操作系统漏洞）<br>—如果证书的跟证书没有，第一次访问会去证书网站获取根证书或者中间证书</p><h5 id="5-3-2-1-证书加密算法的检查"><a href="#5-3-2-1-证书加密算法的检查" class="headerlink" title="5.3.2.1.证书加密算法的检查"></a>5.3.2.1.证书加密算法的检查</h5><p>1、证书的指纹算法是否安全，不安全的算法造成证书加密传输的信息可以被解密<br>2、证书的签名算法是否安全，不安全的签名算法可能造成证书被伪造</p><h5 id="5-3-2-2-证书对应的秘钥保存检查"><a href="#5-3-2-2-证书对应的秘钥保存检查" class="headerlink" title="5.3.2.2.证书对应的秘钥保存检查"></a>5.3.2.2.证书对应的秘钥保存检查</h5><p>1、证书私钥在服务器端存储是否加密<br>2、证书私钥在服务器端的存储文件权限是否只有所有者可以访问<br>—-浏览器端客户的CA根证书是否安全可信，这个无法保证（不涉及）</p><h4 id="5-3-3-明文密码"><a href="#5-3-3-明文密码" class="headerlink" title="5.3.3.明文密码"></a>5.3.3.明文密码</h4><p>客户端<br>1、浏览器Cookie中存储，浏览器Cookie中记录密文密码<br>2、浏览器记录密码保存明文密码<br>服务端明文密码检查<br>1、 配置文件明文密码<br>2、日志中记录明文密码<br>3、程序中硬编码密码、密钥<br>（针对秘钥场景的理解，主要针对当前的弱算法秘钥爆破的场景，原理是通过对多次的加密后的密文对比差异尝试推倒秘钥，有些场景可以认为是分问题的，如数据库密码以DES加密密文存储在配置文件中，密钥在代码中硬编码，这种场景的密钥硬编码就是没有问题的，他的密钥在配置文件和代码中其实没有多大区别。）</p><h4 id="5-3-4-源代码敏感信息检查"><a href="#5-3-4-源代码敏感信息检查" class="headerlink" title="5.3.4.源代码敏感信息检查"></a>5.3.4.源代码敏感信息检查</h4><p>使用search and replace搜索代码中的关键字、敏感字，查看是否有不当使用的地方<br>1、passwd、password、pword等<br>2、使用过的密码111111,123456，admin，amol等</p><h3 id="5-4-协议与接口攻防"><a href="#5-4-协议与接口攻防" class="headerlink" title="5.4.协议与接口攻防"></a>5.4.协议与接口攻防</h3><h4 id="5-4-1-端口扫描"><a href="#5-4-1-端口扫描" class="headerlink" title="5.4.1.端口扫描"></a>5.4.1.端口扫描</h4><p>1、远端扫描工具Nmap<br>端口扫描命令<br>TCP，Nmap -sS -T4 -p 1-65535 -oX filename.xml IP<br>UDP，Nmap -sU -T4 -p 1-65535 -oX filename.xml IP<br>2、系统检测<br>检查服务器的操作系统类型及版本<br>Nmap –O IP<br>3、近端端口信息检查<br>登录服务器，查看端口详细信息<br>lsof –i:port<br>ps –ef|grep pid<br>4、整理系统开放端口的详细列表</p><h4 id="5-4-2-端口服务探测"><a href="#5-4-2-端口服务探测" class="headerlink" title="5.4.2.端口服务探测"></a>5.4.2.端口服务探测</h4><p>1、使用命令nmap -sV -Pn -p port IP，探测端口的详细服务及版本<br>-Pn：在扫描之前，不发送ICMP echo请求测试目标是否活跃。<br>-sV：探索开放的端口，确定服务器/版本信息</p><h4 id="5-4-3-REST-WEB-Service（接口协议）"><a href="#5-4-3-REST-WEB-Service（接口协议）" class="headerlink" title="5.4.3.REST WEB Service（接口协议）"></a>5.4.3.REST WEB Service（接口协议）</h4><h4 id="5-4-4-SOAP"><a href="#5-4-4-SOAP" class="headerlink" title="5.4.4.SOAP"></a>5.4.4.SOAP</h4><p>Soap注入</p><h4 id="5-4-5-SSH协议"><a href="#5-4-5-SSH协议" class="headerlink" title="5.4.5.SSH协议"></a>5.4.5.SSH协议</h4><p>放到操作系统部分，这个组件和操作系统强相关</p><h4 id="5-4-6-IM服务-XMPP协议"><a href="#5-4-6-IM服务-XMPP协议" class="headerlink" title="5.4.6.IM服务-XMPP协议"></a>5.4.6.IM服务-XMPP协议</h4><p><a href="http://wiki.xmpp.org/web/Securing_XMPP" target="_blank" rel="noopener">http://wiki.xmpp.org/web/Securing_XMPP</a><br>IM服务检查：<a href="https://xmpp.net" target="_blank" rel="noopener">https://xmpp.net</a><br>Tigase用户指南：<a href="http://docs.tigase.org/tigase-server/snapshot/Administration_Guide/html_chunk/index.html" target="_blank" rel="noopener">http://docs.tigase.org/tigase-server/snapshot/Administration_Guide/html_chunk/index.html</a><br>Tigase XMPP (Jabber) server ver 7.0.2</p><p>IM服务器如何测试？？？<br><a href="http://my.oschina.net/greki/blog/210393" target="_blank" rel="noopener">http://my.oschina.net/greki/blog/210393</a><br>Tigase-server<br>Tigase-client<br><a href="http://localhost:8080/setup/进入tigase后台" target="_blank" rel="noopener">http://localhost:8080/setup/进入tigase后台</a></p><h4 id="5-4-7-外部接口安全"><a href="#5-4-7-外部接口安全" class="headerlink" title="5.4.7.外部接口安全"></a>5.4.7.外部接口安全</h4><p>获取token：<a href="http://192.168.1.120:8080/amol-back/oauth/token?client_id=amol_client_mbox&amp;client_secret=amol_secret_mbox&amp;grant_type=password&amp;username=mbox&amp;password=123456" target="_blank" rel="noopener">http://192.168.1.120:8080/amol-back/oauth/token?client_id=amol_client_mbox&amp;client_secret=amol_secret_mbox&amp;grant_type=password&amp;username=mbox&amp;password=123456</a><br>1、链路加密<br>2、参数校验 -<br>3、访问数限制-<br>参数：<br>使用burp遍历用例payload<br>1)特殊字符<br>英文字符</p><blockquote><p>~!@#$%^&amp;<em>()____+{}|:”&lt;&gt;?-=;’,./`<br>中文字符<br>~！@#￥%……&amp;</em>（）——+：“《》？，。、‘；、】【·<br>中文汉字<br>哈哈<br>2）sql注入<br>3）XSS<br>4）纯数字、纯英文、组合、大小写、<br>5）换行<br>6）超长<br>7）空</p></blockquote><h4 id="5-4-8-SSL-TSL"><a href="#5-4-8-SSL-TSL" class="headerlink" title="5.4.8.SSL/TSL"></a>5.4.8.SSL/TSL</h4><p>https等其他协议使用的加密协议SSL/TSL是否是安全的，使用开源工具sslsplit检测，工具下载地址<a href="https://github.com/droe/sslsplit/tree/7677fe06557509e95e548318909c1a328b6f6069。" target="_blank" rel="noopener">https://github.com/droe/sslsplit/tree/7677fe06557509e95e548318909c1a328b6f6069。</a><br>检查加协议版本及套件的办法Nmap -sV -p port –script ssl-enum-ciphers ip<br>1、加密协议SSLv2v3需要全部禁用<br>2、TSL的加密密套件部分已经不安全需要配置删除</p><h4 id="5-4-9-WiFi安全"><a href="#5-4-9-WiFi安全" class="headerlink" title="5.4.9.WiFi安全"></a>5.4.9.WiFi安全</h4><p>对象（Wep、Wpa）、原理、工具</p><h3 id="5-5-操作系统安全"><a href="#5-5-操作系统安全" class="headerlink" title="5.5.操作系统安全"></a>5.5.操作系统安全</h3><p><a href="http://www.centoscn.com/CentosSecurity/" target="_blank" rel="noopener">http://www.centoscn.com/CentosSecurity/</a><br>工具：openvas、nessus<br>测试方式：可在本地安装nessus home版完来测试</p><p>影响较大的漏洞<br>CVE-2016-5195：Linux系统本地提权漏洞，脏牛漏洞。（2016-10）【通吃型】。</p><h4 id="5-5-1-本地提权"><a href="#5-5-1-本地提权" class="headerlink" title="5.5.1.本地提权"></a>5.5.1.本地提权</h4><p>1）Windows下提权（我们是linux服务器，这个暂时不关注）<br>2）Linux下提权—-<br>利用系统漏洞提权（主动提权）<br>配置不当提权（被动提权）<br>Sudo提权—/etc/sudoers文件配置<br>Crontab提权–定时执行的脚本的权限配置<br>Init.d提权–/etc/init.d此目录下的文件的写权限要严格禁止<br>Environment提权–用户的profile、environment等的权限设置、还有su命令而不是su - 方式切换到root用户<br>Setuid提权–通过给脚本或者bash添加s权限获取root权限</p><h4 id="5-5-2-各种木马"><a href="#5-5-2-各种木马" class="headerlink" title="5.5.2.各种木马"></a>5.5.2.各种木马</h4><p>键盘记录木马<br>绑定端口木马<br>回连木马<br>端口复用木马<br>远程控制木马</p><h4 id="5-5-3-密码破解"><a href="#5-5-3-密码破解" class="headerlink" title="5.5.3.密码破解"></a>5.5.3.密码破解</h4><p>本地破解–md5、linux shadow、ntlm/lm<br>远程破解–ssh、httpauth、webform、pop/Smtp</p><h3 id="5-6-数据库安全"><a href="#5-6-数据库安全" class="headerlink" title="5.6.数据库安全"></a>5.6.数据库安全</h3><p>Mysql<br><a href="http://www.w3resource.com/mysql/mysql-security.php" target="_blank" rel="noopener">http://www.w3resource.com/mysql/mysql-security.php</a><br>Redis<br>影响较大的漏洞：<br>CVE-2016-6662 mysql本地提权漏洞。（2016-9）</p><h4 id="5-7-软件的发布与安装安全"><a href="#5-7-软件的发布与安装安全" class="headerlink" title="5.7.软件的发布与安装安全"></a>5.7.软件的发布与安装安全</h4><p>1、下载的软件有没有提供签名<br>2、下载后安装是否有校验机制</p><h4 id="5-8-手机端的安全"><a href="#5-8-手机端的安全" class="headerlink" title="5.8.手机端的安全"></a>5.8.手机端的安全</h4><p>1、app的签名、反逆向<br>（apk加固步骤：<a href="http://jingyan.baidu.com/article/b2c186c8cd1a71c46ef6ffcd.html，数字签名：http://blog.csdn.net/kickxxx/article/details/18252881）" target="_blank" rel="noopener">http://jingyan.baidu.com/article/b2c186c8cd1a71c46ef6ffcd.html，数字签名：http://blog.csdn.net/kickxxx/article/details/18252881）</a><br>2、用户隐私<br>本地保存用户密码、无论加密与否<br>敏感信息隐私信息，如聊天记录、关系链、银行卡号等是否加密保存<br>配置文件等是否保存到外部设备上<br>保存到外部设备的信息加载前判断是否被篡改<br>3、文件权限<br>App所在目录不允许其他组成员读写<br>4、网络通讯<br>重要敏感数据传输加密<br>5、运行时解释保护<br>嵌有解释器的软件XSS、SQL注入等<br>外部连接的是否有URL欺骗等漏洞<br>6、组件权限保护<br>禁止App内部组件被任意第三方程序调用<br>调用外部组件先验证签名<br>7、升级<br>升级包完整性、合法性校验，避免被劫持<br>8、3rd库<br>跟进第三方库的更新<br><a href="http://blog.nsfocus.net/mobile-app-security-security-test/" target="_blank" rel="noopener">http://blog.nsfocus.net/mobile-app-security-security-test/</a><br><a href="http://www.zhihu.com/question/24083362" target="_blank" rel="noopener">http://www.zhihu.com/question/24083362</a></p><h3 id="5-9-静态代码分析（纯白盒）"><a href="#5-9-静态代码分析（纯白盒）" class="headerlink" title="5.9.静态代码分析（纯白盒）"></a>5.9.静态代码分析（纯白盒）</h3><p>1、危险函数、方法、关键字<br>2、工具检测 findbugs<br>3、逻辑漏洞</p><h3 id="5-10-抓包走读代码（灰盒测试）"><a href="#5-10-抓包走读代码（灰盒测试）" class="headerlink" title="5.10.抓包走读代码（灰盒测试）"></a>5.10.抓包走读代码（灰盒测试）</h3><p>1、前台功能执行、中间工具抓包、后端代码走读的形式（过程：结合业务思路查看中间参数、走读后端代码跟踪参数处理，结合常见WEB安全漏洞形式匹配问题，抓包重放验证问题。）<br>2、可发现的常见漏洞形式：越权、XSS、sql注入、参数合理性等</p><h2 id="6-安全测试的原则"><a href="#6-安全测试的原则" class="headerlink" title="6.安全测试的原则"></a>6.安全测试的原则</h2><p>攻击面最小化<br>默认安全<br>最小权限原则<br>深度防御原则（多角度、冗余的）<br>安全的失败<br>外部系统是不安全的<br>职责分离（权值分离）<br>不依赖隐晦的安全性<br>简单<br>正确的修复安全性问题<br>客户端的输入是不可信的<br>我的理解的判断依据：<br>1、我们设计的程序的动作是确定的，而程序运行中产生了超出这个预期动作的部分，我们都可认为它是不安全的，需要改正的。<br>2、问题产生在我们的设计得程序动作本身就是不符合现有的大环境下的安全标准。</p><h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7.参考资料"></a>7.参考资料</h2><p><a href="http://www.owasp.org.cn/" target="_blank" rel="noopener">http://www.owasp.org.cn/</a> OWASP 测试指南<br><a href="http://www.wooyun.org/" target="_blank" rel="noopener">http://www.wooyun.org/</a><br><a href="http://bbs.51cto.com/thread-1039046-1.html" target="_blank" rel="noopener">http://bbs.51cto.com/thread-1039046-1.html</a></p><h2 id="8-系统结构简图"><a href="#8-系统结构简图" class="headerlink" title="8.系统结构简图"></a>8.系统结构简图</h2><h2 id="9-涉及的常用工具"><a href="#9-涉及的常用工具" class="headerlink" title="9.涉及的常用工具"></a>9.涉及的常用工具</h2><p>1、Burpsuit<br>2、Watchweb<br>3、Httprint<br>4、Httpwatch<br>5、Appscan<br>6、Awvs<br>7、Nmap<br>8、Search and replace<br>9、Sqlmap<br>10、secureCAT<br>11、–验证码识别工具<br>12、–Whois查询<br>13、DirBuster<br>14、Fiddler<br>15、Wireshark<br>16、Firefox hackbar<br>17、在线js执行（<a href="http://js.do/）" target="_blank" rel="noopener">http://js.do/）</a></p><h3 id="9-1-文件名上传XSS"><a href="#9-1-文件名上传XSS" class="headerlink" title="9.1.文件名上传XSS"></a>9.1.文件名上传XSS</h3><p>1、此种问题的特点：首先，是上传点；第二，在上传后使用了上传的文件名（可能又改名，但是记录了文件名）；<br>2、系统问题发生点医生系统-终审报告-附件<br>3、此处符合了1，查看显示文件名的界面的代码<br>` <a href="javascript:void(0);" onclick="downloadFile('hospital/0100101/2016/06/03/DR/369/20160603140244.gif','aaa.gif')" target="_blank" rel="noopener">aaa.gif</a><br>以上语句2处出现了文件名，即有两个地方是我们可能注入代码的地方<br>先看后一个位置，超链接内的文字，普通文本<br>考虑尝试最简单的<script>alert(1)</script>，尝试设置文件名为<script>alert(1)</script>a.gif<br>发现字符/后的部分被作为了文件名，考虑后台代码有字符截断或者限制长度。并且确认我们的字符&lt;&gt;是接受的。<br>下一步设置文件名为aaaaaaaaaaa.gif，发送多次尝试确认文件名可以的最长长度为24个字符，也就是后缀前面的代码只能有20个字符。<br>再尝试b.gif，确认/<br>失败，什么原因？再尝试a/b.gif<br>确认/是有特殊处理的，会被截断，那么其他编码试试？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;script&gt;alert(2)&lt;%2Fscript&gt; &lt;%2Fscript&gt;可上传，可是整体超长</span><br><span class="line">&lt;script&gt;alert(3)&lt;&amp;#x2f;script&gt; 可上传，可是整体超长</span><br><span class="line">&lt;script&gt;alert(4)&lt;&amp;#47;script&gt; 可上传，可是整体超长</span><br><span class="line">&lt;script&gt;alert(5)&lt;\u2fscript&gt; \和/同样的效果</span><br><span class="line">&lt;script&gt;alert(6)&lt;\u002fscript&gt; \和/同样的效果</span><br></pre></td></tr></table></figure></p><p>好吧，换个思路；这个地方有多个文件上传，能不能用两个文件名组合？试试<br>上传<script>a.gif<br>再上传&lt;alert(2)&lt;%2Fscript&gt;b.gif</p><p>刷新界面看下<br>还是不能执行，后面的脚本都被当成javascript脚本内容解析了，%2F不会被浏览器编码反解析回来；只能是屏蔽了下面的到</script>前的所有代码，其实这里可以说已经是有问题了，改变了原来界面的语义<br>这个位置的文件名貌似行不通啊，我们再来看原始的代码，再看看第一处<br><code>&lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;downloadFile(&#39;hospital/0100101/2016/06/03/DR/369/20160603140244.gif&#39;,&#39;aaa.gif&#39;)&quot;&gt;aaa.gif&lt;/a&gt;两种思路：A）闭合a，在后面形成代码；B）在标签内形成属性事件先看B思路，onclick=&quot;downloadFile(&#39;hospital/0100101/2016/06/03/DR/369/20160603140244.gif&#39;,&#39;aaa.gif&#39;)&quot;，着力点在这里，要闭合’)”，再给一个事件属性如onmouseover=””试试文件名’)”onmouseover=”alert(1)”，尝试后发现”和’，都是问题啊会被处理，这个没办法规避啊再看看A思路同样避不开’”啊在回头看看，谁说执行脚本不需要&lt;scritp&gt;标签啊</code> <a href="javascript:void(0);" onclick="downloadFile('hospital/0100101/2016/06/03/DR/369/20160603140244.gif','aaa.gif')" target="_blank" rel="noopener">aaa.gif</a><br>文件名不包含’”/ \，可以考虑的还是标签的属性，于是看二位置换成<a onclick="alert(1)">a.gif如何<br>再看界面<br>OK，XSS成功，所有查看这份报告的，点击了这个附件的都会执行这个事件。<br>当然也可以换成其他属性触发事件啦，有兴趣可以试试。<br>请不要忽略这个断字符的仅能alert(1)的问题，这个问题也可能和其他漏洞结合发挥大的威力哦（比如值同域然后钓鱼）</a></p><h3 id="9-2-XXE漏洞详解"><a href="#9-2-XXE漏洞详解" class="headerlink" title="9.2.XXE漏洞详解"></a>9.2.XXE漏洞详解</h3><p>什么是XXE ? 就是我们所说的所谓xml实体注入。entity翻译为”实体”。它的作用类似word中的”宏”，也可以理解为DW中的模板，你可以预先定义一个entity，然后在一个文档中多次调用，或者在多个文档中调用同一个entity(XML定义了两种类型的entity。一种是我们这里说的普通entity，在XML文档中使用；另一种是参数entity，在DTD文件中使用。)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE filename</span><br><span class="line">[</span><br><span class="line">&lt;!ENTITY entity-name &quot;entity-content&quot;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure></p><p>参考：<br>http://blog.csdn.net/dongfengkuayue/article/details/50240157<br>http://drops.wooyun.org/papers/1911</p><h4 id="9-2-1-XXE任意文件读取"><a href="#9-2-1-XXE任意文件读取" class="headerlink" title="9.2.1.XXE任意文件读取"></a>9.2.1.XXE任意文件读取</h4><p>构造如下xml文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE file [</span><br><span class="line">&lt;!ENTITY file SYSTEM &quot;file:///C:/Windows/System32/drivers/etc/hosts&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;username&gt;&amp;file;&lt;/username&gt;</span><br><span class="line">&lt;select id=&quot;chartForConsultation&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">&amp;file;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>1、使用最原始的javax.xml.parsers，标准的jdk api</p><p>在解析结果总解析出了hosts文件的内容。<br>2、使用dom4j后程序变得更简单<br>3、使用JDOM</p><h4 id="9-2-2-XXE拒绝服务攻击"><a href="#9-2-2-XXE拒绝服务攻击" class="headerlink" title="9.2.2.XXE拒绝服务攻击"></a>9.2.2.XXE拒绝服务攻击</h4><p>1、sax解析类已经做了处理</p><p>2、循环调用</p><h2 id="10-名词解释"><a href="#10-名词解释" class="headerlink" title="10.名词解释"></a>10.名词解释</h2><h4 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h4><p>Web应用防护系统（也称：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。</p><h4 id="单点登陆"><a href="#单点登陆" class="headerlink" title="单点登陆"></a>单点登陆</h4><p>单点登录（Single Sign On），简称SSO，是目前比较流行的企业业务整合解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有有相互信任的应用系统。</p><h4 id="PR7"><a href="#PR7" class="headerlink" title="PR7"></a>PR7</h4><p>PR值全称为PageRank(网页级别)，取自Google的创始人LarryPage。它是Google排名运算法则（排名公式）的一部分，是Google用于用来标识网页的等级/重要性的一种方法，是Google用来衡量一个网站的好坏的唯一标准。在揉合了诸如Title标识和Keywords标识等所有其它因素之后，Google通过PageRank来调整结果，使那些更具“等级/重要性”的网页在搜索结果中令网站排名获得提升，从而提高搜索结果的相关性和质量。级别从1到10级，10级为满分。PR值越高说明该网页越受欢迎（越重要）</p><h4 id="OAuth授权"><a href="#OAuth授权" class="headerlink" title="OAuth授权"></a>OAuth授权</h4><p>OAuth(开放授权)是一个开放标准。<br>允许第三方网站在用户授权的前提下访问在用户在服务商那里存储的各种信息。<br>而这种授权无需将用户提供用户名和密码提供给该第三方网站。<br>OAuth允许用户提供一个令牌给第三方网站，一个令牌对应一个特定的第三方网站，同时该令牌只能在特定的时间内访问特定的资源.<br>详细参考：http://justcoding.iteye.com/blog/1950270</p><h4 id="REST-WebService"><a href="#REST-WebService" class="headerlink" title="REST WebService"></a>REST WebService</h4><p>REST（Representational State Transfer）是一种轻量级的Web Service架构风格，其实现和操作明显比SOAP和XML-RPC更为简洁，可以完全通过HTTP协议实现，还可以利用缓存Cache来提高响应速度，性能、效率和易用性上都优于SOAP协议。</p><h4 id="隐写术"><a href="#隐写术" class="headerlink" title="隐写术"></a>隐写术</h4><p>隐写术是关于信息隐藏，即不让计划的接收者之外的任何人知道信息的传递事件（而不只是信息的内容）的一门技巧与科学。隐写术英文作“Steganography”，来源于约翰尼斯·特里特米乌斯的一本看上去是有关黑魔法，实际上是讲密码学与隐写术的一本书Steganographia中。此书书名来源于希腊语，意为“隐秘书写”。</p><h4 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h4><p>CTF（Capture the Flag）夺旗比赛。</p><h4 id="MIME编码"><a href="#MIME编码" class="headerlink" title="MIME编码"></a>MIME编码</h4><p>MIME（Multipurpose Internet Mail Extensions）多部分(multi-part)、多媒体电子邮件和WWW超文本的一种编码标准，用于传送诸如图形、声音和传真等非文本数据。</p><h4 id="PKCS"><a href="#PKCS" class="headerlink" title="PKCS"></a>PKCS</h4><p>The Public-Key Cryptography Standards (PKCS)是由美国RSA数据安全公司及其合作伙伴制定的一组公钥密码学标准，其中包括证书申请、证书更新、证书作废表发布、扩展证书内容以及数字签名、数字信封的格式等方面的一系列相关协议。<br>PKCS#1：定义RSA公开密钥算法加密和签名机制，主要用于组织PKCS#7中所描述的数字签名和数字信封。</p><h4 id="WASC"><a href="#WASC" class="headerlink" title="WASC"></a>WASC</h4><p>Web Application Security Consortium（WASC），是一个由安全专家、行业顾问和诸多组织的代表组成的国际团体。WASC 组织的关键项目之一是“Web 安全威胁分类”，也就是将 Web 应用所受到的威胁、攻击进行说明并归纳成具有共同特征的分类。该项目的目的是针对 Web 应用的安全隐患，制定和推广行业标准术语。</p><h4 id="OWASP"><a href="#OWASP" class="headerlink" title="OWASP"></a>OWASP</h4><p>Open Web Application Security Project（OWASP），该组织致力于发现和解决不安全 Web 应用的根本原因。它们最重要的项目之一是“Web 应用的十大安全隐患”，总结了目前 Web 应用最常受到的十种攻击手段，并且按照攻击发生的概率进行了排序。这个项目的目的是统一业界最关键的 Web 应用安全隐患，并且加强企业对 Web 应用安全的意识。</p><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS(Cross Origin Resourse-Sharing)，跨域资源共享。</p><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><p>Node.js是一个Javascript运行环境(runtime)。 实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node.js对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更 好。<br>[1]  Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行的数据密集型的实时应用。</p><h4 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h4><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）<br>渗透攻击、攻击载荷payload、shellcode</p><h4 id="CWE"><a href="#CWE" class="headerlink" title="CWE"></a>CWE</h4><p>CWE(Common Weakness Enumeration),通用弱点枚举。软件弱点分类，更好地识别缺陷、修复阻止缺陷实现自动化。</p><h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>CDN(ConTent Deliver network)内容分发网络。以负载均衡为核心。</p><h4 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h4><p>Maven项目对象模型（POM），可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。</p><h4 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h4><p>WebRTC（Web Real-Time Commutication）Web实时通讯的缩写，就是使用Web浏览器完成实时的语音对话和视屏对话的技术。</p><h4 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h4><p>APT（Advance Persistent Thread）高级可持续性攻击。APT是黑客以窃取核心资料为目的，针对客户所发动的网络攻击和侵袭行为，是一种蓄谋已久的“恶意商业间谍威胁”。这种行为往往经过长期的经营与策划，并 具备高度的隐蔽性。APT的攻击手法，在于隐匿自己，针对特定对象，长期、有计划性和组织性地窃取数据，这种发生在数字空间的偷窃资料、搜集情报的行为， 就是一种“网络间谍”的行为。</p><h4 id="CVSS"><a href="#CVSS" class="headerlink" title="CVSS"></a>CVSS</h4><p>Common Vulnerability Scoring System，即“通用漏洞评分系统”，是一个“行业公开标准，其被设计用来评测漏洞的严重程度，并帮助确定所需反应的紧急度和重要度”。<br>CVSS是安全内容自动化协议（SCAP）[2]的一部分，通常CVSS同CVE一同由美国国家漏洞库（NVD）发布，由美国国家基础建设咨询委员会（NIAC）委托制作，是一套公开的评测标准，经常被用来评比企业资讯科技系统的安全性，并受到eBay、(Symantec)、思科(Cisco)、甲古文(Oracle)等众多厂商支援。<br>CVSS的目标是为所有软件安全漏洞提供一个严重程度的评级<br> 这就意味着CVSS旨在为一个已知的安全漏洞的严重程度提供一个数值(分数)，而不管这个安全漏洞影响的软件类型是什么，不管它是操作系统、杀毒软件、数据库、邮件服务器、桌面还是商务应用程序。由于这个评分范围非常广，这个评分系统把能够完全攻破操作系统层的已知安全漏洞评为基准分数10.0分。换句话说，CVSS基准分数为10.0分的安全漏洞一般指能够完全攻破系统的安全漏洞，典型的结果是攻击者完全控制一个系统，包括操作系统层的管理或者“根”权限。例如，国家安全漏洞数据库中一个第三方产品中的这种安全漏洞被解释为，攻击者能够安装程序;观看、修改或者删除数据;或者创建拥有用户全部权利的新账户。<br>它的主要目的是帮助人们建立衡量漏洞严重程度的标准，使得人们可以比较漏洞的严重程度，从而确定处理它们的优先级。CVSS得分基于一系列维度上的测量结果，这些测量维度被称为量度（Metrics）。漏洞的最终得分最大为10，最小为0。得分7~10的漏洞通常被认为比较严重，得分在4~6.9之间的是中级漏洞，0~3.9的则是低级漏洞<br>CVSS系统包括三种类型的分数</p><ul><li>基准分数，暂时的和环境的。每一个分数都要衡量这个安全漏洞的不同属性。甲骨文在严重补丁更新文件中提供这个“基准分数”。这个基准分数有如下特点：</li><li>这个基准分数具体指一个指定的安全漏洞。</li><li>这个基准分数是不变的。</li><li>它不是具体针对一个客户的技术IT环境的<h2 id="11-那些网络大牛们的语句"><a href="#11-那些网络大牛们的语句" class="headerlink" title="11.那些网络大牛们的语句"></a>11.那些网络大牛们的语句</h2>以安全防御方的角度来看，防御的广度比深度更具优先级，这也是信息安全中木桶原理的体现。<br>网络世界如此的年轻，还没有发展出自己独立的行为规范。<br>我认为安全的核心理念只有两种：<br>一是对无序的内外环境执行线性秩序化策略，构建强韧的防护体系，为系统提供“免疫”能力。<br>二是对无序的内外环境执行非线性秩序化策略，构建反脆弱性防护体系，为系统提供“进化”能力。<br>安在<br>安全的三要素：机密性、完整性、可用性<br>防御的一些思想：<br>白名单思想、深度防御、数据与代码分离、不可预测性、缩小攻击面<h2 id="12-其他"><a href="#12-其他" class="headerlink" title="12.其他"></a>12.其他</h2>我的一些理解：<br>1、安全中总谈到做安全需要首先确认信任域与信任边界，信任边界的概念主要是从这个网络物理结构体系的形式来体现的，比如一般在网闸或者防火墙之类的的设备处作为边界，内部形成一个个安全域。而我们的互联网系统是以云为依托，打破了原来的那种概念。物理层对我们来说是不透明的，以服务提供商的逻辑服务形式体现为8台服务器，2台数据库服务器，2台负载均衡服务器。并且这些服务器之间并没有配置相互的信任关系，这就形成了我们的安全实际形态为多处单点形式。<br>仔细来看这12个单点，首先2台负载均衡，只提供负载均衡服务其他均不需要我们看护，其做了哪些措施除了分配连接外一概不知，所以可以从我们的安全形态圈摒弃掉。剩下的10台服务器，彼此独立，互相不应该信任，彼此交互均应该有有效认证行为。<br>当然，其彼此的交互也被分为了两种，一是大网交互，二是内网交互。这里的大网内网我们就需要和阿里的网络相结合。内网交互就在阿里的相对安全的一个域，不防叫内域，相对的大网交互就在阿里的相对不安全的域和互联网上了，这是一个不可信的不安全的区域，不防叫外域。这种结构就应该和我们的业务相结合，比如我们的10台服务器要彼此访问，同时此访问服务不需要提供给互联网，我们就可以把业务单独配置到内域，如果业务是提供给互联网的，那么配置到外域或者内域和外域。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-安全测试在做什么？&quot;&gt;&lt;a href=&quot;#1-安全测试在做什么？&quot; class=&quot;headerlink&quot; title=&quot;1.安全测试在做什么？&quot;&gt;&lt;/a&gt;1.安全测试在做什么？&lt;/h2&gt;&lt;p&gt;扫描？在很多人的眼中，做安全的就是整天拿个工具在哪里做扫描操作，使用各种不同的工具做扫描。是的，扫描是安全测试的很重要的一部分，扫描可以快速有效的发现问题。扫描工具的易用性、方便性决定了重要地位。但是扫描工具的局限性、程序的不够灵活等缺点也是显而易见的。不管是扫描报告的分析、漏洞的深度挖掘、测试的组织等等的工作都离不开安全测试人员，所以只能说扫描工具减轻了测试人员的工作量，是安全测试的一种手段。&lt;/p&gt;
&lt;h2 id=&quot;2-安全测试者是怎样定位自己的？&quot;&gt;&lt;a href=&quot;#2-安全测试者是怎样定位自己的？&quot; class=&quot;headerlink&quot; title=&quot;2.安全测试者是怎样定位自己的？&quot;&gt;&lt;/a&gt;2.安全测试者是怎样定位自己的？&lt;/h2&gt;&lt;p&gt;我们经常可以从身边的朋友口中听到一些有关安全的名称，向什么软件安全、信息安全、网络安全、计算机安全等一些词组，这些领域都是做安全的，那么我们是属于哪一个呢？&lt;br&gt;大家可以上百度百科查看下这些词组的概念。软件安全往小了说就是某一个软件产品，说大了除了硬件就是软件了啊。信息安全看名字我们就知道关键是信息两个字，但是什么是信息呢，客户的数据还是一切有用的数据？网络安全，什么是网络，网络系统硬件、软件这都是写模糊的可大可小的概念。在看计算机安全，PC？服务器？路由器？好吧我们可以看到这些概念往大了说就成了组成我们今天互联网的各种设备包括各种的嵌入式机器、外接USB、浴室柜尺寸价格专卖蓝牙等设备的共同体的硬软件，以及使用、维护、木桶箱子专卖厂家价格管理等这些东西的人的整个的安全问题。在看他们的区别，他们已不同的地方作为其主要关注点，或者说出发点，他们并没有明显的界线却有着自己的侧重点。而我们的侧重点是什么呢，我们产品是一个什么样的产品呢？我们有WEB服务、接口服务、文件服务、视屏等服务等我们把它们统一称为我们的系统，那么我们就是在做这个系统的安全测试，所以我觉得我们应该定位为系统安全测试。&lt;br&gt;当然我们的系统运行中也涉及到人、涉及到硬件，&lt;br&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="安全渗透测试" scheme="http://xyunlay.github.io/tags/%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>robot framework + python实现http接口自动化测试框架</title>
    <link href="http://xyunlay.github.io/2020/05/08/robot%20framework%20+%20python%E5%AE%9E%E7%8E%B0http%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    <id>http://xyunlay.github.io/2020/05/08/robot framework + python实现http接口自动化测试框架/</id>
    <published>2020-05-08T02:55:00.000Z</published>
    <updated>2021-01-26T02:33:58.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础框架选择"><a href="#基础框架选择" class="headerlink" title="基础框架选择"></a>基础框架选择</h2><p>最方便的方法就是用python直接写代码，代码和测试数据分离，测试数据放在excel中保存。这种实现最快捷方便，但也有些缺点：<br>（1）用例管理不太方便，不直观；<br>（2）HTMLTestRunner输出报告做的比较烂。<br>相较而言，robot framework具有用例管理清晰，输出报告美观的特点。但robot的缺点就是编码起来不如python直接写代码方便。所以，为了快速搭建http接口自动化框架用于回归测试，我直接用python写了一个框架。为了后续长远考虑，便于用例管理，测试报告美观，且集成到测试平台工具化以及推广给rd和其他qa同学使用，又用robot搭建了一套框架。本文就详细说明该搭建过程。</p><h2 id="搭建思路"><a href="#搭建思路" class="headerlink" title="搭建思路"></a>搭建思路</h2><p>框架采用robot和python实现，因为robot中的复杂逻辑实现起来比较繁琐，故选择用python实现，然后以外部库的形式导入robot中使用。测试用例数据保存在excel中。<br>使用过robot的人了解，robot中测试维度划分为测试套件（Test Suite）和测试用例（Test Case），一个Suite为一组Case的集合，每个Case对应为我们手工执行测试时的Case。<br>假设测试一个路径为/areaplug/showCityName的http接口，常规方法是在robot中新建一个showCityName的Suite，其下包含测试该http接口的用例集，如下图所示：<br><a id="more"></a><br><img src="/assets/blogImg/robot framework + python1.jpg" alt="jeikou.xml"></p><ul><li>showCityName Test Suite<br>倘若测试该接口有20个异常用例，则建立20条相应的test case。但是，对于测试http接口来讲，以上用例无非就是请求参数和响应不一样而已，发送请求的逻辑是一模一样的。所以，这20条test case其实用一条test case就能实现了，在这1条case中分别遍历读取20个异常用例的测试数据执行测试就ok了。所以最后构造的suite和case如下：<br><img src="/assets/blogImg/robot framework + python2.jpg" alt="jeikou.xml"></li><li>接口case<br>图中，batch_Request为测试套件，其下的每个robot的test case对应一个http接口测试场景，比如测试路径为/areaplug/showCityName的http接口，该接口的所有正向和异常用例均在test_showCityName中实现，在test_showCityName中读取测试数据文件，获取该接口的测试用例数目，遍历每一条测试用例数据，调用http_Request下的sendHttpRequest发送http请求。其实，这里的test_showCityName就相当于test suite了，而遍历测试数据文件中的每一行测试数据去调用sendHttpRequest时，就相当于生成了一条test case，这样就可以将一个接口的所有测试用例用robot的一条test case实现（实质是robot的一条test case相当于一个test suite，在这个robot的test case中动态生成n条test case）。整个流程如下图所示：<br><img src="/assets/blogImg/robot framework + python3.jpg" alt="jeikou.xml"></li><li>框架流程图<h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3>测试数据保存在excel中，每一个sheet页对应一个测试场景，即一个http接口。该sheet也保存有测试该接口的所有测试用例数据以及接口路径和请求方法，如下图所示（这里仅仅是一个demo，实际回归测试时，会有大量的用例和数据）：<br><img src="/assets/blogImg/robot framework + python4.jpg" alt="jeikou.xml"></li><li>测试数据<h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3>整个工程目录如下：<br>E:\LLF_58TESTSUITES\JZ_WEBINTERGRATION\ROBOT_CODE<br>│  execPybot.bat<br>│<br>├─pycode<br>│  │  Common_Excel.py<br>│  │  Common_Excel.pyc<br>│  │  Common_Exec.py<br>│  │  Common_Exec.pyc<br>│  │  testHTTP.py<br>│  │  <strong>init</strong>.py<br>│  │<br>│  ├─.idea<br>│  │  │  misc.xml<br>│  │  │  modules.xml<br>│  │  │  pycode.iml<br>│  │  │  workspace.xml<br>│  │  │<br>│  │  └─inspectionProfiles<br>│  └─<strong>pycache</strong><br>│          Common_Excel.cpython-36.pyc<br>│          Common_Exec.cpython-36.pyc<br>│          <strong>init</strong>.cpython-36.pyc<br>│<br>├─report<br>│  │  log.html<br>│  │  output.xml<br>│  │  report.html<br>│  │<br>│  └─TestCaseReport<br>│      ├─result_calendar<br>│      │      log_20180130195712.html<br>│      │      output_20180130195712.xml<br>│      │      report_20180130195712.html<br>│      │<br>│      ├─result_getScheduleFlags<br>│      │      log_20180130195710.html<br>│      │      output_20180130195710.xml<br>│      │      report_20180130195710.html<br>│      │<br>│      └─result_showCityName<br>│              log_20180130195707.html<br>│              output_20180130195707.xml<br>│              report_20180130195707.html<br>│<br>├─rfcode<br>│  │  batch_Request.txt<br>│  │  http_Request.txt<br>│  │  <strong>init</strong>.robot<br>│  │<br>│  ├─关键字<br>│  │      关键字index.txt<br>│  │      自定义关键字.txt<br>│  │<br>│  └─配置信息<br>│          config.txt<br>│          configIndex.txt<br>│          RequestHeaders.txt<br>│<br>└─testData<pre><code>testData.xlsx</code></pre>工程有4部分构成：</li><li>pycode<br>由于robot中复杂逻辑的实现比较繁琐，所以将一些复杂逻辑直接用python代码实现，然后以外部库的形式导入robot中调用。共有2个文件:<br>** Common_Excel.py<br>主要负责对测试数据excel文件的读取操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">coding: utf-8</span><br><span class="line">import xlrd</span><br><span class="line">def getTestData(testDataFile, testScene, host, caseNo):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    从excel中获取测试数据</span><br><span class="line">    :param testDataFile: 测试数据文件</span><br><span class="line">    :param testScene: 测试场景</span><br><span class="line">    :param host: 服务器主机</span><br><span class="line">    :param caseNo: 用例No</span><br><span class="line">    :param method: 请求方法</span><br><span class="line">    :return: url，用例No，用例名称，请求参数，预期返回码，预期响应内容</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    caseNo = int(caseNo)</span><br><span class="line">    data = xlrd.open_workbook(testDataFile)</span><br><span class="line">    table = data.sheet_by_name(testScene)</span><br><span class="line">    cols = table.ncols</span><br><span class="line">resource_path = table.cell(0, 1).value  # 文件路径</span><br><span class="line">    url = &quot;http://&quot; + host + resource_path  # 访问的url</span><br><span class="line">    method = table.cell(1, 1).value  # 请求方法</span><br><span class="line">dict_params = &#123;&#125;</span><br><span class="line">    for i in range(cols):</span><br><span class="line">        dict_params[table.cell(2, i).value] = table.cell(caseNo+2, i).value</span><br><span class="line">caseNo = dict_params.pop(&quot;caseNo&quot;)</span><br><span class="line">    caseName = dict_params.pop(&quot;caseName&quot;)</span><br><span class="line">    expectCode = dict_params.pop(&quot;expect_code&quot;)</span><br><span class="line">    expectCotent = dict_params.pop(&quot;expect_content&quot;)</span><br><span class="line">    testName = &quot;TestCase&quot; + caseNo + &quot;_&quot; + caseName</span><br><span class="line">return method, url, caseNo, testName, dict_params, expectCode, expectCotent</span><br><span class="line">def getTestCaseNum(testDataFile, testScene):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    获取testScene测试场景中的测试用例数</span><br><span class="line">    :param testDataFile: 测试数据文件</span><br><span class="line">    :param testScene: 测试场景</span><br><span class="line">    :return: 测试用例数</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    data = xlrd.open_workbook(testDataFile)</span><br><span class="line">    table = data.sheet_by_name(testScene)</span><br><span class="line">    rows = table.nrows</span><br><span class="line">    return rows-3</span><br><span class="line">def getTestHttpMethod(testDataFile, testScene):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    获取testScene测试场景的请求方法</span><br><span class="line">    :param testDataFile: 测试数据文件</span><br><span class="line">    :param testScene: 测试场景</span><br><span class="line">    :return: 请求方法</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    data = xlrd.open_workbook(testDataFile)</span><br><span class="line">    table = data.sheet_by_name(testScene)</span><br><span class="line">    method = table.cell(1, 1).value  # 请求方法</span><br><span class="line">    return method</span><br></pre></td></tr></table></figure></li></ul><p>** Common_Exec.py<br>主要负责根据测试数据批量构造pybot命令来调用robot执行测试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">coding: utf-8</span><br><span class="line">import requests</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">def batch_Call(robot_testSuite, robot_testCase, testScene, caseNum, testCaseReportPath, execTime):</span><br><span class="line">    # 批量执行testScene测试场景下的用例</span><br><span class="line">    :param robot_testSuite: robot testSuite路径</span><br><span class="line">    :param robot_testCase: robot testCase路径</span><br><span class="line">    :param testScene: 测试场景</span><br><span class="line">    :param caseNum: 用例数</span><br><span class="line">    :param testCaseReportPath: 业务用例测试报告路径</span><br><span class="line">    :param execTime: 执行时间</span><br><span class="line">    :return:</span><br><span class="line">   </span><br><span class="line">    try:</span><br><span class="line">        for caseNo in range(caseNum):</span><br><span class="line">            testCase = &quot;&quot;</span><br><span class="line">            caseNo = caseNo + 1</span><br><span class="line">            testName = &quot;testcase&quot; + &quot;_&quot; + str(caseNo)</span><br><span class="line">            output_dir = &quot;-d &quot; + testCaseReportPath + &quot;/result_&#123;0&#125;&quot;.format(testScene)  # 输出目录</span><br><span class="line">            output_xml = &quot;-o output_&#123;0&#125;_&#123;1&#125;.xml&quot;.format(testName, execTime)</span><br><span class="line">            output_log = &quot;-l log_&#123;0&#125;_&#123;1&#125;.html&quot;.format(testName, execTime)</span><br><span class="line">            output_report = &quot;-r report_&#123;0&#125;_&#123;1&#125;.html&quot;.format(testName, execTime)</span><br><span class="line">            variable = &quot;-v caseNo:&quot; + str(caseNo) + &quot; -v testScene:&quot; + testScene</span><br><span class="line">            testCase = &quot;--test &quot; + robot_testCase</span><br><span class="line">            pybot_cmd = &quot;pybot &quot; + output_dir + &quot; &quot; + output_xml + &quot; &quot; + output_log + &quot; &quot; + output_report + &quot; &quot; + variable + &quot; &quot; +  &quot; &quot; + testCase + &quot; &quot; + robot_testSuite</span><br><span class="line">            os.system(pybot_cmd)  # 执行pybot命令</span><br><span class="line">        return &quot;done&quot;</span><br><span class="line">    except Exception as e:</span><br><span class="line">        return &quot;Error: &quot; + str(e)</span><br><span class="line">def send_HttpRequest(url, data=None, headers=None, method=None):</span><br><span class="line">    # 发送http请求</span><br><span class="line">    :param url: 请求的url</span><br><span class="line">    :param data: 请求数据</span><br><span class="line">    :param headers: 请求头</span><br><span class="line">    :param method: 请求方法</span><br><span class="line">    :return: 响应码，响应内容</span><br><span class="line">    </span><br><span class="line">    if method == &quot;get&quot;:</span><br><span class="line">        response = requests.get(url, data, headers=headers)</span><br><span class="line">    if method == &quot;post&quot;:</span><br><span class="line">        response = requests.post(url, data, headers=headers)</span><br><span class="line">    code = str(response.status_code)</span><br><span class="line">    content = response.content.decode(&quot;utf-8&quot;)  # 转码</span><br><span class="line">    return code, content</span><br><span class="line">def cleanLogs(testScene, testCaseReportPath):</span><br><span class="line">    # 删除硬盘中合并前的测试报告</span><br><span class="line">    :param testScene: 测试场景</span><br><span class="line">    :param testCaseReportPath: 业务用例测试报告路径</span><br><span class="line">    :return:</span><br><span class="line"></span><br><span class="line">    testCaseReportPath = testCaseReportPath + &quot;/result_&#123;0&#125;&quot;.format(testScene)</span><br><span class="line">    report_files = testCaseReportPath + &quot;/report_testcase*&quot;</span><br><span class="line">    xml_files = testCaseReportPath + &quot;/output_testcase*&quot;</span><br><span class="line">    log_files = testCaseReportPath + &quot;/log_testcase*&quot;</span><br><span class="line">    cmd = &quot;del &quot; + report_files + &quot; &quot; + xml_files + &quot; &quot; + log_files  # windows</span><br><span class="line">    cmd = cmd.replace(&quot;/&quot;, &quot;\\&quot;)</span><br><span class="line">    print(cmd)</span><br><span class="line">    os.system(cmd)</span><br><span class="line">def getCurtime():</span><br><span class="line">    # 获取当前时间</span><br><span class="line">    :return: 当前时间</span><br><span class="line">    </span><br><span class="line">    return time.strftime(&quot;%Y%m%d%H%M%S&quot;, time.localtime(time.time()))</span><br><span class="line">def mergeReport(testScene, testCaseReportPath, execTime):</span><br><span class="line">    # 合并报告</span><br><span class="line">    :param testScene: 测试场景</span><br><span class="line">    :param testCaseReportPath: 业务用例测试报告路径</span><br><span class="line">    :param execTime: 执行时间</span><br><span class="line">    :return:</span><br><span class="line">    </span><br><span class="line">    try:</span><br><span class="line">        output_dir = &quot;-d &quot; + testCaseReportPath + &quot;/result_&#123;0&#125;&quot;.format(testScene)  # 输出目录</span><br><span class="line">        output_xml = &quot;-o output_&#123;0&#125;.xml&quot;.format(execTime)</span><br><span class="line">        output_log = &quot;-l log_&#123;0&#125;.html&quot;.format(execTime)</span><br><span class="line">        output_report = &quot;-r report_&#123;0&#125;.html&quot;.format(execTime)</span><br><span class="line">        # 被合并的报告</span><br><span class="line">        merge_report = testCaseReportPath + &quot;/result_&#123;0&#125;&quot;.format(testScene) + &quot;/output_testcase_*.xml&quot;</span><br><span class="line">        name = &quot;--name &quot; + testScene</span><br><span class="line">        rebot_cmd = r&quot;rebot &quot; + output_dir + &quot; &quot; + output_xml + &quot; &quot; + output_log + &quot; &quot; + output_report + &quot; &quot; + name + &quot; &quot;  + merge_report</span><br><span class="line">        os.system(rebot_cmd)  # 执行rebot命令</span><br><span class="line">        return &quot;done&quot;</span><br><span class="line">    except Exception as e:</span><br><span class="line">        return &quot;Error: &quot; + str(e)</span><br></pre></td></tr></table></figure></p><ul><li>report<br>该目录用于存放测试报告。其中report目录下的robot测试报告为测试Suite的测试报告，而TestCaseReport下会根据不同的测试场景生成对应该场景名称的测试报告文件夹，其下会包含该测试场景下所有用例的合并报告（即excel中的每一条case会生成一个报告，最后会将这些cases的报告合并为一个报告，作为该测试场景即该http接口的测试报告）。</li><li>rfcode<br>该目录下为robot的代码。<br>** batch_Request.txt<br>batch_Request下包含要测试的各http接口对应的测试场景（即robot的测试用例）。在各测试场景中会设置${testScene}变量，通过该变量去excel文件中对应的sheet页获取相应的测试数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library           ../pycode/Common_Exec.py</span><br><span class="line">Resource          关键字/关键字index.txt</span><br><span class="line">Resource          配置信息/configIndex.txt</span><br><span class="line">Library           ../pycode/Common_Excel.py</span><br><span class="line">*** Test Cases ***</span><br><span class="line">test_showCityName</span><br><span class="line">    [Documentation]    /areaplug/showCityName</span><br><span class="line">    # 测试场景</span><br><span class="line">    $&#123;testScene&#125;    Set Variable    showCityName</span><br><span class="line">    # 请求方法</span><br><span class="line">    $&#123;method&#125;    getTestHttpMethod    $&#123;testDataFile&#125;    $&#123;testScene&#125;</span><br><span class="line">    执行测试    $&#123;testScene&#125;    $&#123;method&#125;</span><br><span class="line">test_getScheduleFlags</span><br><span class="line">    [Documentation]    /ManageSchedule/getScheduleFlags</span><br><span class="line">    # 测试场景</span><br><span class="line">    $&#123;testScene&#125;    Set Variable    getScheduleFlags</span><br><span class="line">    # 请求方法</span><br><span class="line">    $&#123;method&#125;    getTestHttpMethod    $&#123;testDataFile&#125;    $&#123;testScene&#125;</span><br><span class="line">    执行测试    $&#123;testScene&#125;    $&#123;method&#125;</span><br><span class="line">test_calendar</span><br><span class="line">    # 测试场景</span><br><span class="line">    $&#123;testScene&#125;    Set Variable    calendar</span><br><span class="line">    # 请求方法</span><br><span class="line">    $&#123;method&#125;    getTestHttpMethod    $&#123;testDataFile&#125;    $&#123;testScene&#125;</span><br><span class="line">    执行测试    $&#123;testScene&#125;    $&#123;method&#125;</span><br></pre></td></tr></table></figure></li></ul><p>** http_Request.txt<br>在各测试场景中会根据excel中的测试用例记录数目去批量调用http_Request下的sendHttpRequest执行http接口测试。在sendHttpRequest中会根据caseNo去excel中查询相应测试数据，并发送对应的http请求到相应http接口中。收到响应后，与excel中的预期响应码和响应内容做比对。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library           ../pycode/Common_Exec.py</span><br><span class="line">Library           ../pycode/Common_Excel.py</span><br><span class="line">Resource          关键字/关键字index.txt</span><br><span class="line">*** Test Cases ***</span><br><span class="line">sendHttpRequest</span><br><span class="line">    # 获取测试用例数据</span><br><span class="line">    $&#123;method&#125;    $&#123;url&#125;    $&#123;caseNo&#125;    $&#123;testName&#125;    $&#123;dict_params&#125;    $&#123;expectCode&#125;    $&#123;expectCotent&#125;</span><br><span class="line">    ...    getTestData    $&#123;testDataFile&#125;    $&#123;testScene&#125;    $&#123;Host&#125;    $&#123;caseNo&#125;</span><br><span class="line">    # 设置用例说明</span><br><span class="line">    Set Test Documentation    $&#123;testName&#125;</span><br><span class="line">    # 请求头</span><br><span class="line">    $&#123;headers&#125;    获取请求头</span><br><span class="line">    #根据method发送对应的http请求</span><br><span class="line">    $&#123;actualCode&#125;    $&#123;actualContent&#125;    send_HttpRequest    $&#123;url&#125;    $&#123;dict_params&#125;    $&#123;headers&#125;    $&#123;method&#125;</span><br><span class="line">    # 响应码比对</span><br><span class="line">    Should Be Equal    $&#123;actualCode&#125;    $&#123;expectCode&#125;</span><br><span class="line">    # 响应内容比对</span><br><span class="line">    Should Be Equal    $&#123;actualContent&#125;    $&#123;expectCotent&#125;</span><br></pre></td></tr></table></figure></p><p>** 关键字<br>关键字模块主要是对一些复用逻辑的封装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Resource          ../配置信息/configIndex.txt</span><br><span class="line">Library           ../../pycode/Common_Excel.py</span><br><span class="line">Library           ../../pycode/Common_Exec.py</span><br><span class="line">*** Keywords ***</span><br><span class="line">获取请求头</span><br><span class="line">    $&#123;dict_headers&#125;    Create Dictionary    Host=$&#123;Host&#125;    User-Agent=$&#123;User-Agent&#125;    Accept=$&#123;Accept&#125;    Accept-Language=$&#123;Accept-Language&#125;    Accept-Encoding=$&#123;Accept-Encoding&#125;</span><br><span class="line">    ...    Cookie=$&#123;Cookie&#125;    Connection=$&#123;Connection&#125;    Cache-Control=$&#123;Cache-Control&#125;</span><br><span class="line">    Return From Keyword    $&#123;dict_headers&#125;</span><br><span class="line">执行测试</span><br><span class="line">    [Arguments]    $&#123;testScene&#125;    $&#123;method&#125;    # 测试场景|请求方法</span><br><span class="line">    # 获取用例数目</span><br><span class="line">    $&#123;case_num&#125;    getTestCaseNum    $&#123;testDataFile&#125;    $&#123;testScene&#125;</span><br><span class="line">    # 获取当前时间</span><br><span class="line">    $&#123;execTime&#125;    getCurtime</span><br><span class="line">    #批量执行testScene测试场景下的用例</span><br><span class="line">    $&#123;status&#125;    batch_Call    $&#123;httpTestSuite&#125;    $&#123;httpRequestTestCase&#125;    $&#123;testScene&#125;    $&#123;case_num&#125;    $&#123;testCaseReportPath&#125;</span><br><span class="line">    ...    $&#123;execTime&#125;</span><br><span class="line">    log    $&#123;status&#125;</span><br><span class="line">    # 合并报告</span><br><span class="line">    $&#123;status&#125;    mergeReport    $&#123;testScene&#125;    $&#123;testCaseReportPath&#125;    $&#123;execTime&#125;</span><br><span class="line">    log    $&#123;status&#125;</span><br><span class="line">    # 清理合并前的报告</span><br><span class="line">    cleanLogs    $&#123;testScene&#125;    $&#123;testCaseReportPath&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 配置信息<br>配置信息中存储配置信息以及通讯头的信息。通讯头中有cookie，保存有登录信息，通讯头的部分涉及隐私，故这部分数据不放出来了。</strong> config.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">*** Variables ***</span><br><span class="line">$&#123;testDataFile&#125;    E:/llf_58TestSuites/jz_webIntergration/robot_code/testData/testData.xlsx    # 测试数据</span><br><span class="line">$&#123;httpRequestTestCase&#125;    sendHttpRequest    # http请求用例模板</span><br><span class="line">$&#123;httpTestSuite&#125;    E:/llf_58TestSuites/jz_webIntergration/robot_code/rfcode/http_Request.txt    # http请求测试套件</span><br><span class="line">$&#123;testCaseReportPath&#125;    E:/llf_58TestSuites/jz_webIntergration/robot_code/report/TestCaseReport    # 业务用例测试报告路径</span><br><span class="line">RequestHeaders.txt</span><br><span class="line">*** Settings ***</span><br><span class="line">Documentation     请求头信息</span><br><span class="line">*** Variables ***</span><br><span class="line">$&#123;Host&#125;           *******    # 服务器主机</span><br><span class="line">$&#123;User-Agent&#125;     Mozilla/5.0 (Windows NT 6.1; WOW64; rv:56.0) Gecko/20100101 Firefox/56.0    # 浏览器代理</span><br><span class="line">$&#123;Accept&#125;         text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">$&#123;Accept-Language&#125;    en-US,en;q=0.5</span><br><span class="line">$&#123;Accept-Encoding&#125;    gzip, deflate</span><br><span class="line">$&#123;Cookie&#125;         ************</span><br><span class="line">$&#123;Connection&#125;     keep-alive</span><br><span class="line">$&#123;Cache-Control&#125;    max-age=0</span><br><span class="line">$&#123;Upgrade-Insecure-Requests&#125;    ***</span><br></pre></td></tr></table></figure></p><ul><li>testData<br>该目录下存放测试数据excel文件。<h2 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pybot -d E:/llf_58TestSuites/jz_webIntergration/robot_code/report -o output.xml -l log.html -r report.html E:\llf_58TestSuites\jz_webIntergration\robot_code\rfcode\batch_Request.txt</span><br></pre></td></tr></table></figure></li></ul><p><img src="/assets/blogImg/robot framework + python5.jpg" alt="jeikou.xml"></p><ul><li>执行测试<br>可见，showCityName测试场景已根据excel中的用例条数批量执行了测试。<br>进入TestCaseReport目录，可以看到已根据测试场景分别生成了对应目录的测试报告：<br><img src="/assets/blogImg/robot framework + python6.jpg" alt="jeikou.xml"></li><li>各测试场景的报告存在相应目录中<br>进入showCityName目录，打开最新生成的该场景测试报告：<br><img src="/assets/blogImg/robot framework + python7.jpg" alt="jeikou.xml"></li><li>showCityName场景测试报告<br><img src="/assets/blogImg/robot framework + python8.jpg" alt="jeikou.xml"></li><li>根据说明列辨别是哪条用例的报告数据<br><img src="/assets/blogImg/robot framework + python9.jpg" alt="jeikou.xml"></li><li>sendHttpRequest被批量调用<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>经过了上一个项目吃过的亏，这次在http接口测试需求前，提前把自动化框架搭好了，便于测试后期的回归测试。其实http接口自动化测试框架可以很方便的搭建，之所以这么费劲用robot去实现，也是为了后续用例管理以及集成到平台实现工具化的考虑结果。希望这篇文章可以对其他同学有所帮助。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础框架选择&quot;&gt;&lt;a href=&quot;#基础框架选择&quot; class=&quot;headerlink&quot; title=&quot;基础框架选择&quot;&gt;&lt;/a&gt;基础框架选择&lt;/h2&gt;&lt;p&gt;最方便的方法就是用python直接写代码，代码和测试数据分离，测试数据放在excel中保存。这种实现最快捷方便，但也有些缺点：&lt;br&gt;（1）用例管理不太方便，不直观；&lt;br&gt;（2）HTMLTestRunner输出报告做的比较烂。&lt;br&gt;相较而言，robot framework具有用例管理清晰，输出报告美观的特点。但robot的缺点就是编码起来不如python直接写代码方便。所以，为了快速搭建http接口自动化框架用于回归测试，我直接用python写了一个框架。为了后续长远考虑，便于用例管理，测试报告美观，且集成到测试平台工具化以及推广给rd和其他qa同学使用，又用robot搭建了一套框架。本文就详细说明该搭建过程。&lt;/p&gt;
&lt;h2 id=&quot;搭建思路&quot;&gt;&lt;a href=&quot;#搭建思路&quot; class=&quot;headerlink&quot; title=&quot;搭建思路&quot;&gt;&lt;/a&gt;搭建思路&lt;/h2&gt;&lt;p&gt;框架采用robot和python实现，因为robot中的复杂逻辑实现起来比较繁琐，故选择用python实现，然后以外部库的形式导入robot中使用。测试用例数据保存在excel中。&lt;br&gt;使用过robot的人了解，robot中测试维度划分为测试套件（Test Suite）和测试用例（Test Case），一个Suite为一组Case的集合，每个Case对应为我们手工执行测试时的Case。&lt;br&gt;假设测试一个路径为/areaplug/showCityName的http接口，常规方法是在robot中新建一个showCityName的Suite，其下包含测试该http接口的用例集，如下图所示：&lt;br&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="接口自动化" scheme="http://xyunlay.github.io/tags/%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="robot framework" scheme="http://xyunlay.github.io/tags/robot-framework/"/>
    
  </entry>
  
  <entry>
    <title>实用的Docker入门</title>
    <link href="http://xyunlay.github.io/2020/04/06/%E5%AE%9E%E7%94%A8%E7%9A%84Docker%E5%85%A5%E9%97%A8/"/>
    <id>http://xyunlay.github.io/2020/04/06/实用的Docker入门/</id>
    <published>2020-04-06T02:55:00.000Z</published>
    <updated>2021-01-26T03:17:14.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Docker概述"><a href="#1-Docker概述" class="headerlink" title="1 Docker概述"></a>1 Docker概述</h2><p>Docker和虚拟机一样，都拥有环境隔离的能力，但它比虚拟机更加轻量级，可以使资源更大化地得到应用。首先来看Docker的架构图：</p><p><img src="/assets/blogImg/docker1.jpg" alt="docker"></p><p>理解其中几个概念：</p><ul><li>Client（Docker客户端）：是Docker的用户界面，可以接受用户命令（docker build，docker pull…）和配置标识，并与Docker daemon通信</li><li>Images（Docker镜像）：是一个只读模板，含创建Docker容器的说明，它与操作系统的安装光盘有点像</li><li>Containers（容器）：镜像的运行实例，镜像与容器的关系类比面向对象中的类和对象</li><li>Registry：是一个集中存储与分发镜像的服务。最常用的Docker Registry是官方的Docker Hub</li></ul><a id="more"></a><h2 id="2-Docker安装"><a href="#2-Docker安装" class="headerlink" title="2 Docker安装"></a>2 Docker安装</h2><p>CentOS7系统下安装Docker为例。Docker 软件包和依赖包已经包含在默认的 CentOS-Extras 软件源里，安装命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker</span><br></pre></td></tr></table></figure></p><p>启动docker后台服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure></p><p>验证是否安装成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost hemi]# docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:         1.13.1</span><br><span class="line"> API version:     1.26</span><br><span class="line"> Package version: &lt;unknown&gt;</span><br><span class="line"> Go version:      go1.8.3</span><br><span class="line"> Git commit:      774336d/1.13.1</span><br><span class="line"> Built:           Wed Mar  7 17:06:16 2018</span><br><span class="line"> OS/Arch:         linux/amd64</span><br><span class="line">Server:</span><br><span class="line"> Version:         1.13.1</span><br><span class="line"> API version:     1.26 (minimum version 1.12)</span><br><span class="line"> Package version: &lt;unknown&gt;</span><br><span class="line"> Go version:      go1.8.3</span><br><span class="line"> Git commit:      774336d/1.13.1</span><br><span class="line"> Built:           Wed Mar  7 17:06:16 2018</span><br><span class="line"> OS/Arch:         linux/amd64</span><br><span class="line"> Experimental:    false</span><br></pre></td></tr></table></figure></p><p>更详细的针对各操作系统的安装见官方文档：<a href="https://docs.docker.com/install/" target="_blank" rel="noopener">https://docs.docker.com/install/</a></p><p><strong> 镜像加速 </strong><br>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<a href="http://hub-mirror.c.163.com。" target="_blank" rel="noopener">http://hub-mirror.c.163.com。</a><br>新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\docker\config\daemon.json（Windows） 来配置 Daemon。<br>请在该配置文件中加入（没有该文件的话，请先建一个）：<br>{<br>  “registry-mirrors”: [“<a href="http://hub-mirror.c.163.com&quot;]" target="_blank" rel="noopener">http://hub-mirror.c.163.com&quot;]</a><br>}</p><h2 id="3-Docker常用命令"><a href="#3-Docker常用命令" class="headerlink" title="3 Docker常用命令"></a>3 Docker常用命令</h2><h3 id="3-1-镜像常用命令"><a href="#3-1-镜像常用命令" class="headerlink" title="3.1 镜像常用命令"></a>3.1 镜像常用命令</h3><h4 id="1）搜索镜像"><a href="#1）搜索镜像" class="headerlink" title="1）搜索镜像"></a>1）搜索镜像</h4><p>可以在Docker Hub主页上搜索镜像，可以通过docker search命令搜索，如：<br>docker search [OPTIONS] TERM<br>OPTIONS说明：</p><ul><li>–automated : 只列出 automated build类型的镜像；</li><li>–no-trunc : 显示完整的镜像描述；</li><li>-s : 列出收藏数不小于指定值的镜像。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost hemi]# docker search -s 20 tomcat</span><br><span class="line">INDEX       NAME                                      DESCRIPTION           STARS     OFFICIAL   AUTOMATED</span><br><span class="line">docker.io   docker.io/tomcat                          Apache Tomcat is...   1757      [OK]       </span><br><span class="line">docker.io   docker.io/dordoka/tomcat                  Ubuntu 14.04, Or...   48                   [OK]</span><br><span class="line">docker.io   docker.io/tomee                           Apache TomEE is ...   47        [OK]       </span><br><span class="line">docker.io   docker.io/davidcaste/alpine-tomcat        Apache Tomcat 7/...   24                   [OK]</span><br></pre></td></tr></table></figure></li></ul><p>其中，<br>STARTS：镜像仓库收藏数<br>AUTOMATED：表示是否是自动构建的镜像仓库</p><h4 id="2）下载镜像"><a href="#2）下载镜像" class="headerlink" title="2）下载镜像"></a>2）下载镜像</h4><p>docker pull [OPTIONS] NAME[:TAG]<br>OPTIONS说明：</p><ul><li>-a :拉取所有 tagged 镜像 </li><li>–disable-content-trust :忽略镜像的校验,默认开启<br>举个栗子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull java   #从Docker Hub中下载最新版本的Java镜像</span><br><span class="line">docker pull reg.itmuch.com/java:8    #从指定Registry中下载标签为8的Java镜像</span><br></pre></td></tr></table></figure></li></ul><h4 id="3）列出镜像"><a href="#3）列出镜像" class="headerlink" title="3）列出镜像"></a>3）列出镜像</h4><p>docker images [OPTIONS] [REPOSITORY[:TAG]]<br>OPTIONS说明：</p><ul><li>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li><li>–digests :显示镜像的摘要信息</li><li>-f :显示满足条件的镜像；</li><li>–format :指定返回值的模板文件；</li><li>–no-trunc :显示完整的镜像信息；</li><li>-q :只显示镜像ID。<br>举个栗子：<br>列出本地镜像中REPOSITORY为ubuntu的镜像列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[hemi@localhost ~]$ docker images ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/ubuntu    latest              0458a4468cbc        7 weeks ago         111.7 MB</span><br><span class="line">docker.io/ubuntu    15.10               9b9cb95443b5        20 months ago       137.2 MB</span><br></pre></td></tr></table></figure></li></ul><h4 id="4）删除本地镜像"><a href="#4）删除本地镜像" class="headerlink" title="4）删除本地镜像"></a>4）删除本地镜像</h4><p>docker rmi [OPTIONS] IMAGE [IMAGE…]<br>OPTIONS说明：</p><ul><li>-f :强制删除；</li><li>–no-prune :不移除该镜像的过程镜像，默认移除；<h3 id="3-2-容器常用命令"><a href="#3-2-容器常用命令" class="headerlink" title="3.2 容器常用命令"></a>3.2 容器常用命令</h3><h4 id="1）新建并启动容器"><a href="#1）新建并启动容器" class="headerlink" title="1）新建并启动容器"></a>1）新建并启动容器</h4>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]<br>OPTIONS说明（常用）：</li><li>-d: 后台运行容器，并返回容器ID；</li><li>–name=”nginx-lb”: 为容器指定一个名称；</li><li>-i：以交互模式运行容器，通常与 -t 同时使用；</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>-P: 随机端口映射；</li><li>-p: 指定端口映射，有以下四种格式<br>  ○ ip:hostPort:containerPort<br>  ○ ip::containerPort<br>  ○ hostPort:containerPort<br>  ○ containerPort</li><li>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container:&lt;name|id&gt; 四种类型；<br>如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mynginx -d nginx:latest</span><br></pre></td></tr></table></figure></li></ul><p>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 91:80 -v /data:/data -d nginx:latest</span><br></pre></td></tr></table></figure></p><p>使用镜像nginx:latest以后台模式启动一个容器,将容器的80端口映射到主机的91端口,主机的目录/data映射到容器的/data。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hemi@localhost ~]$ docker run -it nginx:latest /bin/bash </span><br><span class="line">root@b8573233d675:/#</span><br></pre></td></tr></table></figure></p><p>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</p><h4 id="2）列出容器"><a href="#2）列出容器" class="headerlink" title="2）列出容器"></a>2）列出容器</h4><p>docker ps [OPTIONS]<br>OPTIONS说明（常用）：</p><ul><li>-a :显示所有的容器，包括未运行的。</li><li>-f :根据条件过滤显示的内容。</li><li>–format :指定返回值的模板文件。</li><li>-l :显示最近创建的容器。</li><li>-n :列出最近创建的n个容器。</li><li>–no-trunc :不截断输出。</li><li>-q :静默模式，只显示容器编号。</li><li>-s :显示总的文件大小。<h4 id="3）停止容器"><a href="#3）停止容器" class="headerlink" title="3）停止容器"></a>3）停止容器</h4>docker stop CONTAINER_ID/CONTAIN_NAME<h4 id="4）强制停止容器"><a href="#4）强制停止容器" class="headerlink" title="4）强制停止容器"></a>4）强制停止容器</h4>docker kill CONTAINER_ID/CONTAIN_NAME<h4 id="5）启动已停止容器"><a href="#5）启动已停止容器" class="headerlink" title="5）启动已停止容器"></a>5）启动已停止容器</h4>docker start CONTAINER_ID/CONTAIN_NAME<h4 id="6）重启容器"><a href="#6）重启容器" class="headerlink" title="6）重启容器"></a>6）重启容器</h4>docker restart CONTAINER_ID/CONTAIN_NAME<h4 id="7）进入容器"><a href="#7）进入容器" class="headerlink" title="7）进入容器"></a>7）进入容器</h4>docker exec -it CONTAINER_ID bash<br>如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hemi@localhost ~]$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                                    NAMES</span><br><span class="line">219371844a81        7f94db72116e        &quot;tomcat.sh&quot;         7 seconds ago       Up 7 seconds        8009/tcp, 8080/tcp, 0.0.0.0:91-&gt;80/tcp   zen_kalam</span><br><span class="line">[hemi@localhost ~]$ docker exec -it 219371844a81 bash</span><br><span class="line">bash-4.2$</span><br></pre></td></tr></table></figure></li></ul><h4 id="8）删除容器"><a href="#8）删除容器" class="headerlink" title="8）删除容器"></a>8）删除容器</h4><p>docker rm [OPTIONS] CONTAINER [CONTAINER…]<br>OPTIONS说明（常用）：</p><ul><li>-f :通过SIGKILL信号强制删除一个运行中的容器</li><li>-l :移除容器间的网络连接，而非容器本身</li><li>-v :-v 删除与容器关联的卷</li></ul><p>更多命令见Docker的官方文档：<a href="https://docs.docker.com/edge/engine/reference/commandline/" target="_blank" rel="noopener">https://docs.docker.com/edge/engine/reference/commandline/</a><br>也可以利用命令行查看，如：<br>docker rm –help</p><h2 id="4-入门实战"><a href="#4-入门实战" class="headerlink" title="4 入门实战"></a>4 入门实战</h2><p><img src="/assets/blogImg/docker2.jpg" alt="docker"><br><img src="/assets/blogImg/docker3.jpg" alt="docker"><br><img src="/assets/blogImg/docker4.jpg" alt="docker"></p><p>此时浏览器访问结果如下表示正常<br><img src="/assets/blogImg/docker5.jpg" alt="docker"><br><img src="/assets/blogImg/docker6.jpg" alt="docker"></p><p>再次访问浏览器如下结果，表示修改正常<br><img src="/assets/blogImg/docker7.jpg" alt="docker"></p><p>但是此时如果重启容器，则之前的改动将失效。若要保存修改可以提交保存为新镜像↓<br><img src="/assets/blogImg/docker8.jpg" alt="docker"></p><p>此过程还可以用Dockerfile完成<br>1、首先新建Dockerfile，内容如下：<br><img src="/assets/blogImg/docker9.jpg" alt="docker"><br>2、在Dockerfile所在路径执行以下命令构建镜像，并运行：<br><img src="/assets/blogImg/docker10.jpg" alt="docker"><br>浏览器访问<br><img src="/assets/blogImg/docker11.jpg" alt="docker"></p><p>Dockerfile官方文档：<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a><br>Dockerfile最佳实践：<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</a></p><h2 id="5-Docker-Compose"><a href="#5-Docker-Compose" class="headerlink" title="5 Docker Compose"></a>5 Docker Compose</h2><p>Docker Compose用来定义和运行多应用容器。使用Docker Compose大致有3个步骤：</p><ul><li>使用Dockerfile定义应用程序环境，应标在任何地方重现该环境</li><li>在docker-compose.yml文件中定义组成应用程序的服务，以便各个服务在一个隔离的环境中一起运行</li><li>运行docker-compose up 命令，启动并运行整个应用程序<h3 id="5-1-安装Compose"><a href="#5-1-安装Compose" class="headerlink" title="5.1 安装Compose"></a>5.1 安装Compose</h3>①通过以下命令自动下载并安装适应系统版本的Compose：<br>curl -L “<a href="https://github.com/docker/compose/releases/download/1.10.0/docker-compose-$" target="_blank" rel="noopener">https://github.com/docker/compose/releases/download/1.10.0/docker-compose-$</a>(uname -s)-$(uname -m)” -o /usr/local/bin/docker-compose<br>②为安装脚本添加执行权限：<br>chmod +x /usr/local/bin/docker-compose<br>安装完成。可以使用以下命令测试安装结果：<br>ocker-compose –version<h3 id="5-2-安装Compose命令补全工具"><a href="#5-2-安装Compose命令补全工具" class="headerlink" title="5.2 安装Compose命令补全工具"></a>5.2 安装Compose命令补全工具</h3>curl -L <a href="https://raw.githubusercontent.com/docker/compose/$" target="_blank" rel="noopener">https://raw.githubusercontent.com/docker/compose/$</a>(docker-compose version –short)/contrib/completion/bash/docker-compose -o /etc/bash_completion.d/docker-compose<br>输入docker-compose并按下Tab键，compose就可以自动补全命令了。<h3 id="5-3-入门实例"><a href="#5-3-入门实例" class="headerlink" title="5.3 入门实例"></a>5.3 入门实例</h3>个人博客实例，含三个层，分别为nginx、ghost app、mysql<h4 id="1、创建3个目录"><a href="#1、创建3个目录" class="headerlink" title="1、创建3个目录"></a>1、创建3个目录</h4></li></ul><h4 id="2、进入ghost目录，创建两个文件"><a href="#2、进入ghost目录，创建两个文件" class="headerlink" title="2、进入ghost目录，创建两个文件"></a>2、进入ghost目录，创建两个文件</h4><p>① Dockerfile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">FROM ghost</span><br><span class="line">COPY ./config.production.json /var/lib/ghost/config.production.json</span><br><span class="line">EXPOSE 2368</span><br><span class="line"> </span><br><span class="line">②config.production.json  </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;url&quot;: &quot;http://localhost:2368/&quot;,</span><br><span class="line">    &quot;server&quot;: &#123;</span><br><span class="line">        &quot;port&quot;: 2368,</span><br><span class="line">        &quot;host&quot;: &quot;0.0.0.0&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;database&quot;: &#123;</span><br><span class="line">        &quot;client&quot;: &quot;mysql&quot;,</span><br><span class="line">        &quot;connection&quot;: &#123;</span><br><span class="line">            &quot;host&quot;: &quot;db&quot;,</span><br><span class="line">            &quot;user&quot;: &quot;ghost&quot;,</span><br><span class="line">            &quot;password&quot;: &quot;ghost&quot;,</span><br><span class="line">            &quot;database&quot;: &quot;ghost&quot;,</span><br><span class="line">            &quot;port&quot;: 3306,</span><br><span class="line">            &quot;charset&quot;: &quot;utf8&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mail&quot;: &#123;</span><br><span class="line">        &quot;transport&quot;: &quot;Direct&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;logging&quot;: &#123;</span><br><span class="line">        &quot;transports&quot;: [</span><br><span class="line">            &quot;file&quot;,</span><br><span class="line">            &quot;stdout&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;process&quot;: &quot;systemd&quot;,</span><br><span class="line">    &quot;paths&quot;: &#123;</span><br><span class="line">        &quot;contentPath&quot;: &quot;/var/lib/ghost/content&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、进入nginx目录，配置"><a href="#3、进入nginx目录，配置" class="headerlink" title="3、进入nginx目录，配置"></a>3、进入nginx目录，配置</h4><p>①Dockerfile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM docker.io/nginx</span><br><span class="line">COPY nginx.conf /etc/nginx/nginx.conf</span><br><span class="line">EXPOSE 80</span><br><span class="line">②nginx.conf</span><br><span class="line"></span><br><span class="line">worker_processes 4;</span><br><span class="line">events &#123;worker_connections 1024;&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://ghost-app:2368;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4、配置docker-compose-yml"><a href="#4、配置docker-compose-yml" class="headerlink" title="4、配置docker-compose.yml"></a>4、配置docker-compose.yml</h4><p> 在blog目录下创建docker-compose.yml文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line">networks:</span><br><span class="line">  ghost:</span><br><span class="line">services:</span><br><span class="line">  ghost-app:</span><br><span class="line">    build: ghost</span><br><span class="line">    networks:</span><br><span class="line">      - ghost</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;2368:2368&quot;</span><br><span class="line">  nginx:</span><br><span class="line">    build: nginx</span><br><span class="line">    networks: </span><br><span class="line">      - ghost</span><br><span class="line">    depends_on:</span><br><span class="line">      - ghost-app</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">  db:</span><br><span class="line">    image: &quot;mysql:5.7.15&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - ghost</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: mysqlroot</span><br><span class="line">      MYSQL_USER: ghost</span><br><span class="line">      MYSQL_PASSWORD: ghost</span><br><span class="line">    volumes:</span><br><span class="line">      - $PWD/data:/var/lib/mysql</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;3306:3306&quot;</span><br><span class="line"></span><br><span class="line">以上即可。随后在docker-compose.yml所在目录build镜像并运行</span><br><span class="line">docker-compost stop         #停止容器   </span><br><span class="line">docker-compose rm            #删除容器</span><br><span class="line">docker-compose build         #重新建立</span><br><span class="line">docker-compose up -d        #启动运行</span><br></pre></td></tr></table></figure></p><p>docker-compose命令-官方文档：<a href="https://docs.docker.com/compose/reference/overview/" target="_blank" rel="noopener">https://docs.docker.com/compose/reference/overview/</a></p><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>在192.168.1.244上的Jenkins运行add_repair_bill.jmx时报错<br><img src="/assets/blogImg/ant_jmeter12.jpg" alt="报错"></p><p>无法将jtl文件转换为HTML时报错<br><img src="/assets/blogImg/ant_jmeter13.jpg" alt="报错"></p><p><a href="http://www.blogjava.net/hyhos/archive/2008/11/30/154606.html" target="_blank" rel="noopener">http://www.blogjava.net/hyhos/archive/2008/11/30/154606.html</a><br><a href="https://www.ibm.com/support/knowledgecenter/zh/SSYKE2_8.0.0/com.ibm.java.lnx.80.doc/diag/appendixes/cmdline/Djdkxmltotalentitysizelimit.html" target="_blank" rel="noopener">https://www.ibm.com/support/knowledgecenter/zh/SSYKE2_8.0.0/com.ibm.java.lnx.80.doc/diag/appendixes/cmdline/Djdkxmltotalentitysizelimit.html</a></p><p>解决：在java目录lib中添加一个文件<br>jaxp.properties<br><img src="/assets/blogImg/ant_jmeter14.jpg" alt="jaxp.properties"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Docker概述&quot;&gt;&lt;a href=&quot;#1-Docker概述&quot; class=&quot;headerlink&quot; title=&quot;1 Docker概述&quot;&gt;&lt;/a&gt;1 Docker概述&lt;/h2&gt;&lt;p&gt;Docker和虚拟机一样，都拥有环境隔离的能力，但它比虚拟机更加轻量级，可以使资源更大化地得到应用。首先来看Docker的架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/blogImg/docker1.jpg&quot; alt=&quot;docker&quot;&gt;&lt;/p&gt;
&lt;p&gt;理解其中几个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Client（Docker客户端）：是Docker的用户界面，可以接受用户命令（docker build，docker pull…）和配置标识，并与Docker daemon通信&lt;/li&gt;
&lt;li&gt;Images（Docker镜像）：是一个只读模板，含创建Docker容器的说明，它与操作系统的安装光盘有点像&lt;/li&gt;
&lt;li&gt;Containers（容器）：镜像的运行实例，镜像与容器的关系类比面向对象中的类和对象&lt;/li&gt;
&lt;li&gt;Registry：是一个集中存储与分发镜像的服务。最常用的Docker Registry是官方的Docker Hub&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="环境部署" scheme="http://xyunlay.github.io/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
      <category term="docker" scheme="http://xyunlay.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>自动化测试分享</title>
    <link href="http://xyunlay.github.io/2019/06/06/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%88%86%E4%BA%AB/"/>
    <id>http://xyunlay.github.io/2019/06/06/自动化测试分享/</id>
    <published>2019-06-06T02:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p> 软件测试自动化从不同的测试阶段分类，可从下层到上层依次分为单元测试–&gt;接口测试–&gt;界面自动化测试。<br>1.单元测试：一般有开发人员自行完成<br>2.接口自动化测试： 手工测试的话可以用postman ，自动化测试多是用到 Jmeter（开源）、soupUI（开源&amp;商业版），loadrunner等。<br>3.界面自动化测试：常见的测试工具有UFT、Robot Framework、Selenium、Appium等；<br><a id="more"></a> </p><p>selenium是开源的，轻量级,能在多种主流浏览器上运行，支持JAVA\PYTHON等各种语言，我们可以根据自己的熟悉程度选择不同的语言及相应的单元测试框架.如：</p><blockquote><p>Java+selenium+TestNG<br>Python+selenium+unitTest </p></blockquote><h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Selenium2将浏览器原生的API封装成WebDriver API，Selenium库下webdriver模块可以直接操作浏览器<br>1）WebDriver 启动目标浏览器，并绑定到指定端口。该启动的浏览器实例，做为web driver 的remote server。<br>2）Client 端通过CommandExcuter 发送HTTPRequest 给remote server 的侦听端口.<br>3）Remote server 需要依赖原生的浏览器组件（如：IEDriverServer.exe、chromedriver.exe），来转化为浏览器的native 调用。</p><h3 id="webdriver-API"><a href="#webdriver-API" class="headerlink" title="webdriver API"></a>webdriver API</h3><h4 id="1、浏览器操作"><a href="#1、浏览器操作" class="headerlink" title="1、浏览器操作"></a>1、浏览器操作</h4><p>1）浏览器最大化</p><ul><li>driver.maximize_window()<br>2）设置浏览器宽和高</li><li>driver.set_window_size(400,800)<br>控制浏览器前进、后退</li><li>driver.forward()</li><li>driver.back()</li></ul><h4 id="2、简单对象的定位"><a href="#2、简单对象的定位" class="headerlink" title="2、简单对象的定位"></a>2、简单对象的定位</h4><ul><li>find_element_by_id()—-唯一</li><li>find_element_by_name()—-唯一</li><li>find_element_by_linx_text()—-文字超链接，文字定位</li><li>find_element_by_partial_link_text()—-文字超链接，部分文字定位</li><li>find_element_by_class_name()</li><li>find_element_by_tag_name())—-标签定位</li><li>find_element_by_xpath()</li><li>find_element_by_css_selector()</li></ul><h4 id="3、操作对象元素"><a href="#3、操作对象元素" class="headerlink" title="3、操作对象元素"></a>3、操作对象元素</h4><ul><li>clear()—————清除内容，如默认用户名和密码</li><li>click()————–  模拟鼠标点击操作</li><li>send_keys()——向输入框输入</li><li>submit()————提交表单</li></ul><h4 id="4、WebElement接口常用方法"><a href="#4、WebElement接口常用方法" class="headerlink" title="4、WebElement接口常用方法"></a>4、WebElement接口常用方法</h4><ul><li>size——————–返回元素尺寸</li><li>text———————-获取元素文本信息</li><li>get_attribute(name)————-获取元素某个属性值</li><li>is_displayde———————–该元素用户是否可见</li></ul><h4 id="5、鼠标事件"><a href="#5、鼠标事件" class="headerlink" title="5、鼠标事件"></a>5、鼠标事件</h4><p>ActionChains类用来操作鼠标事件</p><ul><li>context_click()——————鼠标右击</li><li>double_click()——————鼠标双击</li><li>click()—————————–鼠标点击</li><li>click_and_hold()—————按住鼠标左键不动</li><li>move_to_element(目标元素)————————移动到某个元素</li><li>move_by_offset(xoffset,yoffset)——————–移动到某个坐标</li><li>drag_and_drop(source,target)——将元素从起点source移动到终点target</li><li>drag_and_drop_by_offset(source,xoffset,yoffset)——-按照坐标移动</li><li>release()   在某个元素上释放鼠标</li></ul><p>ActionChains的执行原理<br>调用ActionChains方法的时候，用户行为不会立刻执行，而是将所有操作放在一个队列中，当执行perform()方法时，按照放入队列的顺序先进先出执行<br>如：</p><blockquote><p>ActionChains(driver).context_click(操作对象).perform()</p></blockquote><h4 id="6、键盘事件"><a href="#6、键盘事件" class="headerlink" title="6、键盘事件"></a>6、键盘事件</h4><p>Keys类操作键盘事件<br>常用的组合键</p><ul><li>send_keys(Keys.CONTROL,’a’)—————-全选</li><li>send_keys(Keys.CONTROL,’c’)—————-复制</li><li>send_keys(Keys.CONTROL,’v’)—————-粘贴</li><li>send_keys(Keys.CONTROL,’x’)—————-剪切<br>常用的非组合键</li><li>send_keys(Keys.ENTER)——————————–回车键</li><li>send_keys(Keys.BACK_SPACE)———————-删除键</li><li>send_keys(Keys.SPACE)——————————–空格键</li><li>send_keys(Keys.TAB)————————————制表键</li><li>send_keys(Keys.ESCAPE)——————————回退键</li><li>send_keys(Keys.F5)—————————————刷新键<h4 id="7、获得页面URL和title"><a href="#7、获得页面URL和title" class="headerlink" title="7、获得页面URL和title"></a>7、获得页面URL和title</h4>1）获得当前页面title，判断页面跳转是否符合预期</li><li>title = driver.title<br>2）获得当前URL，一般用来测试重定向</li><li>url = driver.current_url<h4 id="8、设置等待时间"><a href="#8、设置等待时间" class="headerlink" title="8、设置等待时间"></a>8、设置等待时间</h4></li><li>sleep()：设置固定休眠时间。Python的time包提供sleep方法</li><li>implicitly_wait()：webdriver提供的一个隐性等待的时间，在一个时间段内等待页面加载完成最长时间等待，超时则抛出异常</li><li>WebDriverWait()：webdriver提供的另一个方法，在设置时间内，默认每隔一段时间去检测页面元素是否存在，如果超出设置时间检测不到则抛出异常。<h4 id="9、定位一组对象"><a href="#9、定位一组对象" class="headerlink" title="9、定位一组对象"></a>9、定位一组对象</h4>find_elements返回的是一个list<br>定位一组对象，一般应用于下列场景：<br>批量操作对象，比如将页面上的CheckBox都选上<br>1）find_elements_by_tag_name()<br>2）find_element_by_css_selector()</li></ul><h4 id="10、定位frame中的对象"><a href="#10、定位frame中的对象" class="headerlink" title="10、定位frame中的对象"></a>10、定位frame中的对象</h4><p>针对frame嵌套的情况，使用switch_to.frame(id/name/xpath)切换到被嵌套的frame中</p><h4 id="11、多窗口处理"><a href="#11、多窗口处理" class="headerlink" title="11、多窗口处理"></a>11、多窗口处理</h4><p>要想在多个窗口之间切换，首先要获得每一个窗口的唯一标识符号（句柄）。通过获得的句柄来区别分不同的窗口，从而对不同窗口上的元素进行操作</p><ul><li>driver.current_window_handle———————-获得当前窗口的句柄</li><li>driver.window_handles——————————–获得所有窗口的句柄</li><li>driver.switch_to_handle(“句柄”)———————切换回句柄所属的窗口</li><li>driver.close()———————————————关闭当前窗口</li><li>driver.quit()———————————————–关闭所有窗口<h4 id="12、下拉菜单处理"><a href="#12、下拉菜单处理" class="headerlink" title="12、下拉菜单处理"></a>12、下拉菜单处理</h4>先定位到下拉菜单，再定位选项<br>1）下拉菜单需点击才能显示选项<br>有两次点击动作，第一次点击下拉菜单，第二次点击选项<br>2）下拉菜单不需点击，鼠标放上去就会显示选项，则可以使用move_to_element()方法定位<br>3）针对下拉菜单标签是select的<br>导入Select类：from selenium.webdriver.support.select import Select</li><li>select_by_index(index)—————————根据index属性定位选项，index从0开始</li><li>select_by_value(value)—————————根据value属性定位</li><li>select_by_visible_text(text)———————-根据选项文本值来定位</li><li>first_selected_option()—————————-选择第一个选项</li><li>deselect_by_index(index)—————————根据index属性清除选定的选项，index从0开始</li><li>deselect_by_value(value)—————————根据value属性</li><li>deselect_by_visible_text(text)———————-根据选项文本值</li><li>deselect_all()——————————————–清除所有选项</li></ul><h4 id="13、上传文件"><a href="#13、上传文件" class="headerlink" title="13、上传文件"></a>13、上传文件</h4><p>上传过程一般是打开一个系统的window窗口，从窗口选择文件添加，一般会卡在如何操作Window窗口。<br>1）上传控件标签为input<br>只要定位上传按钮，通过send_keys()添加文件路径就可以了。<br>2）上传控件标签为非input<br>可以借助第三方工具：Autolt</p><h4 id="14、下载文件"><a href="#14、下载文件" class="headerlink" title="14、下载文件"></a>14、下载文件</h4><p>webdriver允许设置默认下载路径，从而可以跳过下载弹窗提示<br>1）chrome下载<br>思路：<br>1.实例化一个option对象<br>2.设置配置，并加载到option中<br>3.启动浏览器，点击下载链接</p><ul><li>download.default_directory：设置下载路径</li><li>profile.default_content_settings.popups：设置为 0 禁止弹出窗口<br><img src="/assets/blogImg/zidonghuafenxiang1.jpg" alt="自动化测试分享"><br>2）Firefox下载<br>对于Firefox，需要我们设置其FirefoxProfile：</li><li>browser.download.dir：指定下载路径</li><li>browser.download.folderList：设置成2表示使用自定义下载路径；设置成0表示下载到桌面；设置成1表示下载到默认路径</li><li>browser.download.manager.showWhenStarting：在开始下载时是否显示下载管理器</li><li>browser.helperApps.neverAsk.saveToDisk：对所给出文件类型不再弹出框进行询问<br>Firefox需要针对每种文件类型进行设置，这里需要我们查询对应文件的MIME类型，可以查看MIME 参考手册进行查询<br><img src="/assets/blogImg/zidonghuafenxiang2.jpg" alt="自动化测试分享"><h4 id="15、调用js和控制浏览器滚动条"><a href="#15、调用js和控制浏览器滚动条" class="headerlink" title="15、调用js和控制浏览器滚动条"></a>15、调用js和控制浏览器滚动条</h4>1）webdriver提供了execute_script(script,*args)方法调用js<br>2）控制浏览器滚动条<br>window.scrollTo()方法用于设置浏览器窗口滚动条的水平和垂直位置。方法的第一个参数表示水平的左间距，第二个参数表示垂直的上边距；通过javascript设置浏览器窗口的滚动条位置 <blockquote><p>js=”window.scrollTo(100,450);”<br>driver.execute_script(js)</p></blockquote></li></ul><h4 id="16、处理cookie"><a href="#16、处理cookie" class="headerlink" title="16、处理cookie"></a>16、处理cookie</h4><ul><li>driver.get_cookies()——————————-获得所有cookie</li><li>driver.get_cookie(name)————————-获得name属性的cookie</li><li>driver.add_cookie(cookie_dic)—————–添加cookie（cookie格式为字典）</li><li>driver.delete_cookie(name)———————删除特定cookie</li><li>driver.delete_all_cookies()———————-删除所有cookie</li></ul><h2 id="Unittest"><a href="#Unittest" class="headerlink" title="Unittest"></a>Unittest</h2><h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><p>在开始运用unittest框架进行测试前，我们需要了解unittest框架中4个重要的概念：test fixture、test case、test suite、test runner。</p><ul><li>test fixture:是初始化和清理测试数据及环境，通过覆盖TestCase的setUp（）和tearDown（）方法来实现</li><li>test case:是测试用例</li><li>test suite:是用例集合，即测试套件，通过addTest加载TestCase到TestSuite中，从而返回一个TestSuite实例。</li><li>test runner:的作用是运行用例并返回结果，通过TextTestRunner类提供的run（）方法来执行test suite/test case。</li></ul><h3 id="2、基本用法"><a href="#2、基本用法" class="headerlink" title="2、基本用法"></a>2、基本用法</h3><p>我们通过以下的“加法”例子学习unittest的基本用法：<br>首先建立一个加法类： calculator.py<br>计算器类class Count:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">    self.a = int(a)</span><br><span class="line">    self.b = int(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算加法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.a + self.b</span><br></pre></td></tr></table></figure></p><p>接着写test.py去测试“加法类：calculator.py”:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> testpro.calculator <span class="keyword">import</span> Count</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAdd</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'test start'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span><span class="params">(self)</span>:</span></span><br><span class="line">        j = Count(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        self.assertEqual(j.add(), <span class="number">5</span>, <span class="string">'计算错误！'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'test end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 构造测试集</span></span><br><span class="line">     suite = unittest.TestSuite()</span><br><span class="line">     suite.addTest(TestAdd(<span class="string">'test_add'</span>))</span><br><span class="line"></span><br><span class="line">     <span class="comment"># 执行测试集合</span></span><br><span class="line">     runner = unittest.TextTestRunner()</span><br><span class="line">     runner.run(suite)</span><br></pre></td></tr></table></figure></p><p>在 test.py 中，首先引入unittest模块，创建TestAdd类继承unittest的TestCase类。</p><ul><li>setUp（）方法用于测试用例执行前的初始化工作，而这里用来打印“test start”信息。</li><li>tearDown（）方法与setUp（）相对应，用于测试用例之后的工作，这里打印“test end”信息。</li><li>asserEqual（）方法对add（）的返回值进行断言，判断两者是否相等，assertEqual（）方法由TestCase类继承而来。</li><li>TestSuite（）类来创建测试套件，通过它提供的addTest（）方法来添加测试用例test_add（）。</li><li>TextTestRunner（）类的run（）方法来运行suite所组装的测试用例。</li></ul><h3 id="3、执行用例的方法"><a href="#3、执行用例的方法" class="headerlink" title="3、执行用例的方法"></a>3、执行用例的方法</h3><p>有3种执行项目中测试用例的方法：</p><ul><li>main（） ：unittest提供的全局方法，可以方便地将一个单元测试模块变成可以直接运行的测试脚本。main（）方法使用TestLoader类来搜索所有包含在该模块中以“test”命名开头的测试方法，并自动执行它们。</li><li>run（） ：是unittest的TextTestRunner（）类的方法，用来运行suite套件中的测试用例集。</li><li>discover（） ：TestLoader类中提供的方法，用来自动识别项目中的测试用例<br>例子：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> testpro.calculator <span class="keyword">import</span> Count</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAdd</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'test start'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span><span class="params">(self)</span>:</span></span><br><span class="line">        j = Count(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        self.assertEqual(j.add(), <span class="number">5</span>, <span class="string">'计算错误！'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'test end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># main（）方法</span></span><br><span class="line">     unittest.main()</span><br><span class="line"></span><br><span class="line">     <span class="comment"># run()方法</span></span><br><span class="line">     <span class="comment">#suite = unittest.TestSuite()</span></span><br><span class="line">     <span class="comment"># suite.addTest(TestAdd('test_add'))</span></span><br><span class="line">     <span class="comment">#runner = unittest.TextTestRunner()</span></span><br><span class="line">     <span class="comment">#runner.run(suite)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#discover方法</span></span><br><span class="line"><span class="comment">#test_dir = './test_case'</span></span><br><span class="line"><span class="comment">#discover = unittest.defaultTestLoader.discover(test_dir,pattern='test*.py')</span></span><br><span class="line"><span class="comment">#if __name__ == '__main__':</span></span><br><span class="line"><span class="comment">#    runner = unittest.TextTestRunner()</span></span><br><span class="line"><span class="comment">#    runner.run(discover)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4、用例执行的顺序"><a href="#4、用例执行的顺序" class="headerlink" title="4、用例执行的顺序"></a>4、用例执行的顺序</h3><p>1.unittest框架默认根据ASCII码的顺序加载测试用例的，数字与字母的顺序为：“0-9”，“A-Z”，“a-z”。而想要用例按顺序执行，需要通过TestSuite类的addTest（）方法按照一定的顺序来加载。<br>2.通过前面对unittest单元测试框架的学习，我们来用它运行web自动化测试脚本。在开始之前，需要规划好测试目录，因为一旦测试用例多起来之后，后期维护就很麻烦。所以用例需要按照所测试的功能进行拆分，分散到不同的测试文件中。但通过addTest（）添加/删除测试用例变得很麻烦，所以我们要用TestLoder类中提供的discover（）方法解决:discover(start_dir, pattern=’test*.py, top_level_dir=None)</p><ul><li>start_dir:要测试的模块名称或测试用例目录。</li><li>pattern=’test.py’:表示用例文件名的匹配原则。以“test”开头的 ‘,py’类型的文件，星号“”表示任意多个字符。</li><li>top_level_dir=None:测试模块的顶层目录，如果没有顶层目录，默认为None。<br>让unittest框架查找到子目录中的测试文件，需要在每个子目录下放一个“__init__.py”文件，文件可以为空。<h3 id="5、断言的方法"><a href="#5、断言的方法" class="headerlink" title="5、断言的方法"></a>5、断言的方法</h3>在执行用例的过程中，最终用例是否执行通过，是通过判断测试得到的实际结果与预期结果是否相等决定的。unittest框架的TestCase类提供下面这些方法用于测试结果的判断。<br>常用的：</li><li>assertEqual(first, second, msg=None):断言第一个参数和第二个参数是否相等，如果不相等则测试失败。msg为可选参数，用于定义测试失败时想打印的信息。</li><li>assertTure(expr, msg=None):判断测试表达式是true或false</li><li>assertIN（first, second, msg=None）:断言第一个参数是否在第二个参数中，反过来讲，第二个参数是否包含在第一个参数。</li></ul><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">检查点</th></tr></thead><tbody><tr><td style="text-align:left">assertEqual(a, b)</td><td style="text-align:left">a == b</td></tr><tr><td style="text-align:left">assertNotEqual(a, b)</td><td style="text-align:left">a != b</td></tr><tr><td style="text-align:left">assertTrue(x)</td><td style="text-align:left">bool(x) is True</td></tr><tr><td style="text-align:left">assertFalse(x)</td><td style="text-align:left">bool(x) is False</td></tr><tr><td style="text-align:left">assertIs(a, b)</td><td style="text-align:left">a is b</td></tr><tr><td style="text-align:left">assertIsNot(a, b)</td><td style="text-align:left">a is not b</td></tr><tr><td style="text-align:left">assertIsNone(x)</td><td style="text-align:left">x is None</td></tr><tr><td style="text-align:left">assertIsNotNone(x)</td><td style="text-align:left">x is not None</td></tr><tr><td style="text-align:left">assertIn(a, b)</td><td style="text-align:left">a in b</td></tr><tr><td style="text-align:left">assertNotIn(a, b)</td><td style="text-align:left">a not in b</td></tr></tbody></table><h3 id="6、跳过测试和预期失败"><a href="#6、跳过测试和预期失败" class="headerlink" title="6、跳过测试和预期失败"></a>6、跳过测试和预期失败</h3><p>在运行测试时，有时需要直接跳过某些测试用例，或者当用例符合某个条件跳过测试，又或者直接将测试用例设置为失败。unittest提供了实现这些需求的装饰器</p><ul><li>unittest.skip(reason):无条件跳过测试的装饰器，说明跳过的原因</li><li>unittest.skipIf(condition, reason)：如果条件为真，跳过测试的装饰器</li><li>unittest.skipUnless(condition, reason):跳过测试的装饰器，除非条件为真</li><li>unittest.expectedFailure()：测试标记为失败。不管执行结果是否失败，统一标记失败。</li></ul><h2 id="搭建测试框架"><a href="#搭建测试框架" class="headerlink" title="搭建测试框架"></a>搭建测试框架</h2><h3 id="搭建测试框架前"><a href="#搭建测试框架前" class="headerlink" title="搭建测试框架前"></a>搭建测试框架前</h3><p>1.已经掌握了基本的Python语法<br>2.如果你要搭建web UI框架，请确保了解Selenium的基本用法</p><h3 id="框架基本组件"><a href="#框架基本组件" class="headerlink" title="框架基本组件"></a>框架基本组件</h3><p>框架的基本组成部分：<br>1）需要配置文件管理<br>2）业务逻辑代码和测试脚本分离<br>3）报告和日志文件输出<br>4）自定义的库的封装<br>5）管理、执行脚本方式<br>6）第三方插件引入<br>7）持续集成<br>解释：</p><ul><li>我们需要一个配置文件去控制一些，环境信息，开关，配置文件可以是txt/xml/yaml/properties/ini，一般.properties使用较多在JAVA里，本文是Python系列，可以选择ini文件。</li><li>业务逻辑代码和测试脚本分离，不像刚开始学习Selenium那样，代码和脚本在一个类文件里演示。根本没有用到代码重构，复用。代码和用例文件分离后，更加清晰，使多人开发脚本，方便调试。</li><li>报告和日志文件输出，你执行了多少case，case结果如何，这都需要报告来展示，一般采用第三方插件来实现这个功能，好多报告格式是html，简单，明了的风格。日志输出也很重要，如果发生报错，脚本执行失败，通过日志快速定位发生问题位置。</li><li>用户自定义库，这个很好理解，很多功能需要重复调用，这样我们就写成一个公用方法，放到工具包下，每次方便调用，例如浏览器引擎类和基本页面page.py的封装。</li><li>管理和执行脚本的方式，例如Python中单元测试框架unittest使用率非常高，java中的TestNG或Junit。</li><li>第三方插件，有时候，我们一些功能，需要借助第三方插件，能够更好实现，例如AutoIT,来实现文件上传和下载。还有利用第三方报告插件生成基于html格式的测试报告。</li><li>持续集成，git,svn,ant,maven，jenkins，我们会把这整合到jenkins，达到持续集成，一键执行测试脚本。<br>以上是一个自动化框架的基本组成部分，我们可以根据自己的熟悉程度选择不同的语言及相应的单元测试框架，配置文件，构建工具等<br>如：<blockquote><p>Java+selenium+TestNG<br>Python+selenium+unitTest  </p></blockquote></li></ul><h3 id="框架的结构"><a href="#框架的结构" class="headerlink" title="框架的结构"></a>框架的结构</h3><p>我们可以设计框架的结构如下，：<br>Test_framework<br>    |–config（配置文件）<br>    |–data（数据文件）<br>    |–drivers（驱动）<br>    |–log（日志）<br>    |–report（报告）<br>    |–test（测试用例）<br>    |   |–utils（公共方法）<br>    |–ReadMe.md（加个说明性的文件，告诉团队成员框架需要的环境以及用法）<br>也可以参照这里的目录结构，根据自己的想法设计项目目录，都是类似的，但是要包含以上内容</p><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><p>自动化脚本完善完成后，需要进行构建打包,再简单结合 Jenkins 部署起来，定期或每次代码提交后可自动运行测试，在任何一台安装了python环境的机器上，而不必考虑运行环境的问题。<br><strong> 构建打包方法：</strong> zc.buildout+setuptool<br>zc.buildout可以为应用构建独立的依赖环境,</p><h3 id="1-安装zc-buildout"><a href="#1-安装zc-buildout" class="headerlink" title="1.安装zc.buildout"></a>1.安装zc.buildout</h3><p>zc.buildout的安装依赖于setuptools，安装比较简单。但buildout的安装方式不止一种，大致可以分为以下几种：<br>1.下载bootstrap.py文件生成buildout配置环境；<br>2.安装到系统Python库中，这样可以在Terminal里面直接调用生成新工程；<br>3.与virtualenv搭配，在virtualenv的虚拟环境中安装；</p><h3 id="2-生成buildout文件"><a href="#2-生成buildout文件" class="headerlink" title="2.生成buildout文件"></a>2.生成buildout文件</h3><p>在项目文件夹中运行buildout init:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir newproject</span><br><span class="line">$ cd newproject/</span><br><span class="line">$ buildout init</span><br><span class="line">Creating &apos;.../newproject/buildout.cfg&apos;.</span><br><span class="line">Creating directory &apos;.../newproject/bin&apos;.</span><br><span class="line">Creating directory &apos;.../newproject/parts&apos;.</span><br><span class="line">Creating directory &apos;.../newproject/eggs&apos;.</span><br><span class="line">Creating directory &apos;.../newproject/develop-eggs&apos;.</span><br><span class="line">Generated script &apos;.../newproject/bin/buildout&apos;.</span><br></pre></td></tr></table></figure></p><p>其中，buildout.cfg是配置文件，类似于maven的pom文件，而bin/buildout是build脚本。<br>当共享代码的时候，只有buildout.cfg需要加入版本控制。checkout之后，只需要运行buildout bootstrap，就可以再次生成这些文件夹和文件。<br>假定我们需要在一台新的机器上构建buildout应用环境。<br>我们只需要进入项目目录，运行启动bootstrap.py脚本即可</p><blockquote><p>$ cd project<br>$ python bootstrap.py</p></blockquote><h3 id="3-配置buildout-cfg"><a href="#3-配置buildout-cfg" class="headerlink" title="3 配置buildout.cfg"></a>3 配置buildout.cfg</h3><h3 id="4-配置setup-py"><a href="#4-配置setup-py" class="headerlink" title="4 配置setup.py"></a>4 配置setup.py</h3><h3 id="5-运行buildout，生成配置环境"><a href="#5-运行buildout，生成配置环境" class="headerlink" title="5 运行buildout，生成配置环境"></a>5 运行buildout，生成配置环境</h3><p>现在一切就绪，马上可以调用buildout，生成配置环境了：</p><blockquote><p>$ bin/buildout </p></blockquote><p>可以看到依赖包等已经配置好（在eggs目录中可以看到新下载的eggs），在bin目录下还有新生成的python解释器脚本，<br>所以最终的项目目录如下，圈出的部分不需要加入版本控制<br><img src="/assets/blogImg/zidonghuafenxiang3.jpg" alt="自动化测试分享"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自动化测试&quot;&gt;&lt;a href=&quot;#自动化测试&quot; class=&quot;headerlink&quot; title=&quot;自动化测试&quot;&gt;&lt;/a&gt;自动化测试&lt;/h2&gt;&lt;p&gt; 软件测试自动化从不同的测试阶段分类，可从下层到上层依次分为单元测试–&amp;gt;接口测试–&amp;gt;界面自动化测试。&lt;br&gt;1.单元测试：一般有开发人员自行完成&lt;br&gt;2.接口自动化测试： 手工测试的话可以用postman ，自动化测试多是用到 Jmeter（开源）、soupUI（开源&amp;amp;商业版），loadrunner等。&lt;br&gt;3.界面自动化测试：常见的测试工具有UFT、Robot Framework、Selenium、Appium等；&lt;br&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="自动化测试" scheme="http://xyunlay.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Django入门</title>
    <link href="http://xyunlay.github.io/2019/05/16/Django%E5%85%A5%E9%97%A8/"/>
    <id>http://xyunlay.github.io/2019/05/16/Django入门/</id>
    <published>2019-05-16T02:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.013Z</updated>
    
    <content type="html"><![CDATA[<p>安装 Django 之后，您现在应该已经有了可用的管理工具 django-admin.py。我们可以使用 django-admin.py 来创建一个项目</p><h2 id="创建第一个项目"><a href="#创建第一个项目" class="headerlink" title="创建第一个项目"></a>创建第一个项目</h2><p>使用 django-admin.py 来创建 HelloWorld 项目：<br>django-admin.py startproject HelloWorld<br>创建完成后我们可以查看下项目的目录结构：<br>$ cd HelloWorld/<br>$ tree<br>.<br>|– HelloWorld<br>|   |– <strong>init</strong>.py<br>|   |– settings.py<br>|   |– urls.py<br>|   <code>-- wsgi.py</code>– manage.py<br><a id="more"></a><br>目录说明：</p><ul><li>HelloWorld: 项目的容器。</li><li>manage.py: 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。</li><li>HelloWorld/<strong>init</strong>.py: 一个空文件，告诉 Python 该目录是一个 Python 包。</li><li>HelloWorld/settings.py: 该 Django 项目的设置/配置。</li><li>HelloWorld/urls.py: 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站”目录”。</li><li>HelloWorld/wsgi.py: 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。<br>接下来我们进入 HelloWorld 目录输入以下命令，启动服务器：<blockquote><p>python manage.py runserver 0.0.0.0:8000</p></blockquote></li></ul><p>0.0.0.0 让其它电脑可连接到开发服务器，8000 为端口号。如果不说明，那么端口号默认为 8000。</p><p>Django紧紧地遵循MVC模式，可以称得上是一种MVC框架。 以下是Django中M、V和C各自的含义：</p><ul><li>M：数据存取部分，由django数据库层处理；</li><li>V：选择显示哪些数据要显示以及怎样显示的部分，由视图和模板处理；</li><li>C：根据用户输入委派视图的部分，由Django框架根据URLconf设置，对给定URL调用适当的Python函数。<br>由于C由框架自行处理，而Django里更关注的是模型（Model）、模板(Template)和视图（Views），Django也被称为MTV框架。在MTV开发模式中：</li><li>M代表模型（Model）：即数据存取层。该层处理与数据相关的所有事务：如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等；</li><li>T代表模板(Template)：即表现层。该层处理与表现相关的决定：如何在页面或其他类型文档中进行显示。</li><li>V代表视图（View），即业务逻辑层。该层包含存取模型及调取恰当模板的相关逻辑。你可以把它看作模型与模板之间的桥梁。</li></ul><h2 id="Django-模型"><a href="#Django-模型" class="headerlink" title="Django 模型"></a>Django 模型</h2><p>Django 对各种数据库提供了很好的支持，包括：PostgreSQL、MySQL、SQLite、Oracle。<br>Django 为这些数据库提供了统一的调用API。 我们可以根据自己业务需求选择不同的数据库。<br>MySQL 是 Web 应用中最常用的数据库。本章节我们将以 Mysql 作为实例进行介绍如果你没安装 mysql 驱动，可以执行以下命令安装：</p><blockquote><p>sudo pip install mysqlclient</p></blockquote><h4 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h4><p>在之前创建项目时，Django为我们生成了一个setting.py文件，我们在项目的 settings.py 文件中找到 DATABASES 配置项，将其信息修改为：<br>HelloWorld/HelloWorld/settings.py: 文件代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123; </span><br><span class="line">      <span class="string">'default'</span>: &#123;</span><br><span class="line">           <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>, <span class="comment"># 或者使用mysql.connector.django</span></span><br><span class="line">            <span class="string">'NAME'</span>: <span class="string">'test'</span>, </span><br><span class="line">            <span class="string">'USER'</span>: <span class="string">'test'</span>, </span><br><span class="line">            <span class="string">'PASSWORD'</span>: <span class="string">'test123'</span>, </span><br><span class="line">            <span class="string">'HOST'</span>:<span class="string">'localhost'</span>,</span><br><span class="line">             <span class="string">'PORT'</span>:<span class="string">'3306'</span>,</span><br><span class="line">       &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里添加了中文注释，所以你需要在 HelloWorld/settings.py 文件头部添加 # -<em>- coding: UTF-8 -</em>-。<br>上面包含数据库名称和用户的信息，它们与 MySQL 中对应数据库和用户的设置相同。Django 根据这一设置，与 MySQL 中相应的数据库和用户连接起来。<br>保存配置，返回到项目根目录下，运行 python manage.py shell，执行如下命令：</p><blockquote><p>from django.db import connection<br>cursor = connection.cursor()</p></blockquote><p>这里，请确保你设置的数据库文件的目录已经的的确确存在了。如果运行以上命令没有出错的话，表明你的数据库配置是正确的。</p><h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><h4 id="创建-APP"><a href="#创建-APP" class="headerlink" title="创建 APP"></a>创建 APP</h4><p>Django规定，如果要使用模型，必须要创建一个app。我们使用以下命令创建一个<br>blog的 app:</p><blockquote><p>django-admin.py startapp blog</p></blockquote><p>这样，工程根目录下会增加一个 blog package 并包含如下文件/目录：<br><img src="/assets/blogImg/django1.jpg" alt="Django入门"><br>其中：</p><ul><li>migrations 下包含对模型定义与修改的迁移记录；</li><li>admin.py 是对 Django 站点管理的定制；</li><li>apps.py 包含对 App 的配置；</li><li>models.py 应包含定义的模型；</li><li>tests.py 包含单元测试；</li><li>views.py 应包含各种视图。<br>接下来在settings.py中找到INSTALLED_APPS这一项，如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">    <span class="string">'blog'</span>,               <span class="comment"># 添加此项</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>修改 blog/models.py 文件，代码如下：<br>HelloWorld/blog/models.py: 文件代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"> <span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(models.Model)</span>:</span> </span><br><span class="line">         name = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Category</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    分类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    name = models.CharField(<span class="string">'名称'</span>, max_length=<span class="number">16</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tag</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    标签</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    name = models.CharField(<span class="string">'名称'</span>, max_length=<span class="number">16</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    博客</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    title = models.CharField(<span class="string">'标题'</span>, max_length=<span class="number">32</span>)</span><br><span class="line">    author = models.CharField(<span class="string">'作者'</span>, max_length=<span class="number">16</span>)</span><br><span class="line">    content = models.TextField(<span class="string">'正文'</span>)</span><br><span class="line">  abstract = models.CharField(<span class="string">'摘要'</span>, max_length=<span class="number">54</span>,blank=<span class="keyword">True</span>,null=<span class="keyword">True</span>,           help_text=<span class="string">"可选，如若为空将摘取正文的前54个字符"</span>) </span><br><span class="line">  <span class="comment"># 文章摘要，help_text 在该 field 被渲染成 form 是显示帮助信息</span></span><br><span class="line">    created_time = models.DateTimeField(<span class="string">'发布时间'</span>, auto_now_add=<span class="keyword">True</span>)</span><br><span class="line">  modified_time = models.DateTimeField(<span class="string">'修改时间'</span>, auto_now=<span class="keyword">True</span>)</span><br><span class="line">    category = models.ForeignKey(Category, verbose_name=<span class="string">'分类'</span></span><br><span class="line">  null=<span class="keyword">True</span>,on_delete=models.SET_NULL</span><br><span class="line">  <span class="comment"># on_delete=models.SET_NULL表示  删除某个分类（category）后该分类下所有的Article的外键设为null（空）</span></span><br><span class="line">)</span><br><span class="line">    tags = models.ManyToManyField(Tag, verbose_name=<span class="string">'标签'</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comment</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    评论</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    blog = models.ForeignKey(Blog, verbose_name=<span class="string">'博客'</span>)</span><br><span class="line">    name = models.CharField(<span class="string">'称呼'</span>, max_length=<span class="number">16</span>)</span><br><span class="line">    email = models.EmailField(<span class="string">'邮箱'</span>)</span><br><span class="line">    content = models.CharField(<span class="string">'内容'</span>, max_length=<span class="number">140</span>)</span><br><span class="line">    created = models.DateTimeField(<span class="string">'发布时间'</span>, auto_now_add=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><p><strong> 注意：ForeinKey（一对多），还有 ManyToMany（多对多）、OneToOne（一对一）</strong></p><p>这里，每个模型相当于单个数据库表，而每个属性也就是这个表中的一个字段。每个数据模型都是 django.db.models.Model 的子类，它的父类 Model 包含了所有必要的和数据库交互的方法。其它的知识点这里就不说了，如果需要进一步了解，可以参考Django的官方文档。</p><p>1.在命令行中运行：</p><blockquote><p>$ python manage.py migrate   # 创建表结构<br>$ python manage.py makemigrations blog  # 让 Django 知道我们在我们的模型有一些变更</p></blockquote><p>会生成如下所示的文件：<br><img src="/assets/blogImg/django2.jpg" alt="Django入门"><br>然后执行 migrate 命令来进行数据库的同步操作：</p><blockquote><p>$ python manage.py migrate blog   # 创建表结构</p></blockquote><p>看到几行 “Creating table…” 的字样，你的数据表就创建好了。</p><blockquote><p>Creating tables …<br>……<br>Creating table blog_test  #我们自定义的表<br>……</p></blockquote><p>表名组成结构为：应用名_类名（如：blog_test）。<br><strong> 注意：</strong> 尽管我们没有在models给表设置主键，但是Django会自动添加一个id作为主键。<br>2.还可以采用以下命令：<br>返回项目根目录下，执行 python manage.py validate，如果返回“0 errors found”，说明你的模型的语法和逻辑都正确。再执行 python manage.py sqlall blog，可以得到如下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1BEGIN;</span><br><span class="line">2CREATE TABLE &quot;blog_tag&quot; (</span><br><span class="line">3    &quot;id&quot; integer NOT NULL PRIMARY KEY,</span><br><span class="line">4    &quot;tag_name&quot; varchar(20) NOT NULL,</span><br><span class="line">5    &quot;create_time&quot; datetime NOT NULL</span><br><span class="line">6)</span><br><span class="line">7;</span><br><span class="line">8CREATE TABLE &quot;blog_classification&quot; (</span><br><span class="line">9    &quot;id&quot; integer NOT NULL PRIMARY KEY,</span><br><span class="line">10    &quot;name&quot; varchar(20) NOT NULL</span><br><span class="line">11)</span><br><span class="line">12;</span><br><span class="line">13CREATE TABLE &quot;blog_author&quot; (</span><br><span class="line">14    &quot;id&quot; integer NOT NULL PRIMARY KEY,</span><br><span class="line">15    &quot;name&quot; varchar(30) NOT NULL,</span><br><span class="line">16    &quot;email&quot; varchar(75) NOT NULL,</span><br><span class="line">17    &quot;website&quot; varchar(200) NOT NULL</span><br><span class="line">18)</span><br><span class="line">19;</span><br><span class="line">20CREATE TABLE &quot;blog_article_tags&quot; (</span><br><span class="line">21    &quot;id&quot; integer NOT NULL PRIMARY KEY,</span><br><span class="line">22    &quot;article_id&quot; integer NOT NULL,</span><br><span class="line">23    &quot;tag_id&quot; integer NOT NULL REFERENCES &quot;blog_tag&quot; (&quot;id&quot;),</span><br><span class="line">24    UNIQUE (&quot;article_id&quot;, &quot;tag_id&quot;)</span><br><span class="line">25)</span><br><span class="line">26;</span><br><span class="line">27CREATE TABLE &quot;blog_article&quot; (</span><br><span class="line">28    &quot;id&quot; integer NOT NULL PRIMARY KEY,</span><br><span class="line">29    &quot;caption&quot; varchar(30) NOT NULL,</span><br><span class="line">30    &quot;subcaption&quot; varchar(50) NOT NULL,</span><br><span class="line">31    &quot;publish_time&quot; datetime NOT NULL,</span><br><span class="line">32    &quot;update_time&quot; datetime NOT NULL,</span><br><span class="line">33    &quot;author_id&quot; integer NOT NULL REFERENCES &quot;blog_author&quot; (&quot;id&quot;),</span><br><span class="line">34    &quot;classification_id&quot; integer NOT NULL REFERENCES &quot;blog_classification&quot; (&quot;id&quot;),</span><br><span class="line">35    &quot;content&quot; text NOT NULL</span><br><span class="line">36)</span><br><span class="line">37;</span><br><span class="line">38CREATE INDEX &quot;blog_article_cc846901&quot; ON &quot;blog_article&quot; (&quot;author_id&quot;);</span><br><span class="line">39CREATE INDEX &quot;blog_article_337f0fda&quot; ON &quot;blog_article&quot; (&quot;classification_id&quot;);</span><br><span class="line">40COMMIT;</span><br></pre></td></tr></table></figure></p><p>很明显，你的模型已经变成了SQL语句，确认无误后，最后执行python manage.py syncdb即可将创建的模型同步至数据库。这里系统可能会提示你添加一个超级用户，按步骤添加即可，这个用户可以用于在之后登录Django的站点管理。</p><h4 id="添加内容"><a href="#添加内容" class="headerlink" title="添加内容"></a>添加内容</h4><p>既然数据库表结构已经有了，现在是时候尝试往里面插入一些数据了，这也方便之后在实现功能之后进行测试。传统的方式可以选择手动连接到数据库，写原生的 SQL 来完成该步骤。当然还有一个更“酷”的方法就是利用 Django 内置的站点管理工具。（在做接下来的操作之前，你可能需要先运行 manage.py createsuperuser 命令创建一个超级管理员账户）。<br>我们已经注意到在 app 目录下的 admin.py 文件，要想让定义的模型在站点管理中展示，就需要在此将所需的模型显示的添加进去。打开 blog/admin.py 文件并添加如下内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span><span class="keyword">from</span> .models <span class="keyword">import</span> Category, Tag, Blog</span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">5</span> </span><br><span class="line"><span class="number">6</span>admin.site.register([Category, Tag, Blog])</span><br></pre></td></tr></table></figure></p><p>重新运行 runserver 开发服务器并通过 /admin/ 访问后台，应该能看到我们所期望的内容：<br><img src="/assets/blogImg/django3.jpg" alt="Django入门"><br>在此可以添加数据！</p><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>接下来我们在 HelloWorld 目录中添加 testdb.py 文件（下面介绍），并修改 urls.py：<br>HelloWorld/HelloWorld/urls.py: 文件代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> testdb </span><br><span class="line">urlpatterns = [ </span><br><span class="line">  url(<span class="string">'admin/'</span>,admin.site.urls),</span><br><span class="line">    url(<span class="string">r'^testdb$'</span>, testdb.testdb),</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure></p><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>添加数据需要先创建对象，然后再执行 save 函数，相当于SQL中的INSERT：<br>HelloWorld/HelloWorld/testdb.py: 文件代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> <span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"> <span class="keyword">from</span> blog.models <span class="keyword">import</span> Test </span><br><span class="line"><span class="comment"># 数据库操作 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testdb</span><span class="params">(request)</span>:</span> </span><br><span class="line">     test1 = Test(name=<span class="string">'runoob'</span>)</span><br><span class="line">     test1.save() </span><br><span class="line">     <span class="keyword">return</span> HttpResponse(<span class="string">"&lt;p&gt;数据添加成功！&lt;/p&gt;"</span>)</span><br></pre></td></tr></table></figure></p><p>访问 <a href="http://127.0.0.1:8000/testdb" target="_blank" rel="noopener">http://127.0.0.1:8000/testdb</a> 就可以看到数据添加成功的提示。<br>输出结果如下：<br><img src="/assets/blogImg/django4.jpg" alt="Django入门"></p><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><p>Django提供了多种方式来获取数据库的内容，如下代码所示：<br>HelloWorld/HelloWorld/testdb.py: 文件代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> <span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse </span><br><span class="line"><span class="keyword">from</span> blog.models <span class="keyword">import</span> Test</span><br><span class="line"> <span class="comment"># 数据库操作 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testdb</span><span class="params">(request)</span>:</span> </span><br><span class="line">      <span class="comment"># 初始化 </span></span><br><span class="line">      response = <span class="string">""</span></span><br><span class="line">      response1 = <span class="string">""</span> </span><br><span class="line">      <span class="comment"># 通过objects这个模型管理器的all()获得所有数据行，相当于SQL中的SELECT *      FROM</span></span><br><span class="line">      list = Test.objects.all() </span><br><span class="line">      <span class="comment"># filter相当于SQL中的WHERE，可设置条件过滤结果 </span></span><br><span class="line">      response2 = Test.objects.filter(id=<span class="number">1</span>)</span><br><span class="line">      <span class="comment"># 获取单个对象 </span></span><br><span class="line">      response3 = Test.objects.get(id=<span class="number">1</span>)</span><br><span class="line">      <span class="comment"># 限制返回的数据 相当于 SQL 中的 OFFSET 0 LIMIT 2;</span></span><br><span class="line">      Test.objects.order_by(<span class="string">'name'</span>)[<span class="number">0</span>:<span class="number">2</span>] </span><br><span class="line">      <span class="comment">#数据排序 </span></span><br><span class="line">      Test.objects.order_by(<span class="string">"id"</span>) </span><br><span class="line">      <span class="comment"># 上面的方法可以连锁使用 </span></span><br><span class="line">      Test.objects.filter(name=<span class="string">"runoob"</span>).order_by(<span class="string">"id"</span>) </span><br><span class="line">      <span class="comment"># 输出所有数据</span></span><br><span class="line">      <span class="keyword">for</span> var <span class="keyword">in</span> list:</span><br><span class="line">           response1 += var.name + <span class="string">" "</span> </span><br><span class="line">      response = response1 </span><br><span class="line">      <span class="keyword">return</span> HttpResponse(<span class="string">"&lt;p&gt;"</span> + response + <span class="string">"&lt;/p&gt;"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>修改数据可以使用 save() 或 update():<br>HelloWorld/HelloWorld/testdb.py: 文件代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> <span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"> <span class="keyword">from</span> blog.models <span class="keyword">import</span> Test </span><br><span class="line"><span class="comment"># 数据库操作</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">testdb</span><span class="params">(request)</span>:</span> </span><br><span class="line">      <span class="comment"># 修改其中一个id=1的name字段，再save，相当于SQL中的UPDATE </span></span><br><span class="line">      test1 = Test.objects.get(id=<span class="number">1</span>) </span><br><span class="line">      test1.name = <span class="string">'Google'</span> </span><br><span class="line">      test1.save()</span><br><span class="line">      <span class="comment"># 另外一种方式 </span></span><br><span class="line">      <span class="comment">#Test.objects.filter(id=1).update(name='Google') </span></span><br><span class="line">      <span class="comment"># 修改所有的列 </span></span><br><span class="line">      <span class="comment"># Test.objects.all().update(name='Google') </span></span><br><span class="line">      <span class="keyword">return</span> HttpResponse(<span class="string">"&lt;p&gt;修改成功&lt;/p&gt;"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>删除数据库中的对象只需调用该对象的delete()方法即可：<br>HelloWorld/HelloWorld/testdb.py: 文件代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"> from django.http import HttpResponse</span><br><span class="line"> from blog.models import Test </span><br><span class="line"># 数据库操作</span><br><span class="line"> def testdb(request):</span><br><span class="line">       # 删除id=1的数据</span><br><span class="line">       test1 = Test.objects.get(id=1)</span><br><span class="line">       test1.delete() </span><br><span class="line">       # 另外一种方式</span><br><span class="line">       # Test.objects.filter(id=1).delete()</span><br><span class="line">       # 删除所有数据</span><br><span class="line">       # Test.objects.all().delete()</span><br><span class="line">       return HttpResponse(&quot;&lt;p&gt;删除成功&lt;/p&gt;&quot;)</span><br></pre></td></tr></table></figure></p><h2 id="Django视图"><a href="#Django视图" class="headerlink" title="Django视图"></a>Django视图</h2><p>了解了模型的操作方法后，我们可以开始建立视图了。<br>视图包含存取模型及调取恰当模板的相关逻辑。要实现将所有的Blog显示出来，首先需要利用模型操作从数据库中提取所有的Blog，然后提交给模板（这是之后的内容）形成所需的页面。<br>打开blog应用下的views.py，并输入以下内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> blog.models <span class="keyword">import</span> Blog</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render，render_to_response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blog_list</span><span class="params">(request)</span>:</span></span><br><span class="line"> ctx = &#123;</span><br><span class="line">        <span class="string">'blogs'</span>: Blog.objects.all().order_by(<span class="string">'-created'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'blog-list.html'</span>, ctx)</span><br></pre></td></tr></table></figure></p><ul><li>第一行从models.py中导入了之前创建的模型；</li><li>在函数内部，我们利用模型的操作方法从Blog中获取了所有的blog对象；</li><li>使用了 Django 的 ORM 对博客数据进行查询，并依发布时间的倒序进行排列，然后将结果集（一个 QuerySet 对象）放在一个字典对象 ctx 的 blogs 中。然后调用 render 方法来渲染模板，其第一个参数始终接收 request 对象，第二个参数是要渲染的模板文件，第三个参数则是可选的上下文参数。<h2 id="Django-模板"><a href="#Django-模板" class="headerlink" title="Django 模板"></a>Django 模板</h2>模板是一个文本，用于分离文档的表现形式和内容。 模板定义了占位符以及各种用于规范文档该如何显示的各部分基本逻辑（模板标签）。模板通常用于产生HTML。<br>在上面的视图函数中，我们在render_to_response的第一个参数中指定“’blog-list.html”<br>进入到templates目录，新建文件”‘blog-list.html”并输入如下内容：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Blogs<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        .blog &#123;</span></span><br><span class="line"><span class="undefined">            padding: 20px 0px;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        .blog .info span &#123;</span></span><br><span class="line"><span class="undefined">            padding-right: 10px;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        .blog .summary &#123;</span></span><br><span class="line"><span class="undefined">            padding-top: 20px;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>My Blogs<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&#123;% for blog in blogs %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blog"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; blog.title &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"category"</span> <span class="attr">style</span>=<span class="string">"color: #ff9900;"</span>&gt;</span>&#123;&#123; blog.category.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"author"</span> <span class="attr">style</span>=<span class="string">"color: #4a86e8"</span>&gt;</span>&#123;&#123; blog.author &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"created"</span> <span class="attr">style</span>=<span class="string">"color: #6aa84f"</span>&gt;</span>&#123;&#123; blog.created|date:"Y-m-d H:i" &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"summary"</span>&gt;</span></span><br><span class="line">            &#123;&#123; blog.content|truncatewords:100 &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>其中，用两个大括号括起来的文字（如<code>{{ blog.caprion }}</code>）称为变量，这意味着在此处插入变量的值；<br>被大括号和百分号包围的文本（如<code>{% for blog in blogs %}</code>）是模板标签，即通知模板系统完成某些工作；<br>在输出“发表时间”时，在变量后还跟着一个管道符“|”，这是过滤器，是一种便捷的转换变量输出格式的方式。<br>要了解更多关于模板的知识，请参考官方文档。</p><p>接着，我们还需要一个步骤，那就是指定应该怎样才能访问到这个页面。</p><h4 id="URLConf："><a href="#URLConf：" class="headerlink" title="URLConf："></a>URLConf：</h4><p>URLconf就像是Django所支撑网站的目录。它的本质是URL模式以及要为该URL模式调用的视图函数之间的映射表。你就是以这种方式告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。<br>现在，让我们打开项目目录下的urls.py，并添加我们之前创建的blog_list：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>urlpatterns = patterns(<span class="string">''</span>,</span><br><span class="line"><span class="number">2</span>    url(<span class="string">r'^$'</span>, <span class="string">'blog.views.blog_list'</span>, name=<span class="string">'blog_list'</span>),</span><br><span class="line"><span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><p>现在，再次运行 python manage.py runserver 0.0.0.0:8000，并在浏览器中访问，可以看到’blog-list.html页面</p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h4 id="if-else-标签"><a href="#if-else-标签" class="headerlink" title="if/else 标签"></a>if/else 标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">基本语法格式如下：</span><br><span class="line">&#123;% if condition %&#125;</span><br><span class="line">     ... display</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">或者：</span><br><span class="line">&#123;% if condition1 %&#125;</span><br><span class="line">   ... display 1</span><br><span class="line">&#123;% elif condition2 %&#125;</span><br><span class="line">   ... display 2</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">   ... display 3</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">根据条件判断是否输出。if/else 支持嵌套。</span><br><span class="line">&#123;% if %&#125; 标签接受 and ， or 或者 not 关键字来对多个变量做判断 ，或者对变量取反（ not )，例如：</span><br><span class="line">&#123;% if athlete_list and coach_list %&#125;</span><br><span class="line">     athletes 和 coaches 变量都是可用的。</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h4 id="for-标签"><a href="#for-标签" class="headerlink" title="for 标签"></a>for 标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for %&#125; 允许我们在一个序列上迭代。</span><br><span class="line">与Python的 for 语句的情形类似，循环语法是 for X in Y ，Y是要迭代的序列而X是在每一个特定的循环中使用的变量名称。</span><br><span class="line">每一次循环中，模板系统会渲染在 &#123;% for %&#125; 和 &#123;% endfor %&#125; 之间的所有内容。</span><br><span class="line">例如，给定一个运动员列表 athlete_list 变量，我们可以使用下面的代码来显示这个列表：</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;% for athlete in athlete_list %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; athlete.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">给标签增加一个 reversed 使得该列表被反向迭代：</span><br><span class="line">&#123;% for athlete in athlete_list reversed %&#125;</span><br><span class="line">...</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">可以嵌套使用 &#123;% for %&#125; 标签：</span><br><span class="line">&#123;% for athlete in athlete_list %&#125;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; athlete.name &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">    &#123;% for sport in athlete.sports_played %&#125;</span><br><span class="line">        &lt;li&gt;&#123;&#123; sport &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><h4 id="ifequal-ifnotequal-标签"><a href="#ifequal-ifnotequal-标签" class="headerlink" title="ifequal/ifnotequal 标签"></a>ifequal/ifnotequal 标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ifequal %&#125; 标签比较两个值，当他们相等时，显示在 &#123;% ifequal %&#125; 和 &#123;% endifequal %&#125; 之中所有的值。</span><br><span class="line">下面的例子比较两个模板变量 user 和 currentuser :</span><br><span class="line">&#123;% ifequal user currentuser %&#125;</span><br><span class="line">    &lt;h1&gt;Welcome!&lt;/h1&gt;</span><br><span class="line">&#123;% endifequal %&#125;</span><br><span class="line">和 &#123;% if %&#125; 类似， &#123;% ifequal %&#125; 支持可选的 &#123;% else%&#125; 标签：8</span><br><span class="line">&#123;% ifequal section &apos;sitenews&apos; %&#125;</span><br><span class="line">    &lt;h1&gt;Site News&lt;/h1&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    &lt;h1&gt;No News Here&lt;/h1&gt;</span><br><span class="line">&#123;% endifequal %&#125;</span><br></pre></td></tr></table></figure><h4 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Django 注释使用 &#123;# #&#125;。</span><br><span class="line">&#123;# 这是一个注释 #&#125;</span><br></pre></td></tr></table></figure><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">模板过滤器可以在变量被显示前修改它，过滤器使用管道字符，如下所示：</span><br><span class="line">&#123;&#123; name|lower &#125;&#125;</span><br><span class="line">&#123;&#123; name &#125;&#125; 变量被过滤器 lower 处理后，文档大写转换文本为小写。</span><br><span class="line">过滤管道可以被* 套接* ，既是说，一个过滤器管道的输出又可以作为下一个管道的输入：</span><br><span class="line">&#123;&#123; my_list|first|upper &#125;&#125;</span><br><span class="line">以上实例将第一个元素并将其转化为大写。</span><br><span class="line">有些过滤器有参数。 过滤器的参数跟随冒号之后并且总是以双引号包含。 例如：</span><br><span class="line"> &#123;&#123; bio|truncatewords:&quot;30&quot; &#125;&#125;</span><br><span class="line">这个将显示变量 bio 的前30个词。</span><br><span class="line">其他过滤器：</span><br><span class="line">+ addslashes : 添加反斜杠到任何反斜杠、单引号或者双引号前面。</span><br><span class="line">+ date : 按指定的格式字符串参数格式化 date 或者 datetime 对象，实例：</span><br><span class="line">&#123;&#123; pub_date|date:&quot;F j, Y&quot; &#125;&#125;</span><br><span class="line">+ length : 返回变量的长度。</span><br></pre></td></tr></table></figure><h3 id="include-标签"><a href="#include-标签" class="headerlink" title="include 标签"></a>include 标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include %&#125; 标签允许在模板中包含其它的模板的内容。</span><br><span class="line">下面这个例子都包含了 nav.html 模板：</span><br><span class="line">&#123;% include &quot;nav.html&quot; %&#125;</span><br></pre></td></tr></table></figure><h4 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h4><p>模板可以用继承的方式来实现复用。<br>接下来我们先创建之前项目的 templates 目录中添加 base.html 文件，代码如下：<br>HelloWorld/templates/base.html 文件代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>菜鸟教程 Django 测试。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">         &#123;% block mainbody %&#125; </span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>original<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">         &#123;% endblock %&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>以上代码中，名为 mainbody 的 block 标签是可以被继承者们替换掉的部分。<br>所有的 <code> {% block %}</code> 标签告诉模板引擎，子模板可以重载这些部分。<br>hello.html 中继承 base.html，并替换特定 block，hello.html 修改后的代码如下：<br>HelloWorld/templates/hello.html 文件代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends "base.html" %&#125;</span><br><span class="line"> &#123;% block mainbody %&#125;<span class="tag">&lt;<span class="name">p</span>&gt;</span>继承了 base.html 文件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p>第一行代码说明 hello.html 继承了 base.html 文件。可以看到，这里相同名字的 block 标签用以替换 base.html 的相应 block。</p><h2 id="Request-对象"><a href="#Request-对象" class="headerlink" title="Request 对象"></a>Request 对象</h2><p>每个 view 函数的第一个参数是一个 HttpRequest 对象，就像下面这个 hello() 函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line">def hello(request):</span><br><span class="line">    return HttpResponse(&quot;Hello world&quot;)</span><br></pre></td></tr></table></figure></p><p>HttpRequest对象包含当前请求URL的一些信息：</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">path</td><td style="text-align:left">请求页面的全路径,不包括域名—例如, “/hello/“。</td></tr><tr><td style="text-align:left">method</td><td style="text-align:left">请求中使用的HTTP方法的字符串表示。全大写表示.</td></tr><tr><td style="text-align:left">GET</td><td style="text-align:left">包含所有HTTP GET参数的类字典对象。参见QueryDict 文档。</td></tr><tr><td style="text-align:left">POST</td><td style="text-align:left">包含所有HTTP POST参数的类字典对象。参见QueryDict 文档。服务器收到空的POST请求的情况也是有可能发生的。也就是说，表单form通过HTTP POST方法提交请求，但是表单中可以没有数据。因此，不能使用语句if request.POST来判断是否使用HTTP POST方法；应该使用if request.method == “POST” (参见本表的method属性)。注意: POST不包括file-upload信息。参见FILES属性。</td></tr><tr><td style="text-align:left">REQUEST</td><td style="text-align:left">为了方便，该属性是POST和GET属性的集合体，但是有特殊性，先查找POST属性，然后再查找GET属性。借鉴PHP’s $_REQUEST。例如，如果GET = {“name”: “john”} 和POST = {“age”: ‘34’},则 REQUEST[“name”] 的值是”john”, REQUEST[“age”]的值是”34”.强烈建议使用GET and POST,因为这两个属性更加显式化，写出的代码也更易理解。</td></tr><tr><td style="text-align:left">COOKIES</td><td style="text-align:left">包含所有cookies的标准Python字典对象。Keys和values都是字符串。</td></tr><tr><td style="text-align:left">FILES</td><td style="text-align:left">包含所有上传文件的类字典对象。FILES中的每个Key都是<code>&lt;input type=&quot;file&quot; name=&quot;&quot; /&gt;</code>标签中name属性的值. FILES中的每个value 同时也是一个标准Python字典对象，包含下面三个Keys:+ filename: 上传文件名,用Python字符串表示+ content-type: 上传文件的Content type+ content: 上传文件的原始内容.注意：只有在请求方法是POST，并且请求页面中<form>有enctype=”multipart/form-data”属性时FILES才拥有数据。否则，FILES 是一个空字典。</form></td></tr><tr><td style="text-align:left">META</td><td style="text-align:left">包含所有可用HTTP头部信息的字典。 例如:+ CONTENT_LENGTH+ CONTENT_TYPE+ QUERY_STRING: 未解析的原始查询字符串+ REMOTE_ADDR: 客户端IP地址+ REMOTE_HOST: 客户端主机名+ SERVER_NAME: 服务器主机名+ SERVER_PORT: 服务器端口META 中这些头加上前缀HTTP_最为Key, 例如:+ HTTP_ACCEPT_ENCODING+ HTTP_ACCEPT_LANGUAGE+ HTTP_HOST: 客户发送的HTTP主机头信息+ HTTP_REFERER: referring页+ HTTP_USER_AGENT: 客户端的user-agent字符串+ HTTP_X_BENDER: X-Bender头信息</td></tr><tr><td style="text-align:left">user</td><td style="text-align:left">是一个django.contrib.auth.models.User 对象，代表当前登录的用户。如果访问用户当前没有登录，user将被初始化为django.contrib.auth.models.AnonymousUser的实例。你可以通过user的is_authenticated()方法来辨别用户是否登录;只有激活Django中的AuthenticationMiddleware时该属性才可用</td></tr><tr><td style="text-align:left">session</td><td style="text-align:left">唯一可读写的属性，代表当前会话的字典对象。只有激活Django中的session支持时该属性才可用。</td></tr><tr><td style="text-align:left">raw_post_data</td><td style="text-align:left">原始HTTP POST数据，未解析过。 高级处理时会有用处。</td></tr></tbody></table><p>Request对象也有一些有用的方法：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>getitem</strong>(key)</td><td style="text-align:left">返回GET/POST的键值,先取POST,后取GET。如果键不存在抛出 KeyError。 这是我们可以使用字典语法访问HttpRequest对象。 例如,request[“foo”]等同于先request.POST[“foo”] 然后 request.GET[“foo”]的操作。</td></tr><tr><td style="text-align:left">has_key()</td><td style="text-align:left">检查request.GET or request.POST中是否包含参数指定的Key。</td></tr><tr><td style="text-align:left">get_full_path()</td><td style="text-align:left">返回包含查询字符串的请求路径。例如， “/music/bands/the_beatles/?print=true”</td></tr><tr><td style="text-align:left">is_secure()</td><td style="text-align:left">如果请求是安全的，返回True，就是说，发出的是HTTPS请求。</td></tr></tbody></table><p>配置admin管理模块会应用Djongo自带的lib中的页面文件进行页面展示，相关操作代码在lib中写好了，一般不需要手动修改，只需要通过定义XXXAdmin对象就行了</p><h2 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h2><p>之前我们构建的模板，如果要说敷衍了事，也的确是。因为那既是一个没有头没有尾的残缺页面，也没有任何的美化效果，所有的东西都是很牵强的从上到下依次摆在上面。这很明显不符合一个站点的要求。<br>一个网站确确实实需要设计、美化，形象很重要嘛。所以在继续之前，我认为你还是应该好好构思一个你的网页要怎么排版，然后在PS等工具中做出效果图。当然，如果不愿意自己设计美化，也可以使用如Bootstrap这样的框架来达到相同的目的。<br>完成页面的设计之后，肯定会得到如图片、CSS样式表、JS脚本等静态文件，要在Django中正确使用这些文件，我们需要做一些配置。<br>首先，回到项目的根目录，新建一个文件夹并命名为static，现在，你的项目目录应该包含这些文件（目录）了：<br>进入到static目录，新建三个子目录，分别命名为images、js、css，。然后打开settings.py，添加如下内容：</p><blockquote><p>STATICFILES_DIRS=(os.path.join(BASE_DIR,”static”),)</p></blockquote><p>别忘记将路径该为你自己的，而且这里我故意未删除原有的注释：一定要使用绝对路径。<br>保存并关闭，再打开urls.py文件，加入如下内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>    (<span class="string">r'^static/(?P&lt;path&gt;.*)$'</span>, <span class="string">'django.views.static.serve'</span>,</span><br><span class="line"><span class="number">2</span>        &#123;<span class="string">'document_root'</span>: <span class="string">'os.path.join(BASE_DIR,"static")'</span>&#125;),</span><br><span class="line"><span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><p>现在你就可以放心大胆的将静态文件放在对应的文件夹中了。</p><h2 id="Django站点管理"><a href="#Django站点管理" class="headerlink" title="Django站点管理"></a>Django站点管理</h2><p>想要管理站点数据时，通过模型操作方法直接向数据库中添加数据，这种操作方法太不现实了。更理想的是我们需要一个后台的管理界面，可以方便的对网站数据进行增加、更改、删除等操作。不过自己开发一个这样的管理界面实在是过于繁琐了，还好Django为我们提供了一个自动管理界面，可以很方便的开启使用。<br>Django自动管理工具是django.contrib的一部分。django.contrib是一套庞大的功能集，它是Django基本代码的组成部分，Django框架就是由众多包含附加组件(add-on)的基本代码构成的。你可以把django.contrib看作是可选的Python标准库或普遍模式的实际实现。它们与Django捆绑在一起，这样你在开发中就不用“重复发明轮子”了。<br>让我们马上行动吧，打开settings.py文件并检查或修改以下项：<br>1.将’django.contrib.admin’加入setting的INSTALLED_APPS配置中并确保之中还包含’django.contrib.auth’，’django.contrib.contenttypes’和’django.contrib.sessions’；<br>2.确保MIDDLEWARE_CLASSES包含 ‘django.middleware.common.CommonMiddleware’、 ‘django.contrib.sessions.middleware.SessionMiddleware’ 和 ‘django.contrib.auth.middleware.AuthenticationMiddleware’。<br>回到项目根目录，运行python manage.py syncdb，如果之前添加过超级用户，这里会直接跳过,否则会要求你添加，按步骤操作即可。<br>最后再打开urls.py，增加如下内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>admin.autodiscover()</span><br><span class="line"><span class="number">2</span>            </span><br><span class="line"><span class="number">3</span>urlpatterns = patterns(<span class="string">''</span>,</span><br><span class="line"><span class="number">4</span>    <span class="comment"># ...</span></span><br><span class="line"><span class="number">5</span>    url(<span class="string">r'^admin/'</span>, include(admin.site.urls)),</span><br><span class="line"><span class="number">6</span>    <span class="comment"># ...</span></span><br><span class="line"><span class="number">7</span>）</span><br></pre></td></tr></table></figure></p><p>这样就完成了，打开浏览器（如果你停止了开发服务器，请重新运行）并访问<a href="http://django_server_ip:8000/admin/，即可看到Django站点管理的登录界面：" target="_blank" rel="noopener">http://django_server_ip:8000/admin/，即可看到Django站点管理的登录界面：</a><br>输入之前创建的超级用户的用户名和密码即可登录：<br>不过我们自己的模型貌似还没在这里出现。回到blog项目的目录，打开admin.py文件并输入如下内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="keyword">from</span> blog.models <span class="keyword">import</span> Tag, Author, Blog, Category            </span><br><span class="line"><span class="number">2</span><span class="class"><span class="keyword">class</span> <span class="title">AuthorAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line"><span class="number">3</span>    list_display = (<span class="string">'name'</span>, <span class="string">'email'</span>, <span class="string">'website'</span>)</span><br><span class="line"><span class="number">4</span>    search_fields = (<span class="string">'name'</span>,)</span><br><span class="line"><span class="number">5</span>            </span><br><span class="line"><span class="number">6</span><span class="class"><span class="keyword">class</span> <span class="title">BlogAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line"><span class="number">7</span>    list_display = (<span class="string">'title'</span>, <span class="string">'category'</span>, <span class="string">'author'</span>,<span class="string">'tags'</span>， <span class="string">'publish_time'</span>, <span class="string">'update_time'</span>)</span><br><span class="line"><span class="number">8</span>    list_filter = (<span class="string">'publish_time'</span>,)</span><br><span class="line"><span class="number">9</span>    date_hierarchy = <span class="string">'publish_time'</span></span><br><span class="line"><span class="number">10</span>    ordering = (<span class="string">'-publish_time'</span>,)</span><br><span class="line"><span class="number">11</span>    filter_horizontal = (<span class="string">'tags'</span>,)</span><br><span class="line"><span class="number">12</span>            </span><br><span class="line"><span class="number">13</span>admin.site.register(Blog, BlogAdmin)</span><br><span class="line"><span class="number">14</span>admin.site.register(Author, AuthorAdmin)</span><br><span class="line"><span class="number">15</span>admin.site.register(Tag)</span><br><span class="line"><span class="number">16</span>admin.site.register(Category)</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure></p><p>重启一下开发服务器，再次访问管理页面，你会发现需要的东西出现了。<br>这里我们新建了一个AuthorAdmin类和ArticleAdmin类，它是从django.contrib.admin.ModelAdmin派生出来的子类，保存着一个类的自定义配置，以供管理工具使用。我们自定义了一项：list_display，它是一个字段名称的元组，用于列表显示；而search_fields会在页面顶端加入一个搜索栏，。当然，这些添加的字段名称必须是模块中有的。我们修改了admin.site.register()调用，在Author后面添加了AuthorAdmin。你可以这样理解：用AuthorAdmin选项注册Author模块。admin.site.register()函数接受一个ModelAdmin子类作为第二个参数。如果你忽略第二个参数，Django将使用默认的选项。<br>其它就不一一列举说明了，需要了解更多的内容可以参考Django官方文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装 Django 之后，您现在应该已经有了可用的管理工具 django-admin.py。我们可以使用 django-admin.py 来创建一个项目&lt;/p&gt;
&lt;h2 id=&quot;创建第一个项目&quot;&gt;&lt;a href=&quot;#创建第一个项目&quot; class=&quot;headerlink&quot; title=&quot;创建第一个项目&quot;&gt;&lt;/a&gt;创建第一个项目&lt;/h2&gt;&lt;p&gt;使用 django-admin.py 来创建 HelloWorld 项目：&lt;br&gt;django-admin.py startproject HelloWorld&lt;br&gt;创建完成后我们可以查看下项目的目录结构：&lt;br&gt;$ cd HelloWorld/&lt;br&gt;$ tree&lt;br&gt;.&lt;br&gt;|– HelloWorld&lt;br&gt;|   |– &lt;strong&gt;init&lt;/strong&gt;.py&lt;br&gt;|   |– settings.py&lt;br&gt;|   |– urls.py&lt;br&gt;|   &lt;code&gt;-- wsgi.py&lt;/code&gt;– manage.py&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://xyunlay.github.io/tags/python/"/>
    
      <category term="python框架" scheme="http://xyunlay.github.io/tags/python%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Python3+Scrapy实现网页爬虫</title>
    <link href="http://xyunlay.github.io/2019/04/06/Python3+Scrapy%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB/"/>
    <id>http://xyunlay.github.io/2019/04/06/Python3+Scrapy实现网页爬虫/</id>
    <published>2019-04-06T02:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网页爬虫设计"><a href="#网页爬虫设计" class="headerlink" title="网页爬虫设计"></a>网页爬虫设计</h2><p>项目驱动，需要从网站上爬取文章，并上传至服务器，实现模拟用户发帖。</p><blockquote><p>框架采用Python3，配合爬虫框架Scrapy实现，目前只能抓取静态页，JS+Ajax动态加载的网页见下一篇博客  </p></blockquote><p>GitHub地址：<a href="https://github.com/JohonseZhang/Scrapy-Spider-based-on-Python3" target="_blank" rel="noopener">https://github.com/JohonseZhang/Scrapy-Spider-based-on-Python3</a><br>另外，爬取类似今日头条、淘宝、京东等动态加载网站的需要配合selenium和phantomjs框架：<br>[GitHub地址]：<a href="https://github.com/JohonseZhang/python3-scrapy-spider-phantomjs-selenium" target="_blank" rel="noopener">https://github.com/JohonseZhang/python3-scrapy-spider-phantomjs-selenium</a><br><a id="more"></a></p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>代码结构图：<br><img src="/assets/blogImg/scrapy1.jpg" alt="Scrapy"></p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ul><li>进入指定文件夹，右击空白处&gt;在此处打开命令行窗口</li><li>创建项目</li></ul><blockquote><p> Scrapy startproject DgSpider </p></blockquote><h2 id="主要代码文件说明"><a href="#主要代码文件说明" class="headerlink" title="主要代码文件说明"></a>主要代码文件说明</h2><ul><li>爬虫主类 ：UrlSpider.py、ContentSpider.py<br>项目包含2个爬虫主类，分别用于爬取文章列表页所有文章的URL、文章详情页具体内容</li><li>内容处理类 ：pipelines.py<br>处理内容</li><li>传输字段类 ：items.py<br>暂存爬取的数据</li><li>设置文件 ：settings.py<br>用于主要的参数配置</li><li>数据库操作：mysqlUtils.py<br>链接操作数据库<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2></li><li><p>UrlSpider.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> DgSpider.items <span class="keyword">import</span> DgspiderUrlItem</span><br><span class="line"><span class="keyword">from</span> scrapy.selector <span class="keyword">import</span> Selector</span><br><span class="line"><span class="keyword">from</span> DgSpider <span class="keyword">import</span> urlSettings</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DgUrlSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    print(<span class="string">'Spider DgUrlSpider Staring...'</span>)</span><br><span class="line"><span class="comment"># 爬虫名 必须静态指定</span></span><br><span class="line">    <span class="comment"># name = urlSettings.SPIDER_NAME</span></span><br><span class="line">    name = <span class="string">'DgUrlSpider'</span></span><br><span class="line"><span class="comment"># 设定域名</span></span><br><span class="line">    allowed_domains = [urlSettings.DOMAIN]</span><br><span class="line"><span class="comment"># 爬取地址</span></span><br><span class="line">    url_list = []</span><br><span class="line">    <span class="string">"""一般来说，列表页第一页不符合规则，单独append"""</span></span><br><span class="line">    url_list.append(urlSettings.START_LIST_URL)</span><br><span class="line">    loop = urlSettings.LIST_URL_RULER_LOOP</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, loop):</span><br><span class="line">        url = urlSettings.LIST_URL_RULER_PREFIX + str(i) + urlSettings.LIST_URL_RULER_SUFFIX</span><br><span class="line">        url_list.append(url)</span><br><span class="line">    start_urls = url_list</span><br><span class="line"><span class="comment"># 爬取方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line"><span class="comment"># sel : 页面源代码</span></span><br><span class="line">        sel = Selector(response)</span><br><span class="line">item_url = DgspiderUrlItem()</span><br><span class="line">        url_item = []</span><br><span class="line"><span class="comment"># XPATH获取url</span></span><br><span class="line">        url_list = sel.xpath(urlSettings.POST_URL_XPATH).extract()</span><br><span class="line"><span class="comment"># 消除http前缀差异</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">            url = url.replace(<span class="string">'http:'</span>, <span class="string">''</span>)</span><br><span class="line">            url_item.append(<span class="string">'http:'</span> + url)</span><br><span class="line"><span class="comment"># list去重</span></span><br><span class="line">        url_item = list(set(url_item))</span><br><span class="line">        item_url[<span class="string">'url'</span>] = url_item</span><br><span class="line"><span class="keyword">yield</span> item_url</span><br></pre></td></tr></table></figure><ul><li>ContentSpider.py<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> DgSpider.mysqlUtils <span class="keyword">import</span> dbhandle_geturl</span><br><span class="line"><span class="keyword">from</span> DgSpider.items <span class="keyword">import</span> DgspiderPostItem</span><br><span class="line"><span class="keyword">from</span> scrapy.selector <span class="keyword">import</span> Selector</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> DgSpider <span class="keyword">import</span> contentSettings</span><br><span class="line"><span class="keyword">from</span> DgSpider <span class="keyword">import</span> urlSettings</span><br><span class="line"><span class="keyword">from</span> DgSpider.mysqlUtils <span class="keyword">import</span> dbhandle_update_status</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DgContentSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    print(<span class="string">'Spider DgContentSpider Staring...'</span>)</span><br><span class="line">result = dbhandle_geturl(urlSettings.GROUP_ID)</span><br><span class="line">url = result[<span class="number">0</span>]</span><br><span class="line">    spider_name = result[<span class="number">1</span>]</span><br><span class="line">    site = result[<span class="number">2</span>]</span><br><span class="line">    gid = result[<span class="number">3</span>]</span><br><span class="line">    module = result[<span class="number">4</span>]</span><br><span class="line"><span class="comment"># 爬虫名 必须静态指定</span></span><br><span class="line">    <span class="comment"># name = contentSettings.SPIDER_NAME</span></span><br><span class="line">    name = <span class="string">'DgContentSpider'</span></span><br><span class="line"><span class="comment"># 设定爬取域名范围</span></span><br><span class="line">    allowed_domains = [site]</span><br><span class="line"><span class="comment"># 爬取地址</span></span><br><span class="line">    <span class="comment"># start_urls = ['http://www.mama.cn/baby/art/20140829/774422.html']</span></span><br><span class="line">    start_urls = [url]</span><br><span class="line">start_urls_tmp = []</span><br><span class="line">    <span class="string">"""构造分页序列，一般来说遵循规则 url.html,url_2.html,url_3.html，并且url.html也写为url_1.html"""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>, <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">        start_single = url[:<span class="number">-5</span>]</span><br><span class="line">        start_urls_tmp.append(start_single+<span class="string">"_"</span>+str(i)+<span class="string">".html"</span>)</span><br><span class="line"><span class="comment"># 更新状态</span></span><br><span class="line">    <span class="string">"""对于爬去网页，无论是否爬取成功都将设置status为1，避免死循环"""</span></span><br><span class="line">    dbhandle_update_status(url, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 爬取方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        item = DgspiderPostItem()</span><br><span class="line"><span class="comment"># sel : 页面源代码</span></span><br><span class="line">        sel = Selector(response)</span><br><span class="line">item[<span class="string">'url'</span>] = DgContentSpider.url</span><br><span class="line"><span class="comment"># 对于title, &lt;div&gt;&lt;h1&gt;&lt;span aaa&gt;&lt;span&gt;标题1&lt;/h1&gt;&lt;/div&gt;,使用下列方法取得</span></span><br><span class="line">        data_title_tmp = sel.xpath(contentSettings.POST_TITLE_XPATH)</span><br><span class="line">        item[<span class="string">'title'</span>] = data_title_tmp.xpath(<span class="string">'string(.)'</span>).extract()</span><br><span class="line">item[<span class="string">'text'</span>] = sel.xpath(contentSettings.POST_CONTENT_XPATH).extract()</span><br><span class="line"><span class="keyword">yield</span> item</span><br><span class="line"><span class="keyword">if</span> self.start_urls_tmp:</span><br><span class="line">            url = self.start_urls_tmp.pop()</span><br><span class="line">            <span class="keyword">yield</span> Request(url, callback=self.parse)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>pipelines.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Define your item pipelines here</span></span><br><span class="line"><span class="comment"># If you have many piplelines, all should be init here</span></span><br><span class="line"><span class="comment"># and use IF to judge them</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># DOUGUO Spider pipelines</span></span><br><span class="line"><span class="comment"># @author zhangjianfei</span></span><br><span class="line"><span class="comment"># @date 2017/04/13</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">from</span> DgSpider <span class="keyword">import</span> urlSettings</span><br><span class="line"><span class="keyword">from</span> DgSpider <span class="keyword">import</span> contentSettings</span><br><span class="line"><span class="keyword">from</span> DgSpider.mysqlUtils <span class="keyword">import</span> dbhandle_insert_content</span><br><span class="line"><span class="keyword">from</span> DgSpider.uploadUtils <span class="keyword">import</span> uploadImage</span><br><span class="line"><span class="keyword">from</span> DgSpider.mysqlUtils <span class="keyword">import</span> dbhandle_online</span><br><span class="line"><span class="keyword">from</span> DgSpider.mysqlUtils <span class="keyword">import</span> dbhandle_update_status</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> DgSpider.PostHandle <span class="keyword">import</span> post_handel</span><br><span class="line"><span class="keyword">from</span> DgSpider.commonUtils <span class="keyword">import</span> get_random_user</span><br><span class="line"><span class="keyword">from</span> DgSpider.commonUtils <span class="keyword">import</span> get_linkmd5id</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DgPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># post构造reply</span></span><br><span class="line">    cs = []</span><br><span class="line"><span class="comment"># 帖子title</span></span><br><span class="line">    title = <span class="string">''</span></span><br><span class="line"><span class="comment"># 帖子文本</span></span><br><span class="line">    text = <span class="string">''</span></span><br><span class="line"><span class="comment"># 当前爬取的url</span></span><br><span class="line">    url = <span class="string">''</span></span><br><span class="line"><span class="comment"># 随机用户ID</span></span><br><span class="line">    user_id = <span class="string">''</span></span><br><span class="line"><span class="comment"># 图片flag</span></span><br><span class="line">    has_img = <span class="number">0</span></span><br><span class="line"><span class="comment"># get title flag</span></span><br><span class="line">    get_title_flag = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        DgPipeline.user_id = get_random_user(contentSettings.CREATE_POST_USER)</span><br><span class="line"><span class="comment"># process the data</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        self.get_title_flag += <span class="number">1</span></span><br><span class="line"><span class="comment"># pipeline for content</span></span><br><span class="line">        <span class="keyword">if</span> spider.name == contentSettings.SPIDER_NAME:</span><br><span class="line"><span class="comment"># 获取当前网页url</span></span><br><span class="line">            DgPipeline.url = item[<span class="string">'url'</span>]</span><br><span class="line"><span class="comment"># 获取post title</span></span><br><span class="line">            <span class="keyword">if</span> len(item[<span class="string">'title'</span>]) == <span class="number">0</span>:</span><br><span class="line">                title_tmp = <span class="string">''</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                title_tmp = item[<span class="string">'title'</span>][<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 替换标题中可能会引起 sql syntax 的符号</span></span><br><span class="line">            <span class="comment"># 对于分页的文章，只取得第一页的标题</span></span><br><span class="line">            <span class="keyword">if</span> self.get_title_flag == <span class="number">1</span>:</span><br><span class="line"><span class="comment"># 使用beautifulSoup格什化标题</span></span><br><span class="line">                soup_title = BeautifulSoup(title_tmp, <span class="string">"lxml"</span>)</span><br><span class="line">                title = <span class="string">''</span></span><br><span class="line">                <span class="comment"># 对于bs之后的html树形结构，不使用.prettify()，对于bs, prettify后每一个标签自动换行，造成多个、</span></span><br><span class="line">                <span class="comment"># 多行的空格、换行，使用stripped_strings获取文本</span></span><br><span class="line">                <span class="keyword">for</span> string <span class="keyword">in</span> soup_title.stripped_strings:</span><br><span class="line">                    title += string</span><br><span class="line">title = title.replace(<span class="string">"'"</span>, <span class="string">"”"</span>).replace(<span class="string">'"'</span>, <span class="string">'“'</span>)</span><br><span class="line">                DgPipeline.title = title</span><br><span class="line"><span class="comment"># 获取正post内容</span></span><br><span class="line">            <span class="keyword">if</span> len(item[<span class="string">'text'</span>]) == <span class="number">0</span>:</span><br><span class="line">                text_temp = <span class="string">''</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                text_temp = item[<span class="string">'text'</span>][<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 获取图片</span></span><br><span class="line">            reg_img = re.compile(<span class="string">r'&lt;img.*&gt;'</span>)</span><br><span class="line">            imgs = reg_img.findall(text_temp)</span><br><span class="line">            <span class="keyword">for</span> img <span class="keyword">in</span> imgs:</span><br><span class="line">                DgPipeline.has_img = <span class="number">1</span></span><br><span class="line"><span class="comment"># matchObj = re.search('.*src="(.*)"&#123;2&#125;.*', img, re.M | re.I)</span></span><br><span class="line">                match_obj = re.search(<span class="string">'.*src="(.*)".*'</span>, img, re.M | re.I)</span><br><span class="line">                img_url_tmp = match_obj.group(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 去除所有Http:标签</span></span><br><span class="line">                img_url_tmp = img_url_tmp.replace(<span class="string">"http:"</span>, <span class="string">""</span>)</span><br><span class="line"><span class="comment"># 对于&lt;img src="http://a.jpg" title="a.jpg"&gt;这种情况单独处理</span></span><br><span class="line">                imgUrl_tmp_list = img_url_tmp.split(<span class="string">'"'</span>)</span><br><span class="line">                img_url_tmp = imgUrl_tmp_list[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 加入http</span></span><br><span class="line">                imgUrl = <span class="string">'http:'</span> + img_url_tmp</span><br><span class="line">list_name = imgUrl.split(<span class="string">'/'</span>)</span><br><span class="line">                file_name = list_name[len(list_name)<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># if os.path.exists(settings.IMAGES_STORE):</span></span><br><span class="line">                <span class="comment">#     os.makedirs(settings.IMAGES_STORE)</span></span><br><span class="line"><span class="comment"># 获取图片本地存储路径</span></span><br><span class="line">                file_path = contentSettings.IMAGES_STORE + file_name</span><br><span class="line">                <span class="comment"># 获取图片并上传至本地</span></span><br><span class="line">                urllib.request.urlretrieve(imgUrl, file_path)</span><br><span class="line">                upload_img_result_json = uploadImage(file_path, <span class="string">'image/jpeg'</span>, DgPipeline.user_id)</span><br><span class="line">                <span class="comment"># 获取上传之后返回的服务器图片路径、宽、高</span></span><br><span class="line">                img_u = upload_img_result_json[<span class="string">'result'</span>][<span class="string">'image_url'</span>]</span><br><span class="line">                img_w = upload_img_result_json[<span class="string">'result'</span>][<span class="string">'w'</span>]</span><br><span class="line">                img_h = upload_img_result_json[<span class="string">'result'</span>][<span class="string">'h'</span>]</span><br><span class="line">                img_upload_flag = str(img_u)+<span class="string">';'</span>+str(img_w)+<span class="string">';'</span>+str(img_h)</span><br><span class="line"><span class="comment"># 在图片前后插入字符标记</span></span><br><span class="line">                text_temp = text_temp.replace(img, <span class="string">'[dgimg]'</span> + img_upload_flag + <span class="string">'[/dgimg]'</span>)</span><br><span class="line"><span class="comment"># 使用beautifulSoup格什化HTML</span></span><br><span class="line">            soup = BeautifulSoup(text_temp, <span class="string">"lxml"</span>)</span><br><span class="line">            text = <span class="string">''</span></span><br><span class="line">            <span class="comment"># 对于bs之后的html树形结构，不使用.prettify()，对于bs, prettify后每一个标签自动换行，造成多个、</span></span><br><span class="line">            <span class="comment"># 多行的空格、换行</span></span><br><span class="line">            <span class="keyword">for</span> string <span class="keyword">in</span> soup.stripped_strings:</span><br><span class="line">                text += string + <span class="string">'\n'</span></span><br><span class="line"><span class="comment"># 替换因为双引号为中文双引号，避免 mysql syntax</span></span><br><span class="line">            DgPipeline.text = self.text + text.replace(<span class="string">'"'</span>, <span class="string">'“'</span>)</span><br><span class="line"><span class="comment"># 对于分页的文章，每一页之间加入换行</span></span><br><span class="line">            <span class="comment"># DgPipeline.text += (DgPipeline.text + '\n')</span></span><br><span class="line"><span class="comment"># pipeline for url</span></span><br><span class="line">        <span class="keyword">elif</span> spider.name == urlSettings.SPIDER_NAME:</span><br><span class="line">            db_object = dbhandle_online()</span><br><span class="line">            cursor = db_object.cursor()</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> item[<span class="string">'url'</span>]:</span><br><span class="line">                linkmd5id = get_linkmd5id(url)</span><br><span class="line">                spider_name = contentSettings.SPIDER_NAME</span><br><span class="line">                site = urlSettings.DOMAIN</span><br><span class="line">                gid = urlSettings.GROUP_ID</span><br><span class="line">                module = urlSettings.MODULE</span><br><span class="line">                status = <span class="string">'0'</span></span><br><span class="line">                sql_search = <span class="string">'select md5_url from dg_spider.dg_spider_post where md5_url="%s"'</span> % linkmd5id</span><br><span class="line">                sql = <span class="string">'insert into dg_spider.dg_spider_post(md5_url, url, spider_name, site, gid, module, status) '</span> \</span><br><span class="line">                      <span class="string">'values("%s", "%s", "%s", "%s", "%s", "%s", "%s")'</span> \</span><br><span class="line">                      % (linkmd5id, url, spider_name, site, gid, module, status)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="comment"># 判断url是否存在,如果不存在，则插入</span></span><br><span class="line">                    cursor.execute(sql_search)</span><br><span class="line">                    result_search = cursor.fetchone()</span><br><span class="line">                    <span class="keyword">if</span> result_search <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> result_search[<span class="number">0</span>].strip() == <span class="string">''</span>:</span><br><span class="line">                        cursor.execute(sql)</span><br><span class="line">                        result = cursor.fetchone()</span><br><span class="line">                        db_object.commit()</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    print(<span class="string">"&gt;&gt;&gt; catch exception !"</span>)</span><br><span class="line">                    print(e)</span><br><span class="line">                    db_object.rollback()</span><br><span class="line"><span class="keyword">return</span> item</span><br><span class="line"><span class="comment"># spider开启时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># sipder 关闭时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> spider.name == contentSettings.SPIDER_NAME:</span><br><span class="line">            <span class="comment"># 数据入库：235</span></span><br><span class="line">            url = DgPipeline.url</span><br><span class="line">            title = DgPipeline.title</span><br><span class="line">            content = DgPipeline.text</span><br><span class="line">            user_id = DgPipeline.user_id</span><br><span class="line">            dbhandle_insert_content(url, title, content, user_id, DgPipeline.has_img)</span><br><span class="line"><span class="comment"># 更新status状态为1（已经爬取过内容）</span></span><br><span class="line">            <span class="string">"""此项已在spider启动时设置"""</span></span><br><span class="line">            <span class="comment"># dbhandle_update_status(url, 1)</span></span><br><span class="line"><span class="comment"># 处理文本、设置status、上传至dgCommunity.dg_post</span></span><br><span class="line">            <span class="comment"># 如果判断has_img为1，那么上传帖子</span></span><br><span class="line">            <span class="keyword">if</span> DgPipeline.has_img == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> title.strip() != <span class="string">''</span> <span class="keyword">and</span> content.strip() != <span class="string">''</span>:</span><br><span class="line">                    spider.logger.info(<span class="string">'has_img=1,title and content is not null! Uploading post into db...'</span>)</span><br><span class="line">                    post_handel(url)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    spider.logger.info(<span class="string">'has_img=1,but title or content is null! ready to exit...'</span>)</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                spider.logger.info(<span class="string">'has_img=0, changing status and ready to exit...'</span>)</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> spider.name == urlSettings.SPIDER_NAME:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>items.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Define here the models for your scraped items</span></span><br><span class="line"><span class="comment"># douguo Spider Item</span></span><br><span class="line"><span class="comment"># @author zhangjianfei</span></span><br><span class="line"><span class="comment"># @date 2017/04/07</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DgspiderUrlItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    url = scrapy.Field()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DgspiderPostItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    url = scrapy.Field()</span><br><span class="line">    title = scrapy.Field()</span><br><span class="line">    text = scrapy.Field()</span><br></pre></td></tr></table></figure></li><li><p>settings.py<br>这个文件只需要更改或加上特定的配置项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOT_NAME = <span class="string">'DgSpider'</span></span><br><span class="line">SPIDER_MODULES = [<span class="string">'DgSpider.spiders'</span>]</span><br><span class="line">NEWSPIDER_MODULE = <span class="string">'DgSpider.spiders'</span></span><br><span class="line"><span class="comment"># 注册PIPELINES</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="string">'DgSpider.pipelines.DgPipeline'</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mysqlUtils.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> pymysql.cursors</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbhandle_online</span><span class="params">()</span>:</span></span><br><span class="line">    host = <span class="string">'192.168.1.235'</span></span><br><span class="line">    user = <span class="string">'root'</span></span><br><span class="line">    passwd = <span class="string">'douguo2015'</span></span><br><span class="line">    charset = <span class="string">'utf8'</span></span><br><span class="line">    conn = pymysql.connect(</span><br><span class="line">        host=host,</span><br><span class="line">        user=user,</span><br><span class="line">        passwd=passwd,</span><br><span class="line">        charset=charset,</span><br><span class="line">        use_unicode=<span class="keyword">False</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> conn</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbhandle_local</span><span class="params">()</span>:</span></span><br><span class="line">    host = <span class="string">'192.168.1.235'</span></span><br><span class="line">    user = <span class="string">'root'</span></span><br><span class="line">    passwd = <span class="string">'douguo2015'</span></span><br><span class="line">    charset = <span class="string">'utf8'</span></span><br><span class="line">    conn = pymysql.connect(</span><br><span class="line">        host=host,</span><br><span class="line">        user=user,</span><br><span class="line">        passwd=passwd,</span><br><span class="line">        charset=charset,</span><br><span class="line">        use_unicode=<span class="keyword">True</span></span><br><span class="line">        <span class="comment"># use_unicode=False</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> conn</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbhandle_geturl</span><span class="params">(gid)</span>:</span></span><br><span class="line">    host = <span class="string">'192.168.1.235'</span></span><br><span class="line">    user = <span class="string">'root'</span></span><br><span class="line">    passwd = <span class="string">'douguo2015'</span></span><br><span class="line">    charset = <span class="string">'utf8'</span></span><br><span class="line">    conn = pymysql.connect(</span><br><span class="line">        host=host,</span><br><span class="line">        user=user,</span><br><span class="line">        passwd=passwd,</span><br><span class="line">        charset=charset,</span><br><span class="line">        use_unicode=<span class="keyword">False</span></span><br><span class="line">    )</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    sql = <span class="string">'select url,spider_name,site,gid,module from dg_spider.dg_spider_post where status=0 and gid=%s limit 1'</span> % gid</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        conn.commit()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"***** exception"</span>)</span><br><span class="line">        print(e)</span><br><span class="line">        conn.rollback()</span><br><span class="line"><span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        os._exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        url = result[<span class="number">0</span>]</span><br><span class="line">        spider_name = result[<span class="number">1</span>]</span><br><span class="line">        site = result[<span class="number">2</span>]</span><br><span class="line">        gid = result[<span class="number">3</span>]</span><br><span class="line">        module = result[<span class="number">4</span>]</span><br><span class="line">        <span class="keyword">return</span> url.decode(), spider_name.decode(), site.decode(), gid.decode(), module.decode()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbhandle_insert_content</span><span class="params">(url, title, content, user_id, has_img)</span>:</span></span><br><span class="line">    host = <span class="string">'192.168.1.235'</span></span><br><span class="line">    user = <span class="string">'root'</span></span><br><span class="line">    passwd = <span class="string">'douguo2015'</span></span><br><span class="line">    charset = <span class="string">'utf8'</span></span><br><span class="line">    conn = pymysql.connect(</span><br><span class="line">        host=host,</span><br><span class="line">        user=user,</span><br><span class="line">        passwd=passwd,</span><br><span class="line">        charset=charset,</span><br><span class="line">        use_unicode=<span class="keyword">False</span></span><br><span class="line">    )</span><br><span class="line">    cur = conn.cursor()</span><br><span class="line"><span class="comment"># 如果标题或者内容为空，那么程序将退出，篇文章将会作废并将status设置为1，爬虫继续向下运行获得新的URl</span></span><br><span class="line">    <span class="keyword">if</span> content.strip() == <span class="string">''</span> <span class="keyword">or</span> title.strip() == <span class="string">''</span>:</span><br><span class="line">        sql_fail = <span class="string">'update dg_spider.dg_spider_post set status="%s" where url="%s" '</span> % (<span class="string">'1'</span>, url)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cur.execute(sql_fail)</span><br><span class="line">            result = cur.fetchone()</span><br><span class="line">            conn.commit()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            conn.rollback()</span><br><span class="line">        os._exit(<span class="number">0</span>)</span><br><span class="line">sql = <span class="string">'update dg_spider.dg_spider_post set title="%s",content="%s",user_id="%s",has_img="%s" where url="%s" '</span> \</span><br><span class="line">          % (title, content, user_id, has_img, url)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">        cur.execute(sql)</span><br><span class="line">        result = cur.fetchone()</span><br><span class="line">        conn.commit()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        conn.rollback()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbhandle_update_status</span><span class="params">(url, status)</span>:</span></span><br><span class="line">    host = <span class="string">'192.168.1.235'</span></span><br><span class="line">    user = <span class="string">'root'</span></span><br><span class="line">    passwd = <span class="string">'douguo2015'</span></span><br><span class="line">    charset = <span class="string">'utf8'</span></span><br><span class="line">    conn = pymysql.connect(</span><br><span class="line">        host=host,</span><br><span class="line">        user=user,</span><br><span class="line">        passwd=passwd,</span><br><span class="line">        charset=charset,</span><br><span class="line">        use_unicode=<span class="keyword">False</span></span><br><span class="line">    )</span><br><span class="line">    cur = conn.cursor()</span><br><span class="line">    sql = <span class="string">'update dg_spider.dg_spider_post set status="%s" where url="%s" '</span> \</span><br><span class="line">          % (status, url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cur.execute(sql)</span><br><span class="line">        result = cur.fetchone()</span><br><span class="line">        conn.commit()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        conn.rollback()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbhandle_get_content</span><span class="params">(url)</span>:</span></span><br><span class="line">    host = <span class="string">'192.168.1.235'</span></span><br><span class="line">    user = <span class="string">'root'</span></span><br><span class="line">    passwd = <span class="string">'douguo2015'</span></span><br><span class="line">    charset = <span class="string">'utf8'</span></span><br><span class="line">    conn = pymysql.connect(</span><br><span class="line">        host=host,</span><br><span class="line">        user=user,</span><br><span class="line">        passwd=passwd,</span><br><span class="line">        charset=charset,</span><br><span class="line">        use_unicode=<span class="keyword">False</span></span><br><span class="line">    )</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    sql = <span class="string">'select title,content,user_id,gid from dg_spider.dg_spider_post where status=1 and url="%s" limit 1'</span> % url</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        conn.commit()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"***** exception"</span>)</span><br><span class="line">        print(e)</span><br><span class="line">        conn.rollback()</span><br><span class="line"><span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        os._exit(<span class="number">1</span>)</span><br><span class="line">title = result[<span class="number">0</span>]</span><br><span class="line">    content = result[<span class="number">1</span>]</span><br><span class="line">    user_id = result[<span class="number">2</span>]</span><br><span class="line">    gid = result[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">return</span> title.decode(), content.decode(), user_id.decode(), gid.decode()</span><br><span class="line"><span class="comment"># 获取爬虫初始化参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbhandle_get_spider_param</span><span class="params">(url)</span>:</span></span><br><span class="line">    host = <span class="string">'192.168.1.235'</span></span><br><span class="line">    user = <span class="string">'root'</span></span><br><span class="line">    passwd = <span class="string">'douguo2015'</span></span><br><span class="line">    charset = <span class="string">'utf8'</span></span><br><span class="line">    conn = pymysql.connect(</span><br><span class="line">        host=host,</span><br><span class="line">        user=user,</span><br><span class="line">        passwd=passwd,</span><br><span class="line">        charset=charset,</span><br><span class="line">        use_unicode=<span class="keyword">False</span></span><br><span class="line">    )</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    sql = <span class="string">'select title,content,user_id,gid from dg_spider.dg_spider_post where status=0 and url="%s" limit 1'</span> % url</span><br><span class="line">    result = <span class="string">''</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        conn.commit()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"***** exception"</span>)</span><br><span class="line">        print(e)</span><br><span class="line">        conn.rollback()</span><br><span class="line">    title = result[<span class="number">0</span>]</span><br><span class="line">    content = result[<span class="number">1</span>]</span><br><span class="line">    user_id = result[<span class="number">2</span>]</span><br><span class="line">    gid = result[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">return</span> title.decode(), content.decode(), user_id.decode(), gid.decode()</span><br></pre></td></tr></table></figure></li><li><p>一些特别的常亮及参数，也是用py文件加入<br>urlSettings.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 爬取域名</span></span><br><span class="line">DOMAIN = <span class="string">'eastlady.cn'</span></span><br><span class="line"><span class="comment"># 爬虫名</span></span><br><span class="line"><span class="string">""" URL爬虫模块名，不可变 """</span></span><br><span class="line">SPIDER_NAME = <span class="string">'DgUrlSpider'</span></span><br><span class="line">GROUP_ID = <span class="string">'33'</span></span><br><span class="line">MODULE = <span class="string">'999'</span></span><br><span class="line"><span class="comment"># 文章列表页起始爬取URL</span></span><br><span class="line">START_LIST_URL = <span class="string">'http://www.eastlady.cn/emotion/pxgx/1.html'</span></span><br><span class="line"><span class="comment"># 文章列表循环规则</span></span><br><span class="line">LIST_URL_RULER_PREFIX = <span class="string">'http://www.eastlady.cn/emotion/pxgx/'</span></span><br><span class="line">LIST_URL_RULER_SUFFIX = <span class="string">'.html'</span></span><br><span class="line">LIST_URL_RULER_LOOP = <span class="number">30</span></span><br><span class="line"><span class="comment"># 文章URL爬取规则XPATH</span></span><br><span class="line">POST_URL_XPATH = <span class="string">'//div[@class="article_list"]/ul/li/span[1]/a[last()]/@href'</span></span><br></pre></td></tr></table></figure></li></ul><p>contentSetting:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Scrapy settings for DgSpider project</span></span><br><span class="line"><span class="comment"># 图片储存</span></span><br><span class="line">IMAGES_STORE = <span class="string">'D:\\pics\\jfss\\'</span></span><br><span class="line"><span class="comment"># 爬取域名</span></span><br><span class="line">DOMAIN = <span class="string">'nrsfh.com'</span></span><br><span class="line"><span class="comment"># 图片域名前缀</span></span><br><span class="line">DOMAIN_HTTP = <span class="string">"http:"</span></span><br><span class="line"><span class="comment"># 随机发帖用户</span></span><br><span class="line">CREATE_POST_USER = <span class="string">'37619,18441390'</span></span><br><span class="line"><span class="comment"># 爬虫名</span></span><br><span class="line">SPIDER_NAME = <span class="string">'DgContentSpider'</span></span><br><span class="line"><span class="comment"># 文章URL爬取规则XPATH</span></span><br><span class="line">POST_TITLE_XPATH = <span class="string">'//div[@class="title"]'</span></span><br><span class="line">POST_CONTENT_XPATH = <span class="string">'//div[@class="bodycss"]'</span></span><br></pre></td></tr></table></figure></p><h2 id="启动爬虫"><a href="#启动爬虫" class="headerlink" title="启动爬虫"></a>启动爬虫</h2><p>进入爬虫代码所在的文件夹，右击：在此打开命令行窗口，先执行：</p><blockquote><p> Scrapy crawl UrlSpider  &gt;<br>进行爬取所有的URL，并入库<br>再执行：<br> Scrapy crawl ContentSpider  &gt;<br>从数据库中读取URL，抓取网页内容，入库<br>当然，也可以洗衣歌windos批处理脚本，持续不断的执行Scrapy crawl ContentSpider：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@echo DOUGUO window Spider</span></span><br><span class="line">cd D:\Scrapy\DgSpider</span><br><span class="line"><span class="keyword">for</span> /l %%i <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">7000</span>) do scrapy crawl DgContentSpider</span><br><span class="line">:end</span><br><span class="line"><span class="meta">@echo SUCCESS! PRESS ANAY KEY TO EXIT! </span></span><br><span class="line"><span class="meta">@Pause&gt;nul</span></span><br></pre></td></tr></table></figure></p></blockquote><p>当然，这种方式比较笨拙，最好还是启用cmdline，加入多线程，这里不说明<br>处理完上面的所有步骤，就能成功地抓取到网页数据：<br><img src="/assets/blogImg/scrapy2.jpg" alt="Scrapy"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网页爬虫设计&quot;&gt;&lt;a href=&quot;#网页爬虫设计&quot; class=&quot;headerlink&quot; title=&quot;网页爬虫设计&quot;&gt;&lt;/a&gt;网页爬虫设计&lt;/h2&gt;&lt;p&gt;项目驱动，需要从网站上爬取文章，并上传至服务器，实现模拟用户发帖。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;框架采用Python3，配合爬虫框架Scrapy实现，目前只能抓取静态页，JS+Ajax动态加载的网页见下一篇博客  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;GitHub地址：&lt;a href=&quot;https://github.com/JohonseZhang/Scrapy-Spider-based-on-Python3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JohonseZhang/Scrapy-Spider-based-on-Python3&lt;/a&gt;&lt;br&gt;另外，爬取类似今日头条、淘宝、京东等动态加载网站的需要配合selenium和phantomjs框架：&lt;br&gt;[GitHub地址]：&lt;a href=&quot;https://github.com/JohonseZhang/python3-scrapy-spider-phantomjs-selenium&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JohonseZhang/python3-scrapy-spider-phantomjs-selenium&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://xyunlay.github.io/tags/python/"/>
    
      <category term="自动化测试" scheme="http://xyunlay.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="python爬虫" scheme="http://xyunlay.github.io/tags/python%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>linux下的shell脚本（基本）</title>
    <link href="http://xyunlay.github.io/2018/05/10/linux%E4%B8%8B%E7%9A%84shell%E8%84%9A%E6%9C%AC%EF%BC%88%E5%9F%BA%E6%9C%AC%EF%BC%89/"/>
    <id>http://xyunlay.github.io/2018/05/10/linux下的shell脚本（基本）/</id>
    <published>2018-05-10T02:55:00.000Z</published>
    <updated>2021-01-26T03:28:03.681Z</updated>
    
    <content type="html"><![CDATA[<p>Shell是一种脚本语言，那么，就必须有解释器来执行这些脚本，常见的脚本解释器有：<br><strong>bash</strong>：是Linux标准默认的shell。bash由Brian Fox和Chet Ramey共同完成，是BourneAgain Shell的缩写，内部命令一共有40个。<br><strong>sh</strong>： 由Steve Bourne开发，是Bourne Shell的缩写，sh 是Unix 标准默认的shell。<br>另外还有：ash、 csh、 ksh等。</p><a id="more"></a><p>常见的编程语言分为两类：一个是编译型语言，如：c/c++/java等，它们远行前全部一起要经过编译器的编译。另一个解释型语言，执行时，需要使用解释器一行一行地转换为代码，如：awk, perl, python与shell等。<br>Shell 经过了POSIX的标准化，所以它是可以在不同的linux系统上进行移植。<br><strong> 关于注释的问题 </strong>： 在shell中使用#进行注释，注意，sh里面没有多行注释，只能每一行加一个#号；<br>第一个shell脚本程序：</p><pre><code> !/bin/bash #上面中的 #! 是一种约定标记, 它可以告诉系统这个脚本需要什么样的解释器来执行;echo &quot;Hello, world!&quot;</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量:"></a>变量:</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量:"></a>定义变量:</h3><pre><code>country=&quot;China&quot;Number=100</code></pre><blockquote><p>注意:<br>1,变量名和等号之间不能有空格;<br>2,首个字符必须为字母（a-z，A-Z）。<br>3,中间不能有空格，可以使用下划线（_）。<br>4,不能使用标点符号。<br>5,不能使用bash里的关键字（可用help命令查看保留关键字）。</p></blockquote><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量:"></a>使用变量:</h3><p>只需要在一个定义过的变量前面加上美元符号 $ 就可以了, 另外,对于变量的{} 是可以选择的, 它的目的为帮助解释器识别变量的边界.</p><pre><code>country=&quot;China&quot;echo $countryecho ${country}echo &quot;I love my ${country}abcd!&quot;   * 这个需要有｛｝的；* 重定义变量： 直接把变量重新像开始定义的那样子赋值就可以了：country=&quot;China&quot;country=&quot;ribenguizi&quot;* 只读变量: 用 readonly 命令 可以把变量字义为只读变量。readonly country=&quot;China&quot;或country=&quot;China&quot;readonly country* 删除变量: 使用unset命令可以删除变量，但是不能删除只读的变量。用法：unset variable_name</code></pre><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>运行shell时，会同时存在三种变量：<br>1) 局部变量<br>局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。<br>2) 环境变量<br>所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。<br>3) shell变量<br>shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</p><h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量:"></a>特殊变量:</h3><p><img src="/assets/blogImg/shell1.jpg" alt="shell"></p><pre><code> **$* 和 $@ 的区别为**: $* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(&quot; &quot;)包含时，都以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。但是当它们被双引号(&quot; &quot;)包含时，&quot;$*&quot; 会将所有的参数作为一个整体，以&quot;$1 $2 … $n&quot;的形式输出所有参数；&quot;$@&quot; 会将各个参数分开，以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。$? 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。</code></pre><h2 id="Shell中的替换"><a href="#Shell中的替换" class="headerlink" title="Shell中的替换"></a>Shell中的替换</h2><h3 id="转义符："><a href="#转义符：" class="headerlink" title="转义符："></a>转义符：</h3><p>在echo中可以用于的转义符有：<br><img src="/assets/blogImg/shell1=2.jpg" alt="shell"><br>使用 echo 命令的 –E 选项禁止转义，默认也是不转义的； 使用 –n 选项可以禁止插入换行符；<br>使用 echo 命令的 –e 选项可以对转义字符进行替换。<br>另外，注意，经过我的实验，得到：</p><pre><code>echo &quot;\\&quot;        #得到 \echo -e &quot;\\&quot;   #得到  \echo &quot;\\\\&quot;        #得到 \\echo -e &quot;\\&quot;       #得到  \</code></pre><h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换:"></a>命令替换:</h3><p>它的意思就是说我们把一个命令的输出赋值给一个变量,方法为把命令用反引号(在Esc下方)引起来.  比如:</p><pre><code>directory=`pwd`echo $directory</code></pre><h3 id="变量替换"><a href="#变量替换" class="headerlink" title="变量替换:"></a>变量替换:</h3><p>可以根据变量的状态（是否为空、是否定义等）来改变它的值.<br><img src="/assets/blogImg/shell1=3.jpg" alt="shell"></p><h2 id="Shell运算符"><a href="#Shell运算符" class="headerlink" title="Shell运算符"></a>Shell运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符:"></a>算数运算符:</h3><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr. 下面使用expr进行；expr是一款表达式计算工具，使用它可以完成表达式的求值操作；<br><img src="/assets/blogImg/shell1=4.jpg" alt="shell"><br>比如：</p><pre><code>a=10b=20expr $a + $bexpr $a - $bexpr $a \* $bexpr $a / $bexpr $a % $ba=$b</code></pre><pre><code>注意:1. 在expr中的乖号为：\*2. 在 expr中的 表达式与运算符之间要有空格，否则错误；3. 在[ $a == $b ]与[ $a != $b ]中，要需要在方括号与变量以及变量与运算符之间也需要有括号， 否则为错误的。（亲测过）</code></pre><h3 id="关系运算符："><a href="#关系运算符：" class="headerlink" title="关系运算符："></a>关系运算符：</h3><p>只支持数字，不支持字符串，除非字符串的值是数字。常见的有：<br><img src="/assets/blogImg/shell1=5.jpg" alt="shell"><br>注意：也别忘记了空格；</p><h3 id="布尔运算符："><a href="#布尔运算符：" class="headerlink" title="布尔运算符："></a>布尔运算符：</h3><p><img src="/assets/blogImg/shell1=6.jpg" alt="shell"></p><h3 id="字符串运算符："><a href="#字符串运算符：" class="headerlink" title="字符串运算符："></a>字符串运算符：</h3><p><img src="/assets/blogImg/shell1=7.jpg" alt="shell"></p><h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符:"></a>文件测试运算符:</h3><p>检测 Unix 文件的各种属性。<br><img src="/assets/blogImg/shell1=8.jpg" alt="shell"></p><h2 id="Shell中的字符串"><a href="#Shell中的字符串" class="headerlink" title="Shell中的字符串"></a>Shell中的字符串</h2><h3 id="单引号的限制："><a href="#单引号的限制：" class="headerlink" title="单引号的限制："></a>单引号的限制：</h3><ol><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li><li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）。<h3 id="双引号的优点："><a href="#双引号的优点：" class="headerlink" title="双引号的优点："></a>双引号的优点：</h3></li><li>双引号里可以有变量</li><li>双引号里可以出现转义字符<h3 id="拼接字符串："><a href="#拼接字符串：" class="headerlink" title="拼接字符串："></a>拼接字符串：</h3><pre><code>country=&quot;China&quot;echo &quot;hello, $country&quot;</code></pre>也可以<pre><code>echo &quot;hello, &quot;$country&quot; &quot;</code></pre><h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度:"></a>获取字符串长度:</h3><pre><code>string=&quot;abcd&quot;echo ${#string} #输出 4</code></pre><h3 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串:"></a>提取子字符串:</h3><pre><code>string=&quot;alibaba is a great company&quot;echo ${string:1:4} #输出liba</code></pre><h3 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串:"></a>查找子字符串:</h3><pre><code>string=&quot;alibaba is a great company&quot;echo `expr index &quot;$string&quot; is`</code></pre><h3 id="处理路经的字符串："><a href="#处理路经的字符串：" class="headerlink" title="处理路经的字符串："></a>处理路经的字符串：</h3>例如：当一个路径为 /home/xiaoming/1.txt时，如何怎么它的路径（不带文件) 和如何得到它的文件名？？<br>得到文件名使用 bashname命令：  </li></ol><pre><code># 参数：# -a,表示处理多个路径；# -s, 用于去掉指定的文件的后缀名；basename /home/yin/1.txt          -&gt; 1.txtbasename -a /home/yin/1.txt /home/zhai/2.sh     -&gt; 1.txt2.sh basename -s .txt /home/yin/1.txt    -&gt; 1 basename /home/yin/1.txt .txt       -&gt; 1</code></pre><p>得到路径名（不带文件名）使用 dirname命令：</p><pre><code> 参数：没有啥参数； //例子： dirname /usr/bin/          -&gt; /usr dirname dir1/str dir2/str  -&gt; dir1dir2 dirname stdio.h            -&gt; .</code></pre><h2 id="Shell的数组"><a href="#Shell的数组" class="headerlink" title="Shell的数组:"></a>Shell的数组:</h2><p>bash支持一维数组, 不支持多维数组, 它的下标从0开始编号. 用下标[n] 获取数组元素；</p><h3 id="定义数组："><a href="#定义数组：" class="headerlink" title="定义数组："></a>定义数组：</h3><p>在shell中用括号表示数组，元素用空格分开。 如：<br>array_name=(value0 value1 value2 value3)<br>也可以单独定义数组的各个分量，可以不使用连续的下标，而且下标的范围没有限制。如：</p><pre><code>array_name[0]=value0array_name[1]=value1array_name[2]=value2</code></pre><h3 id="读取数组："><a href="#读取数组：" class="headerlink" title="读取数组："></a>读取数组：</h3><p>读取某个下标的元素一般格式为:</p><pre><code>${array_name[index]}</code></pre><p>读取数组的全部元素，用@或*</p><pre><code>${array_name[*]}${array_name[@]}</code></pre><h3 id="获取数组的信息："><a href="#获取数组的信息：" class="headerlink" title="获取数组的信息："></a>获取数组的信息：</h3><p>取得数组元素的个数：</p><pre><code> length=${#array_name[@]}或 length=${#array_name[*]}</code></pre><p>获取数组的下标：</p><pre><code> length=${!array_name[@]} 或 length=${!array_name[*]}</code></pre><p>取得数组单个元素的长度:</p><pre><code>lengthn=${#array_name[n]}</code></pre><h2 id="printf函数："><a href="#printf函数：" class="headerlink" title="printf函数："></a>printf函数：</h2><p>它与c语言中的printf相似，不过也有不同，下面列出它的不同的地方：</p><ol><li>printf 命令不用加括号</li><li>format-string 可以没有引号，但最好加上，单引号双引号均可。</li><li>参数多于格式控制符(%)时，format-string 可以重用，可以将所有参数都转换。</li><li>arguments 使用空格分隔，不用逗号。<br>下面为例子：</li></ol><pre><code># format-string为双引号$ printf &quot;%d %s\n&quot; 1 &quot;abc&quot;1 abc# 单引号与双引号效果一样 $ printf &apos;%d %s\n&apos; 1 &quot;abc&quot; 1 abc# 没有引号也可以输出$ printf %s abcdefabcdef# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用$ printf %s abc defabcdef$ printf &quot;%s\n&quot; abc defabcdef$ printf &quot;%s %s %s\n&quot; a b c d e f g h i ja b cd e fg h ij# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替$ printf &quot;%s and %d \n&quot; and 0# 如果以 %d 的格式来显示字符串，那么会有警告，提示无效的数字，此时默认置为 0$ printf &quot;The first program always prints&apos;%s,%d\n&apos;&quot; Hello Shell-bash: printf: Shell: invalid numberThe first program always prints &apos;Hello,0&apos;$</code></pre><h2 id="Shell中条件语句"><a href="#Shell中条件语句" class="headerlink" title="Shell中条件语句"></a>Shell中条件语句</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>包括：</p><ol><li>if [ 表达式 ] then  语句  fi</li><li>if [ 表达式 ] then 语句 else 语句 fi</li><li>if [ 表达式] then 语句  elif[ 表达式 ] then 语句 elif[ 表达式 ] then 语句   …… fi<br>例子：</li></ol><pre><code>a=10b=20if [ $a == $b ]then   echo &quot;a is equal to b&quot;else   echo &quot;a is not equal to b&quot;fi</code></pre><p>另外：if … else 语句也可以写成一行，以命令的方式来运行，像这样：<br>if test $[2*3] -eq $[1+5]; then echo ‘The two numbers are equal!’; fi;<br>其中，test 命令用于检查某个条件是否成立，与方括号([ ])类似。</p><h3 id="case-……-esac语句"><a href="#case-……-esac语句" class="headerlink" title="case …… esac语句"></a>case …… esac语句</h3><p>case … esac 与其他语言中的 switch … case 语句类似，是一种多分枝选择结构。case语句格式如下：</p><pre><code>case 值 in模式1)    command1    command2    command3    ;;模式2）    command1    command2    command3    ;;*)    command1    command2    command3    ;;esac</code></pre><p>其中，1. 取值后面必须为关键字 in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。;; 与其他语言中的 break 类似，意思是跳到整个 case 语句的最后。2. 如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p><h2 id="Shell-的循环语句"><a href="#Shell-的循环语句" class="headerlink" title="Shell 的循环语句"></a>Shell 的循环语句</h2><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>  一般格式为：</p><pre><code>for 变量 in 列表do    command1    command2    ...    commandNdone</code></pre><p>注意：列表是一组值（数字、字符串等）组成的序列，每个值通过空格分隔。每循环一次，就将列表中的下一个值赋给变量。       例如：<br>顺序输出当前列表的数字：</p><pre><code>for loop in 1 2 3 4 5do    echo &quot;The value is: $loop&quot;done</code></pre><p>显示主目录下以 .bash 开头的文件：</p><pre><code>#!/bin/bashfor FILE in $HOME/.bash*do   echo $FILEdone</code></pre><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>一般格式为：</p><pre><code>while commanddo   Statement(s) to be executed if command is truedone</code></pre><p>例如：</p><pre><code>COUNTER=0while [ $COUNTER -lt 5 ]do    COUNTER=&apos;expr $COUNTER+1&apos;    echo $COUNTERdone</code></pre><h3 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h3><p>until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。    常用格式为：</p><pre><code>until commanddo   Statement(s) to be executed until command is truedone</code></pre><p>command 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</p><p>类似地， 在循环中使用 break 与continue 跳出循环。    另外，break 命令后面还可以跟一个整数，表示跳出第几层循环。</p><h2 id="Shell函数"><a href="#Shell函数" class="headerlink" title="Shell函数"></a>Shell函数</h2><p>Shell函数必须先定义后使用，定义如下，</p><pre><code>function_name () {    list of commands    [ return value ]}也可以加上function关键字：function function_name () {    list of commands    [ return value ]}</code></pre><p>注意:</p><ol><li>调用函数只需要给出函数名，不需要加括号。</li><li>函数返回值，可以显式增加return语句；如果不加，会将最后一条命令运行结果作为返回值。</li><li>Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。</li><li>函数的参数可以通过 $n  得到.如:</li></ol><pre><code>funWithParam(){    echo &quot;The value of the first parameter is $1 !&quot;    echo &quot;The value of the second parameter is $2 !&quot;    echo &quot;The value of the tenth parameter is ${10} !&quot;    echo &quot;The value of the eleventh parameter is ${11} !&quot;    echo &quot;The amount of the parameters is $# !&quot;  # 参数个数    echo &quot;The string of the parameters is $* !&quot;  # 传递给函数的所有参数}funWithParam 1 2 3 4 5 6 7 8 9 34 73</code></pre><ol start="5"><li>像删除变量一样，删除函数也可以使用 unset 命令，不过要加上 .f 选项，如下所示：<pre><code>unset .f function_name</code></pre><h2 id="shell的文件包含："><a href="#shell的文件包含：" class="headerlink" title="shell的文件包含："></a>shell的文件包含：</h2>Shell 也可以包含外部脚本，将外部脚本的内容合并到当前脚本。使用：. filename<br>或<br>source filename</li><li>两种方式的效果相同，简单起见，一般使用点号(.)，但是注意点号(.)和文件名中间有一空格。</li><li>被包含脚本不需要有执行权限。</li></ol><p>THE END.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Shell是一种脚本语言，那么，就必须有解释器来执行这些脚本，常见的脚本解释器有：&lt;br&gt;&lt;strong&gt;bash&lt;/strong&gt;：是Linux标准默认的shell。bash由Brian Fox和Chet Ramey共同完成，是BourneAgain Shell的缩写，内部命令一共有40个。&lt;br&gt;&lt;strong&gt;sh&lt;/strong&gt;： 由Steve Bourne开发，是Bourne Shell的缩写，sh 是Unix 标准默认的shell。&lt;br&gt;另外还有：ash、 csh、 ksh等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://xyunlay.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="http://xyunlay.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>统一处理异步的js回调</title>
    <link href="http://xyunlay.github.io/2018/05/06/%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E7%9A%84js%E5%9B%9E%E8%B0%83/"/>
    <id>http://xyunlay.github.io/2018/05/06/统一处理异步的js回调/</id>
    <published>2018-05-06T02:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.019Z</updated>
    
    <content type="html"><![CDATA[<p>js编程时经常会用到异步处理，而异步会带了所谓的并发问题。比如，你需要向服务器发出多个ajax请求，然后在返回所有结果后做进一步处理，同时要显示动画。因此我们需要用到以下的方案。<br><a id="more"></a></p><p>###<strong> 【定义函数】 </strong><br>定义Batch函数。参数为函数组成的数组functions，这里面的函数将稍后执行，以及这些函数完成后的回调completionHandler。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Batch</span>(<span class="params">functions, completionHandler</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>._functions = functions;</span><br><span class="line"><span class="keyword">this</span>._completionHandler = completionHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###<strong> 【启动请求】 </strong><br>用this._remaining来记录未执行的函数量，然后执行各个函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Batch.prototype.execute = <span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">  <span class="keyword">var</span> functions = <span class="keyword">this</span>._functions;</span><br><span class="line">  <span class="keyword">var</span> length = <span class="keyword">this</span>._remaining = functions.length;</span><br><span class="line">  <span class="keyword">this</span>._results = [];</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i += <span class="number">1</span>) &#123;</span><br><span class="line">      functions[i](<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>###<strong> 【让Batch知道函数完成】 </strong><br>用this._results来记录执行结果，当this._remaining为0时，表示所有函数已执行完毕。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Batch.prototype.done = <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>._remaining -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span>(result) !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._results.push(result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._remaining === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._completionHandler(<span class="keyword">this</span>._results);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>到这里，就完成了Batch这个函数的简单功能了。</p><p>###<strong> 【使用】 </strong><br>将Batch应用到实际上。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> urls = [</span><br><span class="line">  <span class="string">'/api/gists/1000'</span>,</span><br><span class="line">  <span class="string">'/api/gists/1001'</span>,</span><br><span class="line">  <span class="string">'/api/gists/1002'</span>,</span><br><span class="line">  <span class="string">'/api/gists/1003'</span>,</span><br><span class="line">  <span class="string">'/api/gists/1004'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="string">'/api/gists/1337'</span>,</span><br><span class="line">  <span class="comment">// etc...</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">var</span> length = urls.length;</span><br><span class="line"><span class="keyword">var</span> batchFunctions = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建需要被batch执行的函数数组</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i += <span class="number">1</span>) &#123;</span><br><span class="line">  batchFunctions.push(<span class="function"><span class="keyword">function</span> (<span class="params">batch</span>) </span>&#123;</span><br><span class="line">      $.ajax.get(urls[i], <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">          batch.done(response);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myBatch = <span class="keyword">new</span> Batch(batchFunctions, <span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line"><span class="comment">//返回各个函数的结果数组</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myBatch.execute(); <span class="comment">// 开始执行</span></span><br></pre></td></tr></table></figure></p><p>这样的方案其实是参考了“观察者”模式。相关源码推荐nodeJs的Async.js库。</p><p>THE END.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js编程时经常会用到异步处理，而异步会带了所谓的并发问题。比如，你需要向服务器发出多个ajax请求，然后在返回所有结果后做进一步处理，同时要显示动画。因此我们需要用到以下的方案。&lt;br&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://xyunlay.github.io/tags/web/"/>
    
      <category term="js" scheme="http://xyunlay.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Nginx性能分析--web服务器</title>
    <link href="http://xyunlay.github.io/2018/04/29/Nginx--%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <id>http://xyunlay.github.io/2018/04/29/Nginx--性能分析/</id>
    <published>2018-04-29T03:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Nginx监控"><a href="#1-Nginx监控" class="headerlink" title="1.Nginx监控"></a>1.Nginx监控</h2><h3 id="1）StubStatus"><a href="#1）StubStatus" class="headerlink" title="1）StubStatus"></a>1）StubStatus</h3><ul><li>StubStatus模块能够获取nginx自上次以来的工作状态，此模块非核心功能，需要在nginx编译安装时候手工指定才能使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /nginx_status &#123;</span><br><span class="line">stub_status on;</span><br><span class="line">access_log     /logs/Nginxstatus.log;</span><br><span class="line">#auth_basic     “NginxStatus”;</span><br><span class="line">#auth_basic _user_file    ../htpasswd;</span><br><span class="line">allow all;</span><br><span class="line">#deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>stub_status on  表示启用StubStatus的工作状态统计功能，<br>access_log 用来指定StubStatus模块的访问日志文件；<br>auth_basic 是nginx的认证机制；auth_basic _user_file    用来指定认证的密码文件<br><a id="more"></a></p><ul><li>通过下面的链接就可以看到nginx状态了：<a href="http://www.nginx.com.cn/nginx_status" target="_blank" rel="noopener">http://www.nginx.com.cn/nginx_status</a><br>NginxStatus 显示的内容意思如下：<br>active connections – 当前 Nginx 正处理的活动连接数。<br>server accepts handled requests — 总共处理了 14553819 个连接 , 成功创建 14553819 次握手 ( 证明中间没有失败的 ), 总共处理了 19239266 个请求 ( 平均每次握手处理了 1.3 个数据请求 )。<br>reading — nginx 读取到客户端的 Header 信息数。<br>writing — nginx 返回给客户端的 Header 信息数。<br>waiting — 开启 keep-alive 的情况下，这个值等于 active – (reading + writing)，意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接<h3 id="2）Nginx运行实况"><a href="#2）Nginx运行实况" class="headerlink" title="2）Nginx运行实况"></a>2）Nginx运行实况</h3>~]# ps axf|fgrep nginx:|fgrep -v fgrep<h2 id="2-Nginx优化"><a href="#2-Nginx优化" class="headerlink" title="2.Nginx优化"></a>2.Nginx优化</h2><h3 id="1）-内核优化-etc-sysctl-conf"><a href="#1）-内核优化-etc-sysctl-conf" class="headerlink" title="1） 内核优化(/etc/sysctl.conf)"></a>1） 内核优化(/etc/sysctl.conf)</h3></li><li>net.ipv4.tcp_max_tw_buckets = 6000 : timewait的数量，默认是180000。</li><li>net.ipv4.ip_local_port_range = 1024 65000 : 允许系统打开的端口范围。</li><li>net.ipv4.tcp_tw_recycle = 1 : 启用timewait快速回收。</li><li>net.ipv4.tcp_tw_reuse = 1 : 开启重用。允许将TIME-WAIT sockets重新用              于新的TCP连接。</li><li>net.ipv4.tcp_syncookies = 1 : 开启SYN Cookies，当出现SYN等待队列溢  出时，启用cookies来处理。</li><li>net.core.somaxconn = 262144 : web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而Nginx内核参数定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。</li><li>net.core.netdev_max_backlog = 262144 : 每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</li><li>net.ipv4.tcp_max_orphans = 262144 : 系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤儿连接将即刻被复位并打印出警告信息。这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，更应该增加这个值(如果增加了内存之后)。</li><li>net.ipv4.tcp_max_syn_backlog = 262144 : 记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。</li><li>net.ipv4.tcp_timestamps = 0 : 时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。</li><li>net.ipv4.tcp_synack_retries = 1 : 为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。</li><li>net.ipv4.tcp_syn_retries = 1 :在内核放弃建立连接之前发送SYN包的数量。</li><li>net.ipv4.tcp_fin_timeout = 1 : 如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。</li><li>net.ipv4.tcp_keepalive_time = 30 : 当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时<h3 id="2）配置文件优化"><a href="#2）配置文件优化" class="headerlink" title="2）配置文件优化"></a>2）配置文件优化</h3><h4 id="Nginx配置优化—全局配置"><a href="#Nginx配置优化—全局配置" class="headerlink" title="Nginx配置优化—全局配置"></a>Nginx配置优化—全局配置</h4></li><li>worker_processes 8;<br>Nginx配置文件进程数，建议按照cpu数目来指定，一般为它的倍数。worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;<br>为每个进程分配cpu，上例中将8个进程分配到8个cpu，当然可以写多个，或者将一个进程分配到多个cpu。</li><li>worker_rlimit_nofile 102400;<br>这个指令是指当一个Nginx配置文件进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与Nginx进程数相除，但是Nginx分配请求并不是那么均匀，所以最好与ulimit -n的值保持一致。</li><li>use epoll;<br>使用epoll的I/O模型</li><li>worker_connections 102400;<br>每个进程允许的最多连接数，理论上每台Nginx服务器的最大连接数为worker_processes<em>worker_connections。，在做反向代理时为： worker_processes</em>worker_connections/4<h4 id="Nginx配置优化—HTTP服务器优化"><a href="#Nginx配置优化—HTTP服务器优化" class="headerlink" title="Nginx配置优化—HTTP服务器优化"></a>Nginx配置优化—HTTP服务器优化</h4></li><li>client_header_buffer_size 4k;<br>客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</li><li>open_file_cache max=102400 inactive=20s;<br>这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。（大并发时加上缓存很重要）</li><li>open_file_cache_valid 30s; （此值建议大于缓存失效时间）<br>这个是指多长时间检查一次缓存的有效信息。</li><li>open_file_cache_min_uses 1;<br>open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。<br>关于内核参数的优化：</li><li>client_max_body_size 8m;<br>客户端最大数据段大小</li><li>server_names_hash_bucket_size 128;<br>服务器名的hash库大小</li><li>large_client_header_buffers 4 4k;<br>用来指定客户端请求中较大的消息头的缓存最大数量和大小，4为个数，4k为最大缓存4个4kb</li><li>Senfile 参数用于开启高效文件传输模式，将tcp_nopush和tcp_nodely连个指令设置为on可以防止网络阻塞</li><li>fastcgi_cache_path /usr/local/nginx/fastcgi_cache levels=1:2    keys_zone=TEST:10m<br>缓存路径，级别，检测时间，活动时间</li><li>keepalive_timeout 60;<br>用于设置客户端连接保持活动的超时时间，超过这个时间后，服务器会关闭该链接</li><li>Client_header_timeout<br>用于设置客户端请求头读取超时时间，如果超过这个时间，客户端还没有发送任何数据，nginx将返回“R equit time out(408)错误”。</li><li>Client_body_timeout<br>用于设置客户端请求主体读取超时时间，默认值为60,。如果超过这个时间，客户端还没有发送任何数据，nginx将返回“R equit time out(408)错误”。</li><li>send_timeout<br>用于指定响应客户端的超时时间，这个超时仅限于两个连接活动之前的时间，如果超过这个时间，客户端没有任何活动，nginx将会关系连接。<h4 id="Nginx配置优化—HttpGzip"><a href="#Nginx配置优化—HttpGzip" class="headerlink" title="Nginx配置优化—HttpGzip"></a>Nginx配置优化—HttpGzip</h4></li><li>gzip     on;<br>用于设置开启或者关闭gzip模块，on表示开启gzip压缩，试试压缩输出数据流。</li><li>gzip_min_length    1k;<br>用于设置允许压缩的页面最小字节数，页面字节数从header头的<br>content-length中获取，默认值是0，不管页面多大都进行压缩。建议<br>设置成大于1k的字节数，小于1k可能会越压越大</li><li>gzip_http_version    1.1;<br>用于设置识别HTTP协议版本，默认是1.1，目前大部分浏览器已经支持gzip压缩，使用默认即可</li><li>gzip_buffers     4    16k；<br>表示申请4个单位为16k的内存作为压缩结果流缓存，默认值是申请与原始数据大小相同的内存空间来储存gzip压缩结果</li><li>gzip_comp_level    2;<br>用来指定gzip压缩比，1压缩比最小，处理速度最快；9压缩比最大，传输速度快，但处理最慢，也比较消耗CPU资源（建议设置为4-6）</li><li>gzip_types  <em>**</em>;<br>用来指定压缩类型，无论是否指定，“text/html”类型总是会被压缩的</li><li>gzip_vary     on;<br>该选项可以让前端的缓存服务器经过gzip压缩的页面，例如用Squid缓存经过nginx压缩的数据<h4 id="Nginx配置优化"><a href="#Nginx配置优化" class="headerlink" title="Nginx配置优化"></a>Nginx配置优化</h4></li><li>fastcgi_connect_timeout 300;  fastcgi连接存活时间</li><li>fastcgi_send_timeout 300;   fastcgi发送存活时间</li><li>fastcgi_read_timeout 300;   fastcgi读取存活时间</li><li>fastcgi_buffer_size 16k;    fastcgi缓存块大小</li><li>fastcgi_buffers 16 16k;   fastcgi缓存块分配模式</li><li>fastcgi_busy_buffers_size 16k;  fastcgi繁忙时缓存块大小</li><li>fastcgi_temp_file_write_size 16k;   临时文件写入大小            </li><li>fastcgi_cache_valid 200 302 1h;  缓存失效时间</li><li>fastcgi_cache_min_uses 1;   缓存最小使用时间<h3 id="3）使用lua等"><a href="#3）使用lua等" class="headerlink" title="3）使用lua等"></a>3）使用lua等</h3><h3 id="4）Nginx的缓存功能"><a href="#4）Nginx的缓存功能" class="headerlink" title="4）Nginx的缓存功能"></a>4）Nginx的缓存功能</h3></li><li>缓存把URL及相关组合当作Key，用md5编码哈希后保存；</li><li>Nginx的Web缓存服务只能为指定URL或状态码设置过期时间，不支持类似 Squid的PURGE指令，手动清除指定缓存页面；</li><li>采用MMAP实现，设置的缓存区大小不能超过物理内存+SWAP的值。</li><li>反向代理中的Nginx.conf配置缓存</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Nginx监控&quot;&gt;&lt;a href=&quot;#1-Nginx监控&quot; class=&quot;headerlink&quot; title=&quot;1.Nginx监控&quot;&gt;&lt;/a&gt;1.Nginx监控&lt;/h2&gt;&lt;h3 id=&quot;1）StubStatus&quot;&gt;&lt;a href=&quot;#1）StubStatus&quot; class=&quot;headerlink&quot; title=&quot;1）StubStatus&quot;&gt;&lt;/a&gt;1）StubStatus&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;StubStatus模块能够获取nginx自上次以来的工作状态，此模块非核心功能，需要在nginx编译安装时候手工指定才能使用&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;location /nginx_status &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stub_status on;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;access_log     /logs/Nginxstatus.log;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#auth_basic     “NginxStatus”;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#auth_basic _user_file    ../htpasswd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;allow all;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#deny all;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;stub_status on  表示启用StubStatus的工作状态统计功能，&lt;br&gt;access_log 用来指定StubStatus模块的访问日志文件；&lt;br&gt;auth_basic 是nginx的认证机制；auth_basic _user_file    用来指定认证的密码文件&lt;br&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://xyunlay.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="web服务器" scheme="http://xyunlay.github.io/tags/web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Nginx基础--高性能web服务器</title>
    <link href="http://xyunlay.github.io/2018/04/27/Nginx%E5%9F%BA%E7%A1%80--%E9%AB%98%E6%80%A7%E8%83%BDweb%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://xyunlay.github.io/2018/04/27/Nginx基础--高性能web服务器/</id>
    <published>2018-04-27T03:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h2><p>一个网站用户量、访问量上限的影响因素：服务器的硬件配置（CPU、内存、磁盘速度、网卡）、网站的程序优化程度、web服务器<br>传统web服务器（IIS、apache）:最初设计时要求功能比较多，支持各种各样的功能，这会导致服务器的性能、稳定性各方面不会太高<br>为提高用户访问量，使用高性能web服务器提升网站性能<br>Nginx是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。<br>Nginx是一款面向性能设计的HTTP服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势。与旧版本（&lt;=2.2）的Apache不同，nginx不采用每客户机一线程的设计模型，而是充分使用异步逻辑，削减了上下文调度开销，所以并发服务能力更强。整体采用模块化设计，有丰富的模块库和第三方模块库，配置灵活。 在Linux操作系统下，nginx使用epoll事件模型，得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue<br><a id="more"></a></p><h2 id="Ubuntu16-04安装Nginx"><a href="#Ubuntu16-04安装Nginx" class="headerlink" title="Ubuntu16.04安装Nginx"></a>Ubuntu16.04安装Nginx</h2><h3 id="安装Nginx依赖库"><a href="#安装Nginx依赖库" class="headerlink" title="安装Nginx依赖库"></a>安装Nginx依赖库</h3><h4 id="安装gcc-g-的依赖库"><a href="#安装gcc-g-的依赖库" class="headerlink" title="安装gcc g++的依赖库"></a>安装gcc g++的依赖库</h4><p>ubuntu平台可以使用如下命令。<br>1    apt-get install build-essential<br>2    apt-get install libtool</p><h4 id="安装-pcre依赖库（http-www-pcre-org-）"><a href="#安装-pcre依赖库（http-www-pcre-org-）" class="headerlink" title="安装 pcre依赖库（http://www.pcre.org/）"></a>安装 pcre依赖库（<a href="http://www.pcre.org/）" target="_blank" rel="noopener">http://www.pcre.org/）</a></h4><p>1    sudo apt-get update<br>2    sudo apt-get install libpcre3 libpcre3-dev </p><h4 id="安装-zlib依赖库（http-www-zlib-net）"><a href="#安装-zlib依赖库（http-www-zlib-net）" class="headerlink" title="安装 zlib依赖库（http://www.zlib.net）"></a>安装 zlib依赖库（<a href="http://www.zlib.net）" target="_blank" rel="noopener">http://www.zlib.net）</a></h4><p>1    apt-get install zlib1g-dev</p><h4 id="安装-ssl依赖库"><a href="#安装-ssl依赖库" class="headerlink" title="安装 ssl依赖库"></a>安装 ssl依赖库</h4><p>1    apt-get install openssl</p><h4 id="安装Nginx（http-nginx-org）"><a href="#安装Nginx（http-nginx-org）" class="headerlink" title="安装Nginx（http://nginx.org）"></a>安装Nginx（<a href="http://nginx.org）" target="_blank" rel="noopener">http://nginx.org）</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1#下载最新版本：</span><br><span class="line">2wget http://nginx.org/download/nginx-1.11.3.tar.gz （建议保存在/opt/下）</span><br><span class="line">3#解压：</span><br><span class="line">4tar -zxvf nginx-1.11.3.tar.gz</span><br><span class="line">5#进入解压目录：</span><br><span class="line">6cd nginx-1.11.3</span><br><span class="line">7#配置：</span><br><span class="line">8./configure --prefix=/usr/local/nginx  </span><br><span class="line">9#编辑nginx：</span><br><span class="line">10Make</span><br><span class="line">11</span><br><span class="line">12注意：这里可能会报错，提示“pcre.h No such file or directory”,具体详见：http://stackoverflow.com/questions/22555561/error-building-fatal-error-pcre-h-no-such-file-or-directory </span><br><span class="line">13需要安装 libpcre3-dev,命令为：sudo apt-get install libpcre3-dev</span><br><span class="line">14</span><br><span class="line">15#安装nginx：</span><br><span class="line">16sudo make install</span><br><span class="line">17#启动nginx：</span><br><span class="line">18sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf </span><br><span class="line">19注意：-c 指定配置文件的路径，不加的话，nginx会自动加载默认路径的配置文件，可以通过 -h查看帮助命令。</span><br></pre></td></tr></table></figure><p>这里可能出现文件不存在的问题，试了很多种方法，下面这个方法通过了<br>进入/usr/local/nginx目录</p><blockquote><p>   Sudo ./sbin/nginx -c conf/nginx.conf  </p></blockquote><p>这里可能出现80端口被Apache或者别的进程占用的问题，可以修改/usr/local/nginx/conf/nginx.conf配置中的listen:80，如修改为82，重新启动Nginx，若依旧出现问题，通过 lsof -i:82查看，发现是Nginx进程，通过killall -9 nginx杀掉进程，再重新启动</p><p>#查看nginx进程：</p><blockquote><p>   ps -ef|grep nginx  </p></blockquote><h3 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h3><h4 id="启动-Nginx"><a href="#启动-Nginx" class="headerlink" title="启动 Nginx"></a>启动 Nginx</h4><blockquote><p>1    /usr/local/nginx/sbin/nginx<br>2<br>3    ./sbin/nginx</p></blockquote><h4 id="停止-Nginx"><a href="#停止-Nginx" class="headerlink" title="停止 Nginx"></a>停止 Nginx</h4><blockquote><p>1    ./sbin/nginx -s stop<br>2<br>3    ./sbin/nginx -s quit</p></blockquote><p>-s都是采用向 Nginx 发送信号的方式。</p><h4 id="Nginx重新加载配置"><a href="#Nginx重新加载配置" class="headerlink" title="Nginx重新加载配置"></a>Nginx重新加载配置</h4><blockquote><p>1    ./sbin/nginx -s reload </p></blockquote><h4 id="指定配置文件"><a href="#指定配置文件" class="headerlink" title="指定配置文件"></a>指定配置文件</h4><blockquote><p> 1    ./sbin/nginx -c /usr/local/nginx/conf/nginx.conf  （上面指定过了）<br>-c表示configuration，指定配置文件</p></blockquote><h4 id="查看-Nginx-版本"><a href="#查看-Nginx-版本" class="headerlink" title="查看 Nginx 版本"></a>查看 Nginx 版本</h4><p>有两种可以查看 Nginx 的版本信息的参数。第一种如下：</p><blockquote><p>1    ./sbin/nginx -v<br>2<br>3    nginx: nginx version: nginx/1.0.0</p></blockquote><p>另一种显示的是详细的版本信息：</p><blockquote><p>1    poechant@ubuntu:/usr/local/nginx$ ./sbin/nginx -V<br>2    nginx: nginx version: nginx/1.0.0<br>3    nginx: built by gcc 4.3.3 (Ubuntu 4.3.3-5ubuntu4)<br>4    nginx: TLS SNI support enabled<br>5    nginx: configure arguments: –with-http_ssl_module –with-openssl=/home/luming/openssl-1.0.0d/</p></blockquote><h4 id="检查配置文件是否正确"><a href="#检查配置文件是否正确" class="headerlink" title="检查配置文件是否正确"></a>检查配置文件是否正确</h4><blockquote><p>1    poerchant@ubuntu:/usr/local/nginx$ sudo ./sbin/nginx -t<br>2    nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok<br>3    nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</p></blockquote><p>如果显示如上，则表示配置文件正确。否则，会有相关提示。</p><h4 id="显示帮助信息"><a href="#显示帮助信息" class="headerlink" title="显示帮助信息"></a>显示帮助信息</h4><blockquote><p> 1     poechant@ubuntu:/user/local/nginx$ ./sbin/nginx -h </p></blockquote><p>或者：</p><blockquote><p> 1     poechant@ubuntu:/user/local/nginx$ ./sbin/nginx -?  </p></blockquote><h2 id="Nginx介绍"><a href="#Nginx介绍" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h2><p>安装目录在/usr/local/nginx，目录下有四个文件夹<br>Conf：存放配置文件<br><img src="/assets/blogImg/nginx1.jpg" alt="Nginx基础"></p><p>主配置文件：nginx.congf<br><img src="/assets/blogImg/nginx2.jpg" alt="Nginx基础"><br><img src="/assets/blogImg/nginx3.jpg" alt="Nginx基础"></p><p>Html ：默认网站的根目录<br><img src="/assets/blogImg/nginx4.jpg" alt="Nginx基础"></p><p>Logs：存放日志<br><img src="/assets/blogImg/nginx5.jpg" alt="Nginx基础"></p><p>Sbin ：Nginx主程序<br><img src="/assets/blogImg/nginx6.jpg" alt="Nginx基础"><br>启动Nginx： ./sbin/nginx<br>启动失败的话可能是由于80端口被其他程序占用了</p><h2 id="Nginx与apache2性能比较"><a href="#Nginx与apache2性能比较" class="headerlink" title="Nginx与apache2性能比较"></a>Nginx与apache2性能比较</h2><p>在相同硬件条件下,使用ab工具对统一静态页面（拷贝/usr/local/nginx/html/index.html到/var/www/下）进行压力测试<br><img src="/assets/blogImg/nginx7.jpg" alt="Nginx基础"></p><h4 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h4><p>ab -c 1 -n 10000 <a href="http://127.0.0.1/index.html" target="_blank" rel="noopener">http://127.0.0.1/index.html</a><br><img src="/assets/blogImg/nginx8.jpg" alt="Nginx基础"></p><p>停止apache服务，启动Nginx<br><img src="/assets/blogImg/nginx9.jpg" alt="Nginx基础"></p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>ab -c 1 -n 10000 <a href="http://127.0.0.1/index.html" target="_blank" rel="noopener">http://127.0.0.1/index.html</a><br><img src="/assets/blogImg/nginx10.jpg" alt="Nginx基础"></p><p>观察上述数据中的每秒请求数，可以比较出，在环境一致的情况下，且Nginx配置未做任何调优，此时Nginx的性能已经比apache要高很多而来</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Nginx简介&quot;&gt;&lt;a href=&quot;#Nginx简介&quot; class=&quot;headerlink&quot; title=&quot;Nginx简介&quot;&gt;&lt;/a&gt;Nginx简介&lt;/h2&gt;&lt;p&gt;一个网站用户量、访问量上限的影响因素：服务器的硬件配置（CPU、内存、磁盘速度、网卡）、网站的程序优化程度、web服务器&lt;br&gt;传统web服务器（IIS、apache）:最初设计时要求功能比较多，支持各种各样的功能，这会导致服务器的性能、稳定性各方面不会太高&lt;br&gt;为提高用户访问量，使用高性能web服务器提升网站性能&lt;br&gt;Nginx是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。&lt;br&gt;Nginx是一款面向性能设计的HTTP服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势。与旧版本（&amp;lt;=2.2）的Apache不同，nginx不采用每客户机一线程的设计模型，而是充分使用异步逻辑，削减了上下文调度开销，所以并发服务能力更强。整体采用模块化设计，有丰富的模块库和第三方模块库，配置灵活。 在Linux操作系统下，nginx使用epoll事件模型，得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue&lt;br&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://xyunlay.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="web服务器" scheme="http://xyunlay.github.io/tags/web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>apache基础</title>
    <link href="http://xyunlay.github.io/2018/04/18/apache%E5%9F%BA%E7%A1%80/"/>
    <id>http://xyunlay.github.io/2018/04/18/apache基础/</id>
    <published>2018-04-18T03:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.017Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/apache1.jpg" alt="apache基础"></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h4 id="查看apache信息"><a href="#查看apache信息" class="headerlink" title="查看apache信息"></a>查看apache信息</h4><p>apache2 -V<br><img src="/assets/blogImg/apache2.jpg" alt="apache基础"><br><a id="more"></a></p><h4 id="查看当前已安装模块："><a href="#查看当前已安装模块：" class="headerlink" title="查看当前已安装模块："></a>查看当前已安装模块：</h4><p><img src="/assets/blogImg/apache3.jpg" alt="apache基础"></p><h4 id="查看静态编译入程序的模块："><a href="#查看静态编译入程序的模块：" class="headerlink" title="查看静态编译入程序的模块："></a>查看静态编译入程序的模块：</h4><p><img src="/assets/blogImg/apache4.jpg" alt="apache基础"></p><h4 id="查看apache进程："><a href="#查看apache进程：" class="headerlink" title="查看apache进程："></a>查看apache进程：</h4><p> ps aux | grep apache2<br><img src="/assets/blogImg/apache5.jpg" alt="apache基础"><br>进程号最小的是主进程（主进程号也可以在/var/run/apache2下查看）<br>上图中显示有一个主进程和三个子进程<br><img src="/assets/blogImg/apache6.jpg" alt="apache基础"><br><img src="/assets/blogImg/apache7.jpg" alt="apache基础"></p><h4 id="看端口："><a href="#看端口：" class="headerlink" title="看端口："></a>看端口：</h4><p> netstat -tupln | grep 80<br><img src="/assets/blogImg/apache8.jpg" alt="apache基础"></p><p>使用apxs2工具(可以独立编译apache的动态模块)<br>使用该工具需要安装apache2-dev</p><p><img src="/assets/blogImg/apache9.jpg" alt="apache基础"></p><h2 id="Apache-MPM（多进程模块）"><a href="#Apache-MPM（多进程模块）" class="headerlink" title="Apache MPM（多进程模块）"></a>Apache MPM（多进程模块）</h2><p><img src="/assets/blogImg/apache10.jpg" alt="apache基础"></p><h4 id="查看当前使用的MPM"><a href="#查看当前使用的MPM" class="headerlink" title="查看当前使用的MPM"></a>查看当前使用的MPM</h4><p>apache2  -V   或者 apache2 -l</p><h4 id="切换apache-MPM"><a href="#切换apache-MPM" class="headerlink" title="切换apache MPM"></a>切换apache MPM</h4><p>apt-get install apache2-mpm-prefork<br><img src="/assets/blogImg/apache11.jpg" alt="apache基础"><br><img src="/assets/blogImg/apache12.jpg" alt="apache基础"></p><h4 id="prefork和worker"><a href="#prefork和worker" class="headerlink" title="prefork和worker"></a>prefork和worker</h4><p><img src="/assets/blogImg/apache13.jpg" alt="apache基础"><br>Apache 默认的是 prefork模式，prefork基于进程实现，每个进程只能处理一个请求，故相较于worker模式，它更加的消耗内存和资源，但优势是效率更高。内存资源在成本和技术上并不存在问题，而且prefork是线程安全的，故默认使用prefork </p><p>Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。</p><h4 id="实时监控apache进程"><a href="#实时监控apache进程" class="headerlink" title="实时监控apache进程"></a>实时监控apache进程</h4><p>watch -n 2 ‘ps aux | grep apache2’<br><img src="/assets/blogImg/apache14.jpg" alt="apache基础"></p><p>apache增加子进程是以指数级增加 1-2-4-8-16-…</p><h4 id="条件性模块配置"><a href="#条件性模块配置" class="headerlink" title="条件性模块配置"></a>条件性模块配置</h4><p><img src="/assets/blogImg/apache15.jpg" alt="apache基础"></p><p>刚启动服务时默认启用的子进程数<br>最小空闲进程数量（最小存在）<br>最大空闲进程数量（出现高并发量时，并发处理完后杀掉部分进程后将保留maxspareservers）<br>severlimit：限制maxclient最大能配置到多大<br>最高并发量，最多处理多少请求 maxclient&lt;=serverlimit  （关注内存使用情况 查看每个子进程占用的内存量–top命令中的RES参数）<br>每一个子进程能够处理的最大请求数量 （防止内存泄露或者进程假死）</p><h2 id="Apache-性能调试"><a href="#Apache-性能调试" class="headerlink" title="Apache 性能调试"></a>Apache 性能调试</h2><p><img src="/assets/blogImg/apache16.jpg" alt="apache基础"><br><img src="/assets/blogImg/apache17.jpg" alt="apache基础"><br><img src="/assets/blogImg/apache18.jpg" alt="apache基础"><br><img src="/assets/blogImg/apache19.jpg" alt="apache基础"><br><img src="/assets/blogImg/apache20.jpg" alt="apache基础"><br><img src="/assets/blogImg/apache21.jpg" alt="apache基础"><br><img src="/assets/blogImg/apache22.jpg" alt="apache基础"><br><img src="/assets/blogImg/apache23.jpg" alt="apache基础"></p><p>模块<br><img src="/assets/blogImg/apache24.jpg" alt="apache基础"><br><img src="/assets/blogImg/apache25.jpg" alt="apache基础"></p><h2 id="Apache配置文件"><a href="#Apache配置文件" class="headerlink" title="Apache配置文件"></a>Apache配置文件</h2><p>Apache.conf<br>apache主目录 配置文件<br><img src="/assets/blogImg/apache26.jpg" alt="apache基础"></p><p>apache主进程pid文件<br><img src="/assets/blogImg/apache27.jpg" alt="apache基础"></p><p>进程超时时间：防止被攻击，不宜过长<br><img src="/assets/blogImg/apache28.jpg" alt="apache基础"></p><p>TCP保持连接  在一次TCP连接中进行多次请求<br><img src="/assets/blogImg/apache29.jpg" alt="apache基础"></p><p>指定一次一个TCP连接最多进行的请求数量<br><img src="/assets/blogImg/apache30.jpg" alt="apache基础"></p><p>一个TCP连接两次请求之间的最长时间间隔<br><img src="/assets/blogImg/apache31.jpg" alt="apache基础"></p><p>默认apache会加载所有常用模块，可以删除以精简apache服务</p><p>指定apache子进程的所属用户<br><img src="/assets/blogImg/apache32.jpg" alt="apache基础"></p><p>加载分布式访问控制的配置文件 针对每个目录进行访问控制，将访问控制写到该目录的.htaccess文件中<br><img src="/assets/blogImg/apache33.jpg" alt="apache基础"></p><p>对文件访问进行控制<br><img src="/assets/blogImg/apache34.jpg" alt="apache基础"></p><p>指定网页默认的类型<br><img src="/assets/blogImg/apache35.jpg" alt="apache基础"></p><p>是否进行域名的解析 access.log记录访问信息，设置为on的话就会将IP地址解析成域名<br><img src="/assets/blogImg/apache36.jpg" alt="apache基础"></p><p>错误日志的路径<br><img src="/assets/blogImg/apache37.jpg" alt="apache基础"></p><p>日志的详细程度（debug是最多的）<br><img src="/assets/blogImg/apache38.jpg" alt="apache基础"></p><p>日志的格式<br><img src="/assets/blogImg/apache39.jpg" alt="apache基础"></p><p>httpd.conf文件<br>应用到指定目录（/var/django/dyPLM/media）的<br>针对一个目录都有哪些的访问控制<br><img src="/assets/blogImg/apache40.jpg" alt="apache基础"></p><p>设置别名<br><img src="/assets/blogImg/apache41.jpg" alt="apache基础"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/apache1.jpg&quot; alt=&quot;apache基础&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;h4 id=&quot;查看apache信息&quot;&gt;&lt;a href=&quot;#查看apache信息&quot; class=&quot;headerlink&quot; title=&quot;查看apache信息&quot;&gt;&lt;/a&gt;查看apache信息&lt;/h4&gt;&lt;p&gt;apache2 -V&lt;br&gt;&lt;img src=&quot;/assets/blogImg/apache2.jpg&quot; alt=&quot;apache基础&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://xyunlay.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="web服务器" scheme="http://xyunlay.github.io/tags/web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>性能分析</title>
    <link href="http://xyunlay.github.io/2018/04/17/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <id>http://xyunlay.github.io/2018/04/17/性能分析/</id>
    <published>2018-04-17T02:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.019Z</updated>
    
    <content type="html"><![CDATA[<h4 id="buffer-与cache-的区别"><a href="#buffer-与cache-的区别" class="headerlink" title="buffer 与cache 的区别"></a>buffer 与cache 的区别</h4><p>A buffer is something that has yet to be “written” to disk. A cache is something that has been “read” from the disk and stored for later use.<br>Buffer：缓冲区    快设备—-&gt;慢设备<br>Cache：缓存区     慢设备—-&gt;快设备<br><a id="more"></a></p><h2 id="前端性能分析："><a href="#前端性能分析：" class="headerlink" title="前端性能分析："></a>前端性能分析：</h2><h4 id="1-响应时间；快不快"><a href="#1-响应时间；快不快" class="headerlink" title="1.响应时间；快不快"></a>1.响应时间；快不快</h4><h4 id="2-响应的吞吐率（每秒钟服务器的响应的大小，以字节为单位）；"><a href="#2-响应的吞吐率（每秒钟服务器的响应的大小，以字节为单位）；" class="headerlink" title="2.响应的吞吐率（每秒钟服务器的响应的大小，以字节为单位）；"></a>2.响应的吞吐率（每秒钟服务器的响应的大小，以字节为单位）；</h4><p>1）服务器带宽（以位为单位，故要/8，换算为字节）<br>2）客户端带宽</p><h4 id="3-TPS（每秒事务数）；设计性能需求"><a href="#3-TPS（每秒事务数）；设计性能需求" class="headerlink" title="3.TPS（每秒事务数）；设计性能需求"></a>3.TPS（每秒事务数）；设计性能需求</h4><h4 id="4-HPS（每秒点击数）；减少HTTP请求"><a href="#4-HPS（每秒点击数）；减少HTTP请求" class="headerlink" title="4.HPS（每秒点击数）；减少HTTP请求"></a>4.HPS（每秒点击数）；减少HTTP请求</h4><h2 id="服务器性能分析："><a href="#服务器性能分析：" class="headerlink" title="服务器性能分析："></a>服务器性能分析：</h2><h4 id="1-CPU"><a href="#1-CPU" class="headerlink" title="1.CPU"></a>1.CPU</h4><p>  1）CPU使用率   %Processor Time<br>    处理频率，内核数量，一级缓存，二级缓存，三级缓存的大小<br>  2）处理器队列长度  Processor Queue Length （2*内核数）</p><h4 id="2-带宽"><a href="#2-带宽" class="headerlink" title="2.带宽"></a>2.带宽</h4><p>  1）每秒钟接受的数据量，低于下行带宽/8<br>  2）每秒钟发送的数据量，低于上行带宽/8</p><h4 id="3-内存"><a href="#3-内存" class="headerlink" title="3.内存"></a>3.内存</h4><p>  1）内存使用率   可用内存数量（M）<br>  2）内存的页交换频率  Page/sec (内存与虚拟内存之间的数据交换，越低越好，最好控制在10000以内)<br>  3）缓存<br>  4）虚拟内存：利用一块硬盘区域模拟内存操作   </p><h4 id="4-磁盘I-O"><a href="#4-磁盘I-O" class="headerlink" title="4.磁盘I/O"></a>4.磁盘I/O</h4><p>  1）硬盘使用率    %Disk Time<br>  2）硬盘队列长队   Disk Queue Length<br>  3) 硬盘本身自带缓存  （16M，32M；固态硬盘：512M，1G）</p><h4 id="5-线程-线程池"><a href="#5-线程-线程池" class="headerlink" title="5.线程/线程池"></a>5.线程/线程池</h4><p>  1）线程：主要消耗的时CPU的资源，CPU的资源是有限的<br>  2）多线程 （CPU：多核多线程<br>              分布式应用服务器：多线程，每个线程负责一个用户请求<br>              数据库：多线程，每个线程处理一个SQL请求）<br>  3) 线程池：用于管理多线程的一种机制<br>  4) 动态影响 :  </p><pre><code>* (1) 请求的RT（响应时间）为：3秒，60秒时间内可以发送20个* (2) 三层架构，C(客户端)-----S(服务器)----D(数据库)，瓶颈可能出现在任意一层   线程池的大小越大越好，但受CPU的限制，太大会造成CPU负担.服务器处理速度变慢   利用Apache服务器演示线程数量（修改http.conf文件的ThreadsPerChild参数）* (3)Cpu进程等待-----&gt;内存增加-----&gt;虚拟内存的增加-----&gt;磁盘I/O开销增加-----&gt;CPU开销增加（进程的切换，缺页的处理） **</code></pre><p>5EG95LMIH3NH7785<br><img src="/assets/blogImg/xingnengfenxi1.jpg" alt="性能分析"></p><p><img src="/assets/blogImg/xingnengfenxi2.jpg" alt="性能分析"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;buffer-与cache-的区别&quot;&gt;&lt;a href=&quot;#buffer-与cache-的区别&quot; class=&quot;headerlink&quot; title=&quot;buffer 与cache 的区别&quot;&gt;&lt;/a&gt;buffer 与cache 的区别&lt;/h4&gt;&lt;p&gt;A buffer is something that has yet to be “written” to disk. A cache is something that has been “read” from the disk and stored for later use.&lt;br&gt;Buffer：缓冲区    快设备—-&amp;gt;慢设备&lt;br&gt;Cache：缓存区     慢设备—-&amp;gt;快设备&lt;br&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://xyunlay.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能分析" scheme="http://xyunlay.github.io/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>linux page buffer cache深入理解</title>
    <link href="http://xyunlay.github.io/2018/04/16/linux%20page%20buffer%20cache%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://xyunlay.github.io/2018/04/16/linux page buffer cache深入理解/</id>
    <published>2018-04-16T02:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.017Z</updated>
    
    <content type="html"><![CDATA[<p>Page cache和buffer cache一直以来是两个比较容易混淆的概念，在网上也有很多人在争辩和猜想这两个cache到底有什么区别，讨论到最后也一直没有一个统一和正确的结论，在我工作的这一段时间，page cache和buffer cache的概念曾经困扰过我，但是仔细分析一下，这两个概念实际上非常的清晰。如果能够了解到这两个cache的本质，那么我们在分析io问题的时候可能会更加得心应手。</p><a id="more"></a><p><strong> Page cache </strong> 实际上是针对文件系统的，是文件的缓存，在文件层面上的数据（在文件系统构架里，组成一个文件的有两部分：文件的元数据，即FCB，还有文件的业务数据，即比如平时我们用记事本程序打开一个文件所看到的数据。“在文件层面上的数据”指的就是文件的业务数据）会缓存到page cache（即page cache规划就是用来缓存来自在文件系统下的任一文件的业务数据所存放的那些扇区））。文件的逻辑层需要映射到实际的物理磁盘，这种映射关系由文件系统来完成。当page cache的数据需要刷新时，page cache中的数据交给buffer cache，但是这种处理在2.6版本的内核之后就变的很简单了，没有真正意义上的cache操作（是说直接将文件的业务数据（以扇区为读写的基本单位方式，这个方式也是数据从磁盘读取到buffer cache上的方式）读取到page cache上，不经过buffer cache？）。</p><p><strong> Buffer cache </strong> 是针对磁盘块（即扇区）的缓存（即buffer cache允许缓存的数据可以是来自一个磁盘上任意一个扇区的数据），也就是在没有文件系统的情况下（准确的表达是，无论有否文件系统的存在，设备驱动程序读取的数据（也即直接对磁盘进行操作的数据）都是缓存到buffer cache中的），直接对磁盘进行操作的数据会缓存到buffer cache中，例如，文件系统的元数据都会缓存到buffer cache中。<br>也就是说，首先我们要知道进程（0）（即设备驱动程序，或设备文件）对磁盘进行读写的基本单位是扇区（不是其他大小，如文件系统块大小），所以内存上(的是无论page cache，还是buffer cache)对磁盘进行读写的基本单位是扇区。进程（1）对Buffer cache进行读写的基本单位也是扇区，进程（2）对page cache进行读写的基本单位则是文件系统块。例如，buffer cache通过进程（0）（即设备驱动程序）从磁盘上读取一些数据（这些数据可能分散开的，也可能连续一起，如果更巧的话，正好连续成一个文件系统块的大小）是以扇区为基本单位，接着page cache通过进程（1）（非设备驱动程序了，是一般的程序了）从buffer cache上将这些数据读取到自己上也是以扇区为基本单位的，之后，进程（2）（非设备驱动程序了，是一般的程序了）从page cache上将这些数据读取到自己上时则是以文件系统块为基本单位的 。<br>Buffer cache算是属于硬盘分区这个层次的一部分， page cache 算是属于硬盘分区这个层次的上一层即文件系统这个层次的一部分 。文件系统对磁盘有一个自己的格式划分（即以文件系统块为划分单位），但是文件系统（的进程）不能直接去读写磁盘（即就不可能以文件系统块为单位来直接读写磁盘上的数据），文件系统（的进程）只能调用驱动程序去读写磁盘上的数据，驱动程序直接读写磁盘上的数据是以扇区为基本单位的，而直接对磁盘进行操作的数据则是（程序编程时规划）缓存到buffer cache中。<br>简单说来，page cache用来缓存文件数据（即文件的业务数据），buffer cache用来缓存磁盘数据（例如，在文件系统这个层次上，文件系统的元数据（比如，FAT文件系统中的文件分配表FAT就是属于文件系统的元数据），文件的元数据（即FCB，文件控制块（块，广义的概念是指一片存储区域，无关这片存储区域多大，即无关这片存储区域是否为如文件系统块或扇区的整数倍，小于它们或不是它们的整数倍都可以，像文件控制块就是128字节大小））；在硬盘分区这个层次上，主引导记录（Master Boot Record，缩写：MBR），又叫做主引导扇区，分区表（DPT,Disk Partition Table））。在有文件系统的情况下，对文件操作，那么数据会缓存到page cache，如果直接采用dd等工具对磁盘进行读写，那么数据会缓存到buffer cache。 </p><blockquote><p>更简单说来，<br>buffer cache允许缓存的数据可以是来自一个磁盘上任意一个扇区的数据，而page cache则规划就是用来缓存来自在文件系统下的任一文件的业务数据所存放的那些扇区。</p></blockquote><p>补充一点，在文件系统层每个设备都会分配一个def_blk_ops的文件操作方法，这是设备的操作方法，在每个设备的inode下面会存在一个radix tree，这个radix tree下面将会放置缓存数据的page页。这个page的数量将会在top程序的buffer一栏中显示。如果设备做了文件系统，那么会生成一个inode，这个inode会分配ext3_ops之类的操作方法，这些方法是文件系统的方法，在这个inode下面同样存在一个radix tree，这里会缓存文件的page页，缓存页的数量在top程序的cache一栏进行统计。从上面的分析可以看出，2.6内核中的buffer cache和page cache在处理上是保持一致（即对两个cache上的数据的操作方法类似）的，但是存在概念上的差别（即操作或叫针对的对象不一样），page cache针对文件的cache，buffer是针对磁盘块数据的cache，仅此而已。</p><p><strong>  buffer 与cache 的区别  </strong><br>A buffer is something that has yet to be “written” to disk. A cache is something that has been “read” from the disk and stored for later use.<br>更详细的解释参考：Difference Between Buffer and Cache<br>对于共享内存（Shared memory），主要用于在UNIX 环境下不同进程之间共享数据，是进程间通信的一种方法，一般的应用程序不会申请使用共享内存，笔者也没有去验证共享内存对上面等式的影响。如果你有兴趣，请参考：What is Shared Memory？</p><p><strong> cache 和 buffer的区别：  </strong><br>Cache：高速缓存，是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用，这样就减少了CPU的等待时间，提高了系统的效率。Cache又分为一级Cache（L1 Cache）和二级Cache（L2 Cache），L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上，现在也都集成在CPU内部，常见的容量有256KB或512KB L2 Cache.<br>Buffer：缓冲区，一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。</p><p><strong> Free中的buffer和cache：（它们都是占用内存）：  </strong> </p><blockquote><p>buffer ：作为buffer cache的内存，是块设备的读写缓冲区<br>cache（名词）：作为page cache的内存， 文件系统的cache<br>如果 cache（名词） 的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache（动词）住，那么磁盘的读IO 必会非常小。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Page cache和buffer cache一直以来是两个比较容易混淆的概念，在网上也有很多人在争辩和猜想这两个cache到底有什么区别，讨论到最后也一直没有一个统一和正确的结论，在我工作的这一段时间，page cache和buffer cache的概念曾经困扰过我，但是仔细分析一下，这两个概念实际上非常的清晰。如果能够了解到这两个cache的本质，那么我们在分析io问题的时候可能会更加得心应手。&lt;/p&gt;
    
    </summary>
    
    
      <category term="性能测试" scheme="http://xyunlay.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="操作系统" scheme="http://xyunlay.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="linux" scheme="http://xyunlay.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>《软件性能测试过程详解与案例剖析》读书笔记</title>
    <link href="http://xyunlay.github.io/2018/03/07/%E3%80%8A%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%89%96%E6%9E%90%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://xyunlay.github.io/2018/03/07/《软件性能测试过程详解与案例剖析》读书笔记/</id>
    <published>2018-03-07T02:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、软件测试基本概念"><a href="#1、软件测试基本概念" class="headerlink" title="1、软件测试基本概念"></a>1、软件测试基本概念</h2><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><p><img src="/assets/blogImg/dushubiji1.jpg" alt="读书笔记"></p><a id="more"></a><p>定义：对请求作出响应所需要的时间。是用户视角的软件性能的主要体现，带有主观色彩，没有绝对的长短。 “web页面合理响应时间标准”：2/5/10秒，10秒为上限<br>上图将响应时间划分为“呈现时间”和“系统响应时间”。“呈现时间”取决于数据在客户端收到数据后呈现页面所消耗时间，一般性能测试中不关注“呈现时间”，因为其很大程度上取决于客户端表现。因此此处响应时间多为“系统响应时间”。<br>页面响应时间可被进一步分解为：“网络传输时间”、“数据库延迟时间”和“应用服务器延迟时间”</p><h4 id="并发数"><a href="#并发数" class="headerlink" title="并发数"></a>并发数</h4><p>业务并发用户数定义：同一时间段内访问系统的用户数量（虽然在访问系统，但不一定对服务端产生压力，比如只是在浏览系统）<br>服务端承受的最大并发访问数定义：从服务端承受的压力出发，描述的是同时向客户端发出请求的客户，体现的是服务端承受的最大并发访问数，常结合并发测试，来发现系统中存在的并发引起的资源竞争等问题。<br>例：如果一个OA系统有2000名用户，最高峰时有500人在线，其中40%在看系统公告，20%在发呆，20%在进行页面跳转，20%在填写表单。则：系统用户数为2000，在线用户数为500，业务并发用户数为500，服务端承受并发数取决于业务并发用户数及用户业务场景。<br><img src="/assets/blogImg/dushubiji2.jpg" alt="读书笔记"></p><p>上图用于估算业务并发用户数： 其中，公式1中C为平均并发用户数，n是login session的用户数，L是login session的平均长度，T是考察的时间段的长度，一般为8小时工作时间。公式2给出了并发用户数峰值计算方式，该公式由泊松分布估算得到。若知道平均每个用户发出的请求数u，可估算吞吐量为u*C。<br>可通过“日志分析”对应用服务器进行分析，从而了解并发数数据，推荐AWStats开源工具（<a href="http://awstats.sourceforge.net/）" target="_blank" rel="noopener">http://awstats.sourceforge.net/）</a></p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><ul><li>定义：单位时间内系统处理的客户请求的数量，一般web系统用请求数/秒 或 页面数/秒来衡量。从业务角度，可用访问人数/天、业务数/小时衡量，或网络角度字节数/天</li><li>在没有遇到性能瓶颈时，吞吐量可计算为：F=(N*R)/T。其中N表示用户个数；R表示每个用户发出的请求数量，T表示性能测试所用的时间。</li><li>常用于分析分析吞吐量的图形是“吞吐量——VU数量（虚拟用户数）”的关联图。虽然吞吐量指标被看做系统承受压力的体现，但在不同并发用户数量的情况下，对一个系统施加相同的吞吐量压力，可能得到不同的测试效果。例如，对同一个系统，测试A采用100个VU，每个VU间隔1s发出一个请求；测试B采用1000个并发，每隔10秒发出一个请求；两者吞吐量均为100，但B会更容易出现性能瓶颈。 两个不同系统可能具有不同用户数和用户使用模式，但如果具有基本一致的吞吐量，则可以说他们具有基本相同的平均处理能力。<br>性能计数器：内存数、进程时间；资源利用率<h4 id="思考时间（Think-Time），或休眠时间"><a href="#思考时间（Think-Time），或休眠时间" class="headerlink" title="思考时间（Think Time），或休眠时间"></a>思考时间（Think Time），或休眠时间</h4></li><li>用户操作时每个请求间的间隔时间。自动化测试角度来说，必须在测试脚本中让各个操作之间等待一段时间。<h4 id="RBI测试方法：Rapid-Bottleneck-Identify"><a href="#RBI测试方法：Rapid-Bottleneck-Identify" class="headerlink" title="RBI测试方法：Rapid Bottleneck Identify"></a>RBI测试方法：Rapid Bottleneck Identify</h4><h4 id="性能下降曲线分析法：单用户区域；性能平坦区；压力区域；性能拐点"><a href="#性能下降曲线分析法：单用户区域；性能平坦区；压力区域；性能拐点" class="headerlink" title="性能下降曲线分析法：单用户区域；性能平坦区；压力区域；性能拐点"></a>性能下降曲线分析法：单用户区域；性能平坦区；压力区域；性能拐点</h4><h4 id="LoadRunner的性能测试过程"><a href="#LoadRunner的性能测试过程" class="headerlink" title="LoadRunner的性能测试过程"></a>LoadRunner的性能测试过程</h4><h2 id="2、性能测试的应用领域"><a href="#2、性能测试的应用领域" class="headerlink" title="2、性能测试的应用领域"></a>2、性能测试的应用领域</h2><h4 id="方法分类："><a href="#方法分类：" class="headerlink" title="方法分类："></a>方法分类：</h4></li><li>性能测试：模拟业务压力量和使用场景组合，验证系统是否具有所宣称的能力。</li><li>负载测试：通过在被测系统上不断增加压力，直到性能指标达到饱和状态，目的是找到系统的处理极限。通过“检测-加压-直到性能指标超过预期”的方法</li><li>压力测试：测试系统在一定饱和态下，例如CPU、内存等在饱和态下系统的会话能力，以及系统是否会出错。通过增加访问压力（如并发量），检测系统有无出错信息，以及系统响应时间，以及系统在一段时间内的稳定性。一般会以*“CPU使用率达75%以上，内存使用率达70%以上，系统错误率，响应时间”来作为描述。</li><li>配置测试：通过对系统软硬件调整，了解不同配置对系统性能影响程度，从而找到最优分配原则。一般用于性能调优和规划能力</li><li>并发测试：通过模拟用户并发访问，测试多用户并发访问一个应用时是否存在死锁或其他性能问题。主要关注内存泄露、线程锁、资源争用等。可针对系统或某种架构设计进行，可在开发各阶段使用。</li><li>可靠性测试：通过给系统加载一定的业务压力（如资源在70%~90%使用率），让应用持续运行一段时间，测试系统是否稳定。</li><li>失效恢复测试：针对有冗余备份和负载均衡的系统设计，可以用来检验如果系统局部发生故障，用户能否继续使用系统，以及用户将受多大程度的影响。<h4 id="应用领域："><a href="#应用领域：" class="headerlink" title="应用领域："></a>应用领域：</h4></li><li>能力验证：对一个已部署系统的性能进行验证。如性能测试，可靠性测试，压力测试，失效恢复测试</li><li>规划能力：关心如何才能使系统具有我们要求的性能能力，如系统能否支持未来一段时间内的用户增长。 是一种探索性测试。如负载测试，配置测试和压力测试</li><li>性能调优：配置测试，负载测试，压力测试和失效恢复测试</li><li>发现缺陷：并发测试，压力测试，失效恢复测试<h2 id="3、性能计数器及性能分析方法"><a href="#3、性能计数器及性能分析方法" class="headerlink" title="3、性能计数器及性能分析方法"></a>3、性能计数器及性能分析方法</h2>操作系统级别、应用服务器级别和数据库级别上查看和记录分析<br>操作系统计数器：<h3 id="Windows操作系统主要计数器"><a href="#Windows操作系统主要计数器" class="headerlink" title="Windows操作系统主要计数器"></a>Windows操作系统主要计数器</h3></li></ul><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:center">计数器名称</th><th style="text-align:right">计数器描述</th></tr></thead><tbody><tr><td style="text-align:left">Memory</td><td style="text-align:center">Available Mbytes</td><td style="text-align:right">可用物理内存</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Pages/sec</td><td style="text-align:right">表明由于硬件页面错误而从磁盘取出的页面数，或由于页面错误而写入磁盘以释放工作集空间的页面数</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Pages Read/sec</td><td style="text-align:right">页的硬故障，Pages/sec的子集，为了解析对内存的引用，必须读取页文件的次数。大数值表示是磁盘读而不是缓存读</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Pages Faults/sec</td><td style="text-align:right">此值为处理器中的页面错误的技术</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Cache Bytes</td><td style="text-align:right">文件系统缓存，默认情况下为50%的可用物理内存</td></tr><tr><td style="text-align:left">Process</td><td style="text-align:center">%Processor Time</td><td style="text-align:right">被处理器消耗的处理器时间数量</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Pages Faults/sec</td><td style="text-align:right">将进程产生的页故障与系统产生的相比较，以判断这个进程对系统页故障产生的影响</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Work set</td><td style="text-align:right">处理线程最近使用的内存页，反映了每一个进程使用的内存页的数量</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Private Bytes</td><td style="text-align:right">此进程所分配的无法与其他进程共享的当前字节数量</td></tr><tr><td style="text-align:left">Processor</td><td style="text-align:center">%Processor Time</td><td style="text-align:right">如果该值持续超过95%，表明瓶颈是CPU</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">%User Time</td><td style="text-align:right">非内核操作耗费的CPU时间</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">%Privileged Time</td><td style="text-align:right">CPU内核时间是在特权模式下处理线程执行代码所花时间的百分比</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">%DPC Time</td><td style="text-align:right">CPU消耗在网络处理上的时间</td></tr><tr><td style="text-align:left">Physical Disk</td><td style="text-align:center">%Disk Time</td><td style="text-align:right">指所选磁盘驱动器忙于为读或写入请求提供服务所用的时间的百分比</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Average Disk Queue Length</td><td style="text-align:right">指读取和写入请求的平均数</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Average Disk Read/Write Queue Length</td><td style="text-align:right">指读取（写入）请求的平均数</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Disk Reads(Writes)/sec</td><td style="text-align:right">物理磁盘上每秒钟磁盘读，写的次数</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Average Disk sec/Read</td><td style="text-align:right">指以秒计算的在此盘上写入数据的所需平均时间</td></tr><tr><td style="text-align:left">Network interface</td><td style="text-align:center">Average Disk sec/Transfer</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">System</td><td style="text-align:center">Bytes Total/sec</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">%Total processor Time</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">File Data Operations/sec</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Processor Queue Length</td></tr></tbody></table><h3 id="Linux操作系统主要计数器"><a href="#Linux操作系统主要计数器" class="headerlink" title="Linux操作系统主要计数器"></a>Linux操作系统主要计数器</h3><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:center">计数器名称</th><th style="text-align:right">计数器描述</th></tr></thead><tbody><tr><td style="text-align:left">Memory 1</td><td style="text-align:center">Free（KB）</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Swap(KB)</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">(page) si</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">(page) s0</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Cache(KB)</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">Process 2</td><td style="text-align:center">%CPU Usage</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Pages Fault count</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Resident size(KB)</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">Processor2</td><td style="text-align:center">%Idle Time</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">%User Time</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">%Kernel Time</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">%Iowait Time</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">Physical Disk 3</td><td style="text-align:center">Percent of time the disk is busy</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Average number of transactions actively being serviced</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Average number of transactions waiting for service</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Reads(Writes)per sec</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Average service  time active transactions, in milliseconds</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">The number of disk operations per second</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">Network interface</td><td style="text-align:center">参见Unix的SNMP接口内容</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">System 1</td><td style="text-align:center">%User Time</td><td style="text-align:right"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">CPU context switches</td></tr></tbody></table><p>注意：1.该计数器值来源于vmstat应用的输出结果<br>      2.该计数器值来源于top命令的输出结果<br>      3.该计数器值来源于iostat应用的输出结果<br>           Linux操作系统的命令与Unix稍有差别，Unix主要计数器监控命令是vmstat,iostat,top,sar和sag(图形方式，需要Xserver的支持)，而在Linux中，没有iostat命令，iostat可以监控的计数器被包含在vmstat计数器中，可以通过参数控制.</p><h4 id="内存分析方法（应用命令vmstat）："><a href="#内存分析方法（应用命令vmstat）：" class="headerlink" title="内存分析方法（应用命令vmstat）："></a>内存分析方法（应用命令vmstat）：</h4><p>内存分析需要用到的计数器包括Memory/PhysicalDisk计数器，以下是内存分析的主要步骤：<br>1.查看Memory/Available Mbytes指标（Linux系统中对应的指标是Free(KB)）<br>该数值描述了系统可用内存的直接指标，使用该数值建立一个初步印象，如果该数值较小，系统可能出现内存方面的问题，这是依据以下步骤进一步分析<br>2.注意Pages/sec,Pages Read/sec,Pages Faults/sec的值（Linux系统中对应的指标是(page)si和(page)so）<br>操作系统经常会利用磁盘交换的方式提高系统可用的内存量或内存的使用效率。如果Pages/sec,的计数持续高于几百？很可能会有内存方面的问题产生，但Pages/sec,的值很大不一定表明内存有问题，而可能是运行使用内存映射文件的程序所致。Pages Faults/sec值表明每秒发生页面失效的次数，页面失效次数越多，说明操作系统向内存中读取的次数越多。此时还需查看Pages Read/sec的计数值，该计数器的阙值为3，如果该计数值超过5，则可以判断存在内存方面的问题.<br>3.根据PhysicalDisk计数器的值分析性能瓶颈（Linux系统中对应的指标是Reads(Writes)per sec,Percent of time the disk is busy和Average number of transactions waiting for service）<br>包括对Page Reads/sec和%DiskTime及Average Disk Queue Length的分析.如果Page Reads/sec很低，同时%DiskTime和Average Disk Queue Length的值很高，则可能有磁盘瓶颈。但是如果队列长度增加的同时Page Reads/sec并未降低，则是由于内存不足.</p><h4 id="处理器分析方法（命令top）："><a href="#处理器分析方法（命令top）：" class="headerlink" title="处理器分析方法（命令top）："></a>处理器分析方法（命令top）：</h4><p>1.查看System\%Total processor Time性能计数器计数值：<br>该数值体现服务器整体的处理器利用率（或平均利用率）。当持续超过90%，则整个系统面临处理器方面的瓶颈，需增加处理器.要注意的是，在某些多处理器系统中，该数据本身不大，但若CPU之间的负载状况极不平衡，也应该视作产生了处理器瓶颈.<br>2.查看每个CPU的Processor\%Processor Time 和 Processor\%User Time(系统非核心操作消耗的CPU时间，如果该值较大，可以考虑是否能通过算法优化等方法降低该值，当服务器是数据库服务器时，可能是数据库排序或函数操作消耗时间，此时可以考虑对数据库系统进行优化) 和 Processor\%Privileged Time<br>3.研究系统处理器瓶颈<br>查看 System\Processor Queue Length，当其大于CPU数量总数+1时，说明出现处理器阻塞。当Processor\%Process Time较高时一般伴随阻塞，但产生处理器阻塞时，该值并不一定很大，此时需要查找处理器阻塞的原因。<br>%DPC Time是另一个需要关注的值，该计数值越低越好，在多处理器系统中，如果该值大于50%且Processor\%Processor Time值非常高，则考虑加入一个网卡来提高性能.</p><h4 id="磁盘I-O分析方法：（针对数据库服务器、或文件服务器、流媒体服务器，磁盘I-O更容易成为瓶颈"><a href="#磁盘I-O分析方法：（针对数据库服务器、或文件服务器、流媒体服务器，磁盘I-O更容易成为瓶颈" class="headerlink" title="磁盘I/O分析方法：（针对数据库服务器、或文件服务器、流媒体服务器，磁盘I/O更容易成为瓶颈)"></a>磁盘I/O分析方法：（针对数据库服务器、或文件服务器、流媒体服务器，磁盘I/O更容易成为瓶颈)</h4><p>1.计算每磁盘的I/O数<br>每磁盘的I/O数可用来与磁盘的I/O能力进行对比，如果经过计算得到的每磁盘I/O数超过了磁盘标称的I/O能力，则说明确实存在磁盘的性能瓶颈.<br>2.与Processor\Privileged Time合并进行分析<br>如果在PhysicalDisk计数器中，只有%Disk Time值比较大，其他值都比较适中，则硬盘可能会是瓶颈。如几个值都比较大，且数值持续超过80%，则可能是内存泄漏.<br>3.根据Disk sec/Transfer进行分析<br>Disk/Transfer 数值小于15好吗为优秀，介于15~30ms为良好，30~60毫秒为可以接受，超过60ms则需考虑更换硬盘或硬盘的RAID方式了</p><h4 id="进程分析方法："><a href="#进程分析方法：" class="headerlink" title="进程分析方法："></a>进程分析方法：</h4><p>1.查看进程的%Processor Time值，<br>每个进程的该值反应进程所消耗的处理器时间。<br>2.查看每个进程产生的页面失效。<br>可以用每个进程产生的页面失效和系统的页面失效的比值，来判断那个进程产生了最多的页面失效，该进程要么是需要大量内存的进程，要么是非常活跃的进程，可以对其重点分析.<br>3.了解进程的Process\Private Bytes（Linux系统对应的指标是Resident Size）<br>Process\Private Bytes是指进程所分配的无法与其他进程共享的当前字节数量。该计数器主要用来判断在性能测试过程中是否存在内存泄漏。例如，对于一个IIS之上的WEB应用，可以重点监控inetinfo进程的Private Bytes,如果在性能测试过程中，该进程的该计数器值不断增加，或是性能测试停止后一段时间，该进程的该值仍持续在高水平，这说明应用存在内存泄漏.</p><h4 id="网络分析方法："><a href="#网络分析方法：" class="headerlink" title="网络分析方法："></a>网络分析方法：</h4><p>1.注意Network Interface\Bytes Total/sec的值，该值为发送和接受字节的速率（包括帧字符在内），可以通过使用该值和目前网络的带宽进行比较判断网络速度是否是瓶颈.（Linux系统中可以参照Linux系统提供的SNMP服务接口进行网络分析）</p><h3 id="应用服务器计数器：（IIS应用服务器和Tomcat，weblogic，websphere等J2ee应用服务器）"><a href="#应用服务器计数器：（IIS应用服务器和Tomcat，weblogic，websphere等J2ee应用服务器）" class="headerlink" title="应用服务器计数器：（IIS应用服务器和Tomcat，weblogic，websphere等J2ee应用服务器）"></a>应用服务器计数器：（IIS应用服务器和Tomcat，weblogic，websphere等J2ee应用服务器）</h3><h3 id="数据库计数器"><a href="#数据库计数器" class="headerlink" title="数据库计数器"></a>数据库计数器</h3><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:center">计数器名称</th><th style="text-align:right">计数器描述</th></tr></thead><tbody><tr><td style="text-align:left">system</td><td style="text-align:center">Total Processor Time</td><td style="text-align:right">数据库进程占据CPU时间</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">User Connections</td><td style="text-align:right">当前的用户连接数</td></tr><tr><td style="text-align:left">Memory</td><td style="text-align:center">Cache Hit Ratio</td><td style="text-align:right">缓存命中率</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Total Server Memory</td><td style="text-align:right">SQL server数据库进程当前使用的内存量</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">PGA Memory/UGA Memory</td><td style="text-align:right">Oracle数据库进程的内存使用情况</td></tr><tr><td style="text-align:left">Lock</td><td style="text-align:center">Average Wait Time</td><td style="text-align:right">锁平均等待时间</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Lock Requests/sec</td><td style="text-align:right">每秒的锁请求数</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Number of Deadlocks/sec</td><td style="text-align:right">每秒产生的死锁数量</td></tr><tr><td style="text-align:left">I/O</td><td style="text-align:center">Outstanding Reads(Writes)</td><td style="text-align:right">被挂起的物理读（写）</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Page Reads/sec</td><td style="text-align:right">每秒页面读写的次数</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">Transactions/sec</td><td style="text-align:right">每秒产生的事务数量</td></tr></tbody></table><h2 id="4、性能测试工具原理"><a href="#4、性能测试工具原理" class="headerlink" title="4、性能测试工具原理"></a>4、性能测试工具原理</h2><p>性能测试不等同于性能测试工具；性能测试脚本录制是指录制服务端和应用之间的通信数据，而非GUI操作，需先选择录制的协议<br>性能测试架构（以load runner为例）<br><img src="/assets/blogImg/dushubiji3.jpg" alt="读书笔记"></p><ul><li>虚拟用户脚本生成器</li><li>压力产生器：用于根据校本内容产生实际的负载。（一般一台具有512MB内存的PC机可顺利运行200个左右的VU）</li><li>用户代理：是运行在负载机上的进程（可被看作压力产生器的组成部分），一般以后台方式在负载机上运行</li><li>压力调度和监控系统</li><li>压力结果分析功能</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、软件测试基本概念&quot;&gt;&lt;a href=&quot;#1、软件测试基本概念&quot; class=&quot;headerlink&quot; title=&quot;1、软件测试基本概念&quot;&gt;&lt;/a&gt;1、软件测试基本概念&lt;/h2&gt;&lt;h4 id=&quot;响应时间&quot;&gt;&lt;a href=&quot;#响应时间&quot; class=&quot;headerlink&quot; title=&quot;响应时间&quot;&gt;&lt;/a&gt;响应时间&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/assets/blogImg/dushubiji1.jpg&quot; alt=&quot;读书笔记&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://xyunlay.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="读书笔记" scheme="http://xyunlay.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>分析瓶颈总结--Linux</title>
    <link href="http://xyunlay.github.io/2018/02/27/%E5%88%86%E6%9E%90%E7%93%B6%E9%A2%88%E6%80%BB%E7%BB%93--Linux/"/>
    <id>http://xyunlay.github.io/2018/02/27/分析瓶颈总结--Linux/</id>
    <published>2018-02-27T02:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统瓶颈"><a href="#系统瓶颈" class="headerlink" title="系统瓶颈"></a>系统瓶颈</h2><h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><p>交互模式：</p><blockquote><p>输入M，进程列表按内存使用大小降序排序<br>输入P，进程列表按CPU使用大小降序排序</p></blockquote><p><img src="/assets/blogImg/fenxi-linux1.jpg" alt="分析瓶颈总结--Linux"><br>%id：空闲CPU时间百分比，如果该值过低，表明系统CPU存在瓶颈<br>%wa：等待I/O的CPU时间百分比，如果这个值过高，表明IO存在瓶颈<br><a id="more"></a></p><h2 id="内存瓶颈"><a href="#内存瓶颈" class="headerlink" title="内存瓶颈"></a>内存瓶颈</h2><h4 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h4><p><img src="/assets/blogImg/fenxi-linux2.jpg" alt="分析瓶颈总结--Linux"><br>系统实际可用的内存为free工具删除第二行的free+buffer+cached<br>[2][4]表示被几个进程共享的内存<br>[2][5]表示被OS buffer住的内存<br>[2][6]表示被OS cache住的内存</p><p><img src="/assets/blogImg/fenxi-linux3.jpg" alt="分析瓶颈总结--Linux"><br>buffer是用于存放要输出到disk块设备的数据的<br>cache是存放从disk上独处的数据的<br>Linux为了提高IO read的性能，总是要多cache一些数据，所以cached memory 总是比buffers memory大<br>[3][2] -buffers/cache 表示一个应用程序认为系统被用掉多少内存<br>[3][3] +buffers/cache 表示一个应用程序认为系统还有多少内存</p><h4 id="Vmstat命令"><a href="#Vmstat命令" class="headerlink" title="Vmstat命令"></a>Vmstat命令</h4><p>实时动态监测OS的虚拟内存、进程、CPU活动<br><img src="/assets/blogImg/fenxi-linux4.jpg" alt="分析瓶颈总结--Linux"><br><img src="/assets/blogImg/fenxi-linux5.jpg" alt="分析瓶颈总结--Linux"></p><h2 id="IO瓶颈"><a href="#IO瓶颈" class="headerlink" title="IO瓶颈"></a>IO瓶颈</h2><h4 id="iostat命令"><a href="#iostat命令" class="headerlink" title="iostat命令"></a>iostat命令</h4><p><img src="/assets/blogImg/fenxi-linux6.jpg" alt="分析瓶颈总结--Linux"><br>cpu属性值说明：</p><ul><li>%user：CPU处在用户模式下的时间百分比。</li><li>%nice：CPU处在带NICE值的用户模式下的时间百分比。</li><li>%system：CPU处在系统模式下的时间百分比。</li><li>%iowait：CPU等待输入输出完成时间的百分比。</li><li>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</li><li>%idle：CPU空闲时间百分比。<br>注：<br>如果%iowait的值过高，表示硬盘存在I/O瓶颈，<br>%idle值高，表示CPU较空闲，<br>如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。<br>%idle值如果持续于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。<br><img src="/assets/blogImg/fenxi-linux7.jpg" alt="分析瓶颈总结--Linux"></li></ul><p>disk属性值说明：</p><ul><li>rrqm/s: 每秒进行 merge 的读操作数目。即 rmerge/s</li><li>wrqm/s: 每秒进行 merge 的写操作数目。即 wmerge/s</li><li>r/s: 每秒完成的读 I/O 设备次数。即 rio/s</li><li>w/s: 每秒完成的写 I/O 设备次数。即 wio/s</li><li>rsec/s: 每秒读扇区数。即 rsect/s</li><li>wsec/s: 每秒写扇区数。即 wsect/s</li><li>rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。</li><li>wkB/s: 每秒写K字节数。是 wsect/s 的一半。</li><li>avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。</li><li>avgqu-sz: 平均I/O队列长度。</li><li>await: 平均每次设备I/O操作的等待时间 (毫秒)。</li><li>svctm: 平均每次设备I/O操作的服务时间 (毫秒)。</li><li>%util: 一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比<br>await 的参数也要多和 svctm 来参考。差的过高就一定有 IO 的问题<br>avgqu-sz 也是个做 IO 调优时需要注意的地方，这个就是直接每次操作的数据的大小，如果次数多，但数据拿的小的话，其实 IO 也会很小。如果数据拿的大，才IO 的数据会高。也可以通过 avgqu-sz × ( r/s or w/s ) = rsec/s or wsec/s。也就是讲，读写速度是这个来决定的。svctm 一般要小于 await (因为同时等待的请求的等待时间被重复计算了)，svctm 的大小一般和磁盘性能有关，CPU/内存的负荷也会对其有影响，请求过多也会间接导致 svctm 的增加。await 的大小一般取决于服务时间(svctm) 以及 I/O 队列的长度和 I/O 请求的发出模式。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明 I/O 队列太长，应用得到的响应时间变慢，如果响应时间超过了用户可以容许的范围，这时可以考虑更换更快的磁盘，调整内核 elevator 算法，优化应用，或者升级 CPU。<br>队列长度(avgqu-sz)也可作为衡量系统 I/O 负荷的指标，但由于 avgqu-sz 是按照单位时间的平均值，所以不能反映瞬间的 I/O 洪水。<br>形象的比喻：</li><li>r/s+w/s 类似于交款人的总数</li><li>平均队列长度(avgqu-sz)类似于单位时间里平均排队人的个数</li><li>平均服务时间(svctm)类似于收银员的收款速度</li><li>平均等待时间(await)类似于平均每人的等待时间</li><li>平均I/O数据(avgrq-sz)类似于平均每人所买的东西多少</li><li>I/O 操作率 (%util)类似于收款台前有人排队的时间比例</li></ul><h2 id="分析进程调用"><a href="#分析进程调用" class="headerlink" title="分析进程调用"></a>分析进程调用</h2><h4 id="Pstack命令"><a href="#Pstack命令" class="headerlink" title="Pstack命令"></a>Pstack命令</h4><p>此命令可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID<br>这个命令在排查进程问题时非常有用，比如我们发现一个服务一直处于work状态（如假死状态，好似死循环），使用这个命令就能轻松定位问题所在</p><h4 id="Strace命令"><a href="#Strace命令" class="headerlink" title="Strace命令"></a>Strace命令</h4><p>跟踪进程执行时的系统调用和所接收的信号<br>strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;系统瓶颈&quot;&gt;&lt;a href=&quot;#系统瓶颈&quot; class=&quot;headerlink&quot; title=&quot;系统瓶颈&quot;&gt;&lt;/a&gt;系统瓶颈&lt;/h2&gt;&lt;h4 id=&quot;top命令&quot;&gt;&lt;a href=&quot;#top命令&quot; class=&quot;headerlink&quot; title=&quot;top命令&quot;&gt;&lt;/a&gt;top命令&lt;/h4&gt;&lt;p&gt;交互模式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入M，进程列表按内存使用大小降序排序&lt;br&gt;输入P，进程列表按CPU使用大小降序排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/assets/blogImg/fenxi-linux1.jpg&quot; alt=&quot;分析瓶颈总结--Linux&quot;&gt;&lt;br&gt;%id：空闲CPU时间百分比，如果该值过低，表明系统CPU存在瓶颈&lt;br&gt;%wa：等待I/O的CPU时间百分比，如果这个值过高，表明IO存在瓶颈&lt;br&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://xyunlay.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能监控" scheme="http://xyunlay.github.io/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix server 安装配置文档</title>
    <link href="http://xyunlay.github.io/2018/02/26/Zabbix%20server%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/"/>
    <id>http://xyunlay.github.io/2018/02/26/Zabbix server 安装配置文档/</id>
    <published>2018-02-26T02:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>Zabbix Server需要运行在CentOS、RedHat Linux、Debain等Linux系统上，这里以CentOS6作为部署环境，Root用户安装必须的包，建议配置好yum，通过yum安装下列包，解决包的依赖关系。<br>1)    LAMP(Linux + Apache + Mysql + PHP)环境</p><blockquote><p>yum install mysql-server httpd php</p></blockquote><p>2)安装依赖包</p><blockquote><p>yum install mysql-devel net-snmp-devel OpenIPMI-devel openssl-devel fping-devel libcurl-devel perl-DBI php-gd php-mysql php-bcmath php-mbstring php-xml gcc</p></blockquote><p>可以到官网下载最新安装包<br><a id="more"></a><br><a href="http://jaist.dl.sourceforge.net/project/zabbix/ZABBIX%20Latest%20Stable/2.2.3/zabbix-2.2.3.tar.gz" target="_blank" rel="noopener">http://jaist.dl.sourceforge.net/project/zabbix/ZABBIX%20Latest%20Stable/2.2.3/zabbix-2.2.3.tar.gz</a><br>或者采用yum安装<br><a href="http://repo.zabbix.com/zabbix/2.2/rhel/6/x86_64/" target="_blank" rel="noopener">http://repo.zabbix.com/zabbix/2.2/rhel/6/x86_64/</a> 红帽yum源</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h4 id="1）创建zabbix用户和组"><a href="#1）创建zabbix用户和组" class="headerlink" title="1）创建zabbix用户和组"></a>1）创建zabbix用户和组</h4><p>groupadd zabbix<br>useradd zabbix -g zabbix</p><h4 id="2）创建数据库，添加授权账号"><a href="#2）创建数据库，添加授权账号" class="headerlink" title="2）创建数据库，添加授权账号"></a>2）创建数据库，添加授权账号</h4><p>create database zabbix character set utf8;<br>grant all privileges on zabbix.* to zabbix@localhost identified by ‘zabbix’;</p><h4 id="3）编译安装zabbix"><a href="#3）编译安装zabbix" class="headerlink" title="3）编译安装zabbix"></a>3）编译安装zabbix</h4><p>tar xzf zabbix-2.2.3.tar.gz<br>cd zabbix-2.2.3<br>./configure  –prefix=/usr/local/zabbix  –enable-server  –enable-agent \<br>–with-mysql  –with-net-snmp  –with-libcurl<br>make  install</p><h4 id="4）导入数据库"><a href="#4）导入数据库" class="headerlink" title="4）导入数据库"></a>4）导入数据库</h4><p>mysql -uzabbix -pzabbix -hlocalhost zabbix &lt; database/mysql/schema.sql<br>mysql -uzabbix -pzabbix -hlocalhost zabbix &lt; database/mysql/images.sql<br>mysql -uzabbix -pzabbix -hlocalhost zabbix &lt; database/mysql/data.sql</p><h4 id="5）修改配置文件"><a href="#5）修改配置文件" class="headerlink" title="5）修改配置文件"></a>5）修改配置文件</h4><p>cp misc/init.d/fedora/core/zabbix_server /etc/init.d/<br>cp misc/init.d/fedora/core/zabbix_agentd /etc/init.d/<br>cp -R frontends/php /var/www/html/zabbix<br>sed -i ‘s/^DBUser=.<em>$/DBUser=zabbix/g’ /usr/local/zabbix/etc/zabbix_server.conf<br>sed -i ‘s/^.</em>DBPassword=.*$/DBPassword=123456/g’ /usr/local/zabbix/etc/zabbix_server.conf<br>sed -i ‘s/BASEDIR=\/usr\/local/BASEDIR=\/usr\/local\/zabbix/g’ /etc/init.d/zabbix_server<br>sed -i ‘s/BASEDIR=\/usr\/local/BASEDIR=\/usr\/local\/zabbix/g’ /etc/init.d/zabbix_agentd</p><h4 id="6）添加服务端口"><a href="#6）添加服务端口" class="headerlink" title="6）添加服务端口"></a>6）添加服务端口</h4><p>cat &gt;&gt;/etc/services &lt;&lt;EOF<br>zabbix-agent 10050/tcp Zabbix Agent<br>zabbix-agent 10050/udp Zabbix Agent<br>zabbix-trapper 10051/tcp Zabbix Trapper<br>zabbix-trapper 10051/udp Zabbix Trapper<br>EOF</p><h4 id="7）启动服务并开机启动"><a href="#7）启动服务并开机启动" class="headerlink" title="7）启动服务并开机启动"></a>7）启动服务并开机启动</h4><p>/etc/init.d/zabbix_server start<br>/etc/init.d/zabbix_agentd start<br>echo “/etc/init.d/zabbix_server start” &gt;&gt; /etc/rc.local<br>echo “/etc/init.d/zabbix_agentd start” &gt;&gt; /etc/rc.local</p><h4 id="8）修改php-ini"><a href="#8）修改php-ini" class="headerlink" title="8）修改php.ini"></a>8）修改php.ini</h4><p>Vi /etc/php.ini<br>    memory_limit = 256M<br>    date.timezone = Asia/Shanghai<br>    post_max_size = 32M<br>    max_execution_time = 600<br>    upload_max_filesize = 16M<br>    max_input_time = 600</p><h4 id="9）web页面安装配置，打开浏览器输入http-zabbix-server-ip地址-zabbix"><a href="#9）web页面安装配置，打开浏览器输入http-zabbix-server-ip地址-zabbix" class="headerlink" title="9）web页面安装配置，打开浏览器输入http://zabbix server ip地址/zabbix"></a>9）web页面安装配置，打开浏览器输入<a href="http://zabbix" target="_blank" rel="noopener">http://zabbix</a> server ip地址/zabbix</h4><p>确认每个Required都是ok的才会显示Next按钮，如果有Fail的需要完善系统要求<br> <img src="/assets/blogImg/zabbix_server1.jpg" alt="Zabbix-server"><br> <img src="/assets/blogImg/zabbix_server2.jpg" alt="Zabbix-server"><br> <img src="/assets/blogImg/zabbix_server3.jpg" alt="Zabbix-server"><br> <img src="/assets/blogImg/zabbix_server4.jpg" alt="Zabbix-server"><br> <img src="/assets/blogImg/zabbix_server5.jpg" alt="Zabbix-server"><br> <img src="/assets/blogImg/zabbix_server6.jpg" alt="Zabbix-server"><br> <img src="/assets/blogImg/zabbix_server7.jpg" alt="Zabbix-server"><br> <img src="/assets/blogImg/zabbix_server8.jpg" alt="Zabbix-server"></p><p>更换中文字体，登陆后在页面的右上边点击“Prefile”<br><img src="/assets/blogImg/zabbix_server9.jpg" alt="Zabbix-server"></p><p>在Language选项中选择“Chinese（zh_CN）”，然后Save<br><img src="/assets/blogImg/zabbix_server10.jpg" alt="Zabbix-server"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;p&gt;Zabbix Server需要运行在CentOS、RedHat Linux、Debain等Linux系统上，这里以CentOS6作为部署环境，Root用户安装必须的包，建议配置好yum，通过yum安装下列包，解决包的依赖关系。&lt;br&gt;1)    LAMP(Linux + Apache + Mysql + PHP)环境&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;yum install mysql-server httpd php&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2)安装依赖包&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;yum install mysql-devel net-snmp-devel OpenIPMI-devel openssl-devel fping-devel libcurl-devel perl-DBI php-gd php-mysql php-bcmath php-mbstring php-xml gcc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以到官网下载最新安装包&lt;br&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://xyunlay.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能监控" scheme="http://xyunlay.github.io/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>NMON监测</title>
    <link href="http://xyunlay.github.io/2018/01/06/NMON%E7%9B%91%E6%B5%8B/"/>
    <id>http://xyunlay.github.io/2018/01/06/NMON监测/</id>
    <published>2018-01-06T02:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.015Z</updated>
    
    <content type="html"><![CDATA[<p>Nmon ( 又名 Nigel’s Monitor) 是非常常用的系统性能监视工具，由 IBM 工程师 Nigel Griffiths 开发，适用于 AIX 和 Linux 操作系统。该工具可以直接在屏幕上显示当前操作系统的资源利用率，以帮助大家找出系统瓶颈和协助系统调优。由于其十分出名，在 10大好用的Linux实用工具推荐 一文中已进行过简单推荐。</p><p>nmon 工具可以为 AIX 和 Linux 性能专家提供监视和分析性能数据的功能，其中包括：</p><ul><li>CPU 使用率</li><li>内存使用情况 </li><li>内核统计信息和运行队列信息 </li><li>磁盘 I/O 速度、传输和读/写比率 </li><li>文件系统中的可用空间 </li><li>磁盘适配器 </li><li>网络 I/O 速度、传输和读/写比率 </li><li>页面空间和页面速度 </li><li>CPU 和 AIX 规范</li><li>消耗资源最多的进程 </li><li>IBM HTTP Web 缓存 </li><li>用户自定义的磁盘组</li><li>计算机详细信息和资源</li><li>异步 I/O，仅适用于 AIX</li><li>工作负载管理器 (WLM)，仅适用于 AIX</li><li>IBM TotalStorage® Enterprise Storage Server® (ESS) 磁盘，仅适用于 AIX</li><li>网络文件系统 (NFS)</li><li>动态 LPAR (DLPAR) 更改，仅适用于面向 AIX 或 Linux 的 pSeries p5 和 OpenPower<br>还包括一个用来从 nmon 的输出生成图形并创建可以在 Web 站点显示的 .gif 文件的新工具<a id="more"></a></li></ul><h2 id="一-安装"><a href="#一-安装" class="headerlink" title="一.安装"></a>一.安装</h2><h4 id="1）安装"><a href="#1）安装" class="headerlink" title="1）安装"></a>1）安装</h4><p>sudo apt-get install nmon</p><h4 id="2）启动"><a href="#2）启动" class="headerlink" title="2）启动"></a>2）启动</h4><p>直接启动   nmon<br>或者在/usr/bin下启动       ./nmon<br><img src="/assets/blogImg/nmon1.jpg" alt="nmon"></p><pre><code>q : 停止并退出Nmonh : 查看帮助信息c : 查看 CPU 统计信息m : 查看内存统计信息d : 查看磁盘统计信息k : 查看内核统计信息n : 查看网络统计信息N : 查看 NFS 统计信息j : 查看文件系统统计信息t : 查看 Top 进程统计信息V : 查看虚拟内存统计信息v : 详细输出模式</code></pre><h2 id="二-输出示例"><a href="#二-输出示例" class="headerlink" title="二.输出示例"></a>二.输出示例</h2><p>图 2 说明了关于 CPU（这里是 4 CPU 的 POWER5 计算机，并打开了 SMT）、内存使用、内核内部统计和磁盘统计的详细信息。注意：这个逻辑分区 (LPAR) 占用了一半 CPU 中其授权值的 6 倍。<br>图 2. CPU 详细信息<br><img src="/assets/blogImg/nmon2.jpg" alt="nmon"><br>图 3 显示了网络、NFS 统计信息和日志文件系统使用的详细信息。<br>图 3. 网络详细信息<br><img src="/assets/blogImg/nmon3.jpg" alt="nmon"><br>在下面的图 4 中显示了 POWER5 共享处理器微分区统计的详细信息。<br>图 4. LPAR 详细信息<br><img src="/assets/blogImg/nmon4.jpg" alt="nmon"><br>图 5 说明了 Linux 版本的 nmon 的详细信息，其中显示了 CPU（这里是 2 CPU 的 POWER5 计算机，并打开了 SMT）、LPAR 统计、内存使用、网络统计、文件系统使用和磁盘统计的详细信息。注意：该 LPAR 的物理 CPU 仅在 SUSE SLES9 Service Pack 1 和 Red Hat EL 4 Update 1 中是可用的。<br>图 5. nmon 的 Linux 版本<br><img src="/assets/blogImg/nmon5.jpg" alt="nmon"><br>图 6 显示了计算机、磁盘统计（详细模式）和主要进程的操作系统详细信息。<br>图 6. nmon 的 Linux 版本（续）<br><img src="/assets/blogImg/nmon6.jpg" alt="nmon"></p><h2 id="三-生成nmon报告"><a href="#三-生成nmon报告" class="headerlink" title="三.生成nmon报告"></a>三.生成nmon报告</h2><h4 id="1-采集数据："><a href="#1-采集数据：" class="headerlink" title="1).采集数据："></a>1).采集数据：</h4><p>nmon -s time1 -c time2 -f -T -N -m filepath<br>参数-T以生成TOP等Sheet<br>参数-N以生成NFS Sheet<br>time1 为每多少秒采样一次，time2为总共采样的次数，两个数据合起来计算就是总共采样的时间。<br>filepath为nmon保存数据的路径，可以先使用pwd确定好路径之后再进行输入保存。</p><p>#nmon -s10 -c60 -f  -m /home/<br>参数解释：<br>-s10 每 10 秒采集一次数据。<br>-c60 采集 60 次，即为采集十分钟的数据。<br>-f 生成的数据文件名中包含文件创建的时间。<br>-m 生成的数据文件的存放目录。 没有- m指定的话数据文件就存放在当前目录<br>这样就会生成一个 nmon 文件，并每十秒更新一次，直到十分钟后。<br>生成的文件名如： _090824_1306.nmon ，”” 是这台主机的主机名。<br>nmon -h查看更多帮助信息。</p><h4 id="2-生成报表："><a href="#2-生成报表：" class="headerlink" title="2).生成报表："></a>2).生成报表：</h4><p>下载 nmon analyser (生成性能报告的免费工具)：<br><a href="https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/Power%20Systems/page/nmon_analyser" target="_blank" rel="noopener">https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/Power%20Systems/page/nmon_analyser</a><br>（复制该地址，然后到浏览器中打开即可）<br>   将之前生成的 nmon 数据文件传到 Windows 机器上，用 Excel 打开分析工具 nmon analyser v33C.xls 。点击 Excel 文件中的 “Analyze nmon data” 按钮，选择 nmon 数据文件，这样就会生成一个分析后的结果文件： hostname_090824_1306.nmon.xls ，用 Excel 打开生成的文件就可以看到结果了。<br>如果宏不能运行，需要做以下操作：<br>工具 -&gt; 宏 -&gt; 安全性 -&gt; 中，然后再打开文件并允许运行宏。<br>下面是在测试环境中生成的NMON报告截图：<br><img src="/assets/blogImg/nmon7.jpg" alt="nmon"><br>红色区域为不同指标的分析报告。</p><h4 id="3-自动按天采集数据："><a href="#3-自动按天采集数据：" class="headerlink" title="3).自动按天采集数据："></a>3).自动按天采集数据：</h4><p>在 crontab 中增加一条记录：（使用Linux crontab定时执行任务）<br>0 0 <em> </em> <em> root nmon -s300 -c288 -f -m /home/ &gt; /dev/null 2&gt;&amp;1<br>300</em>288=86400 秒，正好是一天的数据。 </p><p>参考文章：<br>nmon 性能：分析 AIX 和 Linux 性能的免费工具：<br><a href="http://www.ibm.com/developerworks/cn/aix/library/analyze_aix/index.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/aix/library/analyze_aix/index.html</a><br>nmon analyser —— 生成 AIX 性能报告的免费工具：<br><a href="http://www.ibm.com/developerworks/cn/aix/library/nmon_analyser/index.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/aix/library/nmon_analyser/index.html</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nmon ( 又名 Nigel’s Monitor) 是非常常用的系统性能监视工具，由 IBM 工程师 Nigel Griffiths 开发，适用于 AIX 和 Linux 操作系统。该工具可以直接在屏幕上显示当前操作系统的资源利用率，以帮助大家找出系统瓶颈和协助系统调优。由于其十分出名，在 10大好用的Linux实用工具推荐 一文中已进行过简单推荐。&lt;/p&gt;
&lt;p&gt;nmon 工具可以为 AIX 和 Linux 性能专家提供监视和分析性能数据的功能，其中包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 使用率&lt;/li&gt;
&lt;li&gt;内存使用情况 &lt;/li&gt;
&lt;li&gt;内核统计信息和运行队列信息 &lt;/li&gt;
&lt;li&gt;磁盘 I/O 速度、传输和读/写比率 &lt;/li&gt;
&lt;li&gt;文件系统中的可用空间 &lt;/li&gt;
&lt;li&gt;磁盘适配器 &lt;/li&gt;
&lt;li&gt;网络 I/O 速度、传输和读/写比率 &lt;/li&gt;
&lt;li&gt;页面空间和页面速度 &lt;/li&gt;
&lt;li&gt;CPU 和 AIX 规范&lt;/li&gt;
&lt;li&gt;消耗资源最多的进程 &lt;/li&gt;
&lt;li&gt;IBM HTTP Web 缓存 &lt;/li&gt;
&lt;li&gt;用户自定义的磁盘组&lt;/li&gt;
&lt;li&gt;计算机详细信息和资源&lt;/li&gt;
&lt;li&gt;异步 I/O，仅适用于 AIX&lt;/li&gt;
&lt;li&gt;工作负载管理器 (WLM)，仅适用于 AIX&lt;/li&gt;
&lt;li&gt;IBM TotalStorage® Enterprise Storage Server® (ESS) 磁盘，仅适用于 AIX&lt;/li&gt;
&lt;li&gt;网络文件系统 (NFS)&lt;/li&gt;
&lt;li&gt;动态 LPAR (DLPAR) 更改，仅适用于面向 AIX 或 Linux 的 pSeries p5 和 OpenPower&lt;br&gt;还包括一个用来从 nmon 的输出生成图形并创建可以在 Web 站点显示的 .gif 文件的新工具
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://xyunlay.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能监控" scheme="http://xyunlay.github.io/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Appium学习路—Android定位元素与操作</title>
    <link href="http://xyunlay.github.io/2017/08/06/Appium%E5%AD%A6%E4%B9%A0%E8%B7%AF%E2%80%94Android%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0%E4%B8%8E%E6%93%8D%E4%BD%9C/"/>
    <id>http://xyunlay.github.io/2017/08/06/Appium学习路—Android定位元素与操作/</id>
    <published>2017-08-06T02:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、常用识别元素的工具"><a href="#一、常用识别元素的工具" class="headerlink" title="一、常用识别元素的工具"></a>一、常用识别元素的工具</h2><p>uiautomator：Android SDK自带的一个工具，在tools目录下<br>monitor：Android SDK自带的一个工具，在tools目录下<br>Appium Inspector：Appium自带的一个功能，只有mac下可以使用该功能</p><p>下面是用monitor抓取到的页面元素<br><img src="/assets/blogImg/Appium1.jpg" alt="Appium">   </p> <a id="more"></a><p>下面使用Appium Inspector定位的元素<br><img src="/assets/blogImg/Appium2.jpg" alt="Appium"> </p><h2 id="二、元素定位"><a href="#二、元素定位" class="headerlink" title="二、元素定位"></a>二、元素定位</h2><h4 id="1-格式：find-element-by-定位方式-value"><a href="#1-格式：find-element-by-定位方式-value" class="headerlink" title="1.格式：find_element_by_定位方式(value)"></a>1.格式：find_element_by_定位方式(value)</h4><p>通过id定位<br>（取resource-id的值）：<br>driver.find_element_by_id(“com.wuba.zhuanzhuan:id/azo”)<br>也可以直接用id后面的内容driver.find_element_by_id(“azo”)</p><p>通过class_name定位<br>（取class的内容）<br>driver.find_element_by_class_name(“android.widget.RelativeLayout”)</p><p>通过xpath定位<br>（取xpath得内容）<br>driver.find_element_by_xpath(“//android.widget.LinearLayout[1]/android.widget.XXX”)</p><p>通过text定位<br>（需要使用uiautomator的定位方式，使用text的内容）<br>driver.find_elements_by_android_uiautomator(“new UiSelector().text(\”+关注\”)”)</p><p>使用这里需要注意一下，通过text定位的结果是个list，不能直接click。所以如果要点击需要取数组的值，比如下面是点击找到的第一个元素<br>driver.find_elements_by_android_uiautomator(“new UiSelector().text(\”+关注\”)”)[0].click()</p><p>通过css_selector定位（webview）<br>只适用于webview的html页面，继承自webdriver，与pc版本的UI测试一致<br>driver.find_element_by_css_selector()</p><p>通过link_text定位（webview）<br>只适用于webview容器中的html页面，继承自webdriver，与pc版本的UI测试一致<br>driver.find_element_by_link_text()</p><p>通过name定位<br>web view容器中的html页面可以用name定位，native并没有name属性<br>driver.find_element_by_name()</p><h4 id="2-定位元素的另一种写法：find-element-by-value"><a href="#2-定位元素的另一种写法：find-element-by-value" class="headerlink" title="2.定位元素的另一种写法：find_element(by,value)"></a>2.定位元素的另一种写法：find_element(by,value)</h4><p>find_element_by_方式(value)实际调用的都是find_element(by,value)<br>需要导入这个包：from selenium.webdriver.common.by import By</p><p>例如：定位id为ag2的元素<br>方式一：driver.find_element_by_id(“ag2”)<br>方式二：driver.find_element(By.ID,”ag2”)</p><p>这个操作的好处是可以直接把操作的by和value放到一个元组里，然后调用通用方法来传参获得元素结果<br>cateid=(By.ID,”ag2”)<br>driver.find_element(*cateid).click()</p><p>by的操作可以是：<br>By.ID   相当于by_id<br>By.CLASS_NAME  相当于by_class_name<br>By.XPATH   相当于by_xpath<br>By.NAME   相当于by_name<br>By.TAG_NAME   相当于by_tag_name<br>By.CSS_SELECTOR  相当于by_css_selector<br>By.LINK_TEXT  相当于by_link_text</p><h4 id="3-find-elements-by-定位方式-value-返回元素数组"><a href="#3-find-elements-by-定位方式-value-返回元素数组" class="headerlink" title="3.find_elements_by_定位方式(value)返回元素数组"></a>3.find_elements_by_定位方式(value)返回元素数组</h4><p>用法与find_element_by_方式(value)一致，但是返回一个数组。可以通过数组的索引来访问具体的某个结果</p><p>例如：通过class_name定位到多个元素，我想点击第一个元素<br>driver.find_elements_by_class_name(“android.widget.RelativeLayout”)[0].click()</p><h4 id="4-返回元素数组的另一种写法：find-elements-by-value"><a href="#4-返回元素数组的另一种写法：find-elements-by-value" class="headerlink" title="4.返回元素数组的另一种写法：find_elements(by,value)"></a>4.返回元素数组的另一种写法：find_elements(by,value)</h4><p>用法与find_element(by,value)一致，但是返回一个数组。可以通过数组的索引来访问具体的某个结果</p><p>例如：通过class_name定位到多个元素，我想点击第一个元素<br>driver.find_elements(By.CLASS_NAME,”android.widget.RelativeLayout”)[0].click()</p><h4 id="5-通过元素定位元素"><a href="#5-通过元素定位元素" class="headerlink" title="5.通过元素定位元素"></a>5.通过元素定位元素</h4><p>可以先找到某个元素，然后再进一步定位元素<br>find_element_by_class_xpath(“xxx”).find_element_by_name(“yyy”)</p><h2 id="三、元素操作"><a href="#三、元素操作" class="headerlink" title="三、元素操作"></a>三、元素操作</h2><p>找到元素后可以对元素进行的操作，例如上面讲的进一步定位元素</p><h4 id="1-click"><a href="#1-click" class="headerlink" title="1.click()"></a>1.click()</h4><p>点击操作<br>也可以用tab实现点击操作<br>driver.find_element_by_id(“com.wuba.zhuanzhuan:id/ae8”).click()</p><h4 id="2-clear"><a href="#2-clear" class="headerlink" title="2.clear()"></a>2.clear()</h4><p>清空输入框内容<br>driver.find_element_by_id(“com.wuba.zhuanzhuan:id/ij”).clear()</p><h4 id="3-send-xx"><a href="#3-send-xx" class="headerlink" title="3.send(xx)"></a>3.send(xx)</h4><p>输入框内输入内容<br>driver.find_element_by_id(“com.wuba.zhuanzhuan:id/ij”).send_keys(“test content”)</p><h4 id="4-text"><a href="#4-text" class="headerlink" title="4.text"></a>4.text</h4><p>获得元素的text内容<br>print(driver.find_element_by_xpath(“ //android.widget.LinearLayout[1]//xxx”).text)</p><h2 id="四、触摸操作"><a href="#四、触摸操作" class="headerlink" title="四、触摸操作"></a>四、触摸操作</h2><h4 id="1-driver-tap-坐标-，持续点击时间"><a href="#1-driver-tap-坐标-，持续点击时间" class="headerlink" title="1.driver.tap([坐标]，持续点击时间)"></a>1.driver.tap([坐标]，持续点击时间)</h4><p>除了定位到元素的点击外，也可以通过tab实现坐标的点击<br>driver.tap(driver.tap([(216,1776)],2))</p><h4 id="2-TouchAction-driver"><a href="#2-TouchAction-driver" class="headerlink" title="2.TouchAction(driver)"></a>2.TouchAction(driver)</h4><p>TouchAction对象包含（tab）、press（短按）、move_to（滑动到某个坐标）等方法<br>通过TouchAction对象，添加tap、move_to等操作，然后perform()执行，可以实现解锁屏幕等功能</p><p>规范中的可用事件有：</p><ul><li>短按 (press)</li><li>释放 (release)</li><li>移动到 (moveTo)</li><li>点击 (tap)</li><li>等待 (wait)</li><li>长按 (longPress)</li><li>取消 (cancel)</li><li>执行 (perform)<br><img src="/assets/blogImg/Appium3.jpg" alt="Appium"> </li></ul><p>例如：一个多次滑屏的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">action=TouchAction(driver)</span><br><span class="line">action.press(x=220,y=700).move_to(x=840, y=700).move_to(x=220, y=1530).move_to(x=840, y=1530).release().perform()</span><br></pre></td></tr></table></figure></p><p>可以通过wait()等待操作</p><h4 id="3-MultiAction-多点触控"><a href="#3-MultiAction-多点触控" class="headerlink" title="3.MultiAction()//多点触控"></a>3.MultiAction()//多点触控</h4><p>通过MultiAction().add()添加多个TouchAction操作，最后调用perform()一起执行这些操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">action0 = TouchAction().tap(el)</span><br><span class="line">action1 = TouchAction().tap(el)</span><br><span class="line">MultiAction().add(action0).add(action1).perform()</span><br></pre></td></tr></table></figure></p><h4 id="4-driver-swipe-x1-y1-x2-y2-duration"><a href="#4-driver-swipe-x1-y1-x2-y2-duration" class="headerlink" title="4.driver.swipe(x1, y1, x2, y2,duration)"></a>4.driver.swipe(x1, y1, x2, y2,duration)</h4><p>从坐标(x1,x2)滑动到坐标(x2,y2)，duration非必填项，滑动时间<br>（滑动的坐标不能超过屏幕的宽高）<br>可以通过【driver.get_window_size()】命令获得窗口高和宽，结果为{‘width’: 1080, ‘height’: 1776}</p><p>一个鼠标向上下左右活动的例子如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获得屏幕大小宽和高</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSize</span><span class="params">(driver)</span>:</span></span><br><span class="line">    x = driver.get_window_size()[<span class="string">'width'</span>]</span><br><span class="line">    y = driver.get_window_size()[<span class="string">'height'</span>]</span><br><span class="line">    <span class="keyword">return</span> (x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#屏幕向上滑动</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swipeUp</span><span class="params">(driver,t=<span class="number">1000</span>)</span>:</span></span><br><span class="line">    l = getSize(driver)</span><br><span class="line">    x1 = int(l[<span class="number">0</span>] * <span class="number">0.5</span>)    <span class="comment">#x坐标</span></span><br><span class="line">    y1 = int(l[<span class="number">1</span>] * <span class="number">0.75</span>)   <span class="comment">#起始y坐标</span></span><br><span class="line">    y2 = int(l[<span class="number">1</span>] * <span class="number">0.25</span>)   <span class="comment">#终点y坐标</span></span><br><span class="line">    driver.swipe(x1, y1, x1, y2,t)</span><br><span class="line"></span><br><span class="line"><span class="comment">#屏幕向下滑动</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swipeDown</span><span class="params">(driver,t=<span class="number">1000</span>)</span>:</span></span><br><span class="line">    l = getSize(driver)</span><br><span class="line">    x1 = int(l[<span class="number">0</span>] * <span class="number">0.5</span>)  <span class="comment">#x坐标</span></span><br><span class="line">    y1 = int(l[<span class="number">1</span>] * <span class="number">0.25</span>)   <span class="comment">#起始y坐标</span></span><br><span class="line">    y2 = int(l[<span class="number">1</span>] * <span class="number">0.75</span>)   <span class="comment">#终点y坐标</span></span><br><span class="line">    driver.swipe(x1, y1, x1, y2,t)</span><br><span class="line"><span class="comment">#屏幕向左滑动</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swipLeft</span><span class="params">(driver,t)</span>:</span></span><br><span class="line">    l=getSize(driver)</span><br><span class="line">    x1=int(l[<span class="number">0</span>]*<span class="number">0.75</span>)</span><br><span class="line">    y1=int(l[<span class="number">1</span>]*<span class="number">0.5</span>)</span><br><span class="line">    x2=int(l[<span class="number">0</span>]*<span class="number">0.05</span>)</span><br><span class="line">    driver.swipe(x1,y1,x2,y1,t)</span><br><span class="line"><span class="comment">#屏幕向右滑动</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swipRight</span><span class="params">(driver,t=<span class="number">1000</span>)</span>:</span></span><br><span class="line">    l=getSize(driver)</span><br><span class="line">    x1=int(l[<span class="number">0</span>]*<span class="number">0.05</span>)</span><br><span class="line">    y1=int(l[<span class="number">1</span>]*<span class="number">0.5</span>)</span><br><span class="line">    x2=int(l[<span class="number">0</span>]*<span class="number">0.75</span>)</span><br><span class="line">    driver.swipe(x1,y1,x2,y1,t)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用向下滑动的方法</span></span><br><span class="line">swipeDown(driver)</span><br></pre></td></tr></table></figure></p><h2 id="五、系统按键事件"><a href="#五、系统按键事件" class="headerlink" title="五、系统按键事件"></a>五、系统按键事件</h2><p>press_keycode(AndroidKeyCode)//发送按键事件<br>例如：点击home键，home键的KeyCode是3<br>driver.press_keycode(3)</p><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:center">描述</th><th style="text-align:right">键值</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_CALL</td><td style="text-align:center">拨号键</td><td style="text-align:right">5</td></tr><tr><td style="text-align:left">KEYCODE_ENDCALL</td><td style="text-align:center">挂机键</td><td style="text-align:right">6</td></tr><tr><td style="text-align:left">KEYCODE_HOME</td><td style="text-align:center">按键Home</td><td style="text-align:right">3</td></tr><tr><td style="text-align:left">KEYCODE_MENU</td><td style="text-align:center">菜单键</td><td style="text-align:right">82</td></tr><tr><td style="text-align:left">KEYCODE_BACK</td><td style="text-align:center">返回键</td><td style="text-align:right">4</td></tr><tr><td style="text-align:left">KEYCODE_SEARCH</td><td style="text-align:center">搜索键</td><td style="text-align:right">84</td></tr><tr><td style="text-align:left">KEYCODE_CAMERA</td><td style="text-align:center">拍照键</td><td style="text-align:right">27</td></tr><tr><td style="text-align:left">KEYCODE_FOCUS</td><td style="text-align:center">拍照对焦键</td><td style="text-align:right">80</td></tr><tr><td style="text-align:left">KEYCODE_POWER</td><td style="text-align:center">电源键</td><td style="text-align:right">26</td></tr><tr><td style="text-align:left">KEYCODE_NOTIFICATION</td><td style="text-align:center">通知键</td><td style="text-align:right">83</td></tr><tr><td style="text-align:left">KEYCODE_MUTE</td><td style="text-align:center">话筒静音键</td><td style="text-align:right">91</td></tr><tr><td style="text-align:left">KEYCODE_VOLUME_MUTE</td><td style="text-align:center">扬声器静音键</td><td style="text-align:right">164</td></tr><tr><td style="text-align:left">KEYCODE_VOLUME_UP</td><td style="text-align:center">音量增加键</td><td style="text-align:right">24</td></tr><tr><td style="text-align:left">KEYCODE_VOLUME_DOWN</td><td style="text-align:center">音量减小键</td><td style="text-align:right">25</td></tr></tbody></table><p>更多KeyCode可以查看下面的博客：<br><a href="http://blog.csdn.net/crisschan/article/details/50419963" target="_blank" rel="noopener">http://blog.csdn.net/crisschan/article/details/50419963</a></p><h2 id="六、driver的一些比较重要操作"><a href="#六、driver的一些比较重要操作" class="headerlink" title="六、driver的一些比较重要操作"></a>六、driver的一些比较重要操作</h2><h4 id="1-reset"><a href="#1-reset" class="headerlink" title="1.reset()"></a>1.reset()</h4><p>重置app<br>这时候driver会重置，相当于卸载重装应用。所以本地缓存会失效<br>driver.reset()</p><h4 id="2-start-activity-包名-activity名"><a href="#2-start-activity-包名-activity名" class="headerlink" title="2.start_activity(包名,activity名)"></a>2.start_activity(包名,activity名)</h4><p>启动app的某一个activity<br>例如：driver.start_activity(“com.wuba.zhuanzhuan”,”./presentation.view.activity.LaunchActivity”)</p><p>启动一个activity，这个activity必须是AndroidManifest.xml中有intent-filter的activity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class="line">   &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure></p><p>这种启动activity和driver的reset()不同的是</p><h4 id="3-contexts"><a href="#3-contexts" class="headerlink" title="3.contexts"></a>3.contexts</h4><p>获得所有contexts<br>driver.contexts<br>结果如下：<br>[‘NATIVE_APP’, ‘WEBVIEW_com.android.browser’]</p><p>NATIVE_APP：native的context<br>WEBVIEW_com.android.browser：webview的context，存放html的容器</p><h4 id="4-current-context"><a href="#4-current-context" class="headerlink" title="4.current_context"></a>4.current_context</h4><p>查看当前的context<br>driver.current_context</p><h4 id="5-switch-to-context-context名"><a href="#5-switch-to-context-context名" class="headerlink" title="5.switch_to.context(context名)"></a>5.switch_to.context(context名)</h4><p>切换context<br>driver.switch_to.context(“WEBVIEW_com.wuba.zhuanzhuan”)</p><p>NATIVE时不能定位WEBVIEW的内容，在WEBVIEW的context时不能定位NATIVE的内容。<br>所以需要切换到对应的context中去进行操作</p><h4 id="6-setNetworkConnection-bitmask掩码"><a href="#6-setNetworkConnection-bitmask掩码" class="headerlink" title="6.setNetworkConnection(bitmask掩码)"></a>6.setNetworkConnection(bitmask掩码)</h4><p>设置网络类型<br>例如：设置网络类型为只开wifi<br>driver.set_network_connection(2)</p><p>网络的bitmask掩码如下：</p><table><thead><tr><th style="text-align:left">值 (别名)</th><th style="text-align:center">数据连接</th><th style="text-align:center">Wifi连接</th><th style="text-align:right">飞行模式</th></tr></thead><tbody><tr><td style="text-align:left">0 (什么都没有)</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:right">0</td></tr><tr><td style="text-align:left">1 (飞行模式)</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:right">1</td></tr><tr><td style="text-align:left">2 (只有Wifi)</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:right">0</td></tr><tr><td style="text-align:left">4 (只有数据连接)</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:right">0</td></tr><tr><td style="text-align:left">6 (开启所有网络)</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:right">0</td></tr></tbody></table><h4 id="7-scroll-起始元素，结束元素"><a href="#7-scroll-起始元素，结束元素" class="headerlink" title="7.scroll(起始元素，结束元素)"></a>7.scroll(起始元素，结束元素)</h4><p>driver.scroll(origin_el,destination_el)</p><h4 id="8-获得当前页面的所有元素"><a href="#8-获得当前页面的所有元素" class="headerlink" title="8.获得当前页面的所有元素"></a>8.获得当前页面的所有元素</h4><p>driver.page_source</p><p>这可以用来判断元素是否存在，例如（assert “发布成功” in driver.page_source）</p><h4 id="9-补充一些driver启动时可能用到的项"><a href="#9-补充一些driver启动时可能用到的项" class="headerlink" title="9.补充一些driver启动时可能用到的项"></a>9.补充一些driver启动时可能用到的项</h4><p>其实这些在上一篇启动里都有介绍，但是有些可能大家没注意到的点再列一下。这些点也是我在测试中实际遇到的点</p><ul><li><p>autoLaunch ：Appium是否要自动启动或安装app，默认true<br>desired_caps[‘autoLaunch’] = ‘false’<br>有的时候我不想让appium每次都启动app，想自己去启动activity，那这个项这时就可以起作用了</p></li><li><p>noReset：在会话前是否重置app状态。默认是false<br>desired_caps[‘noReset’] = ‘true’</p></li><li><p>newCommandTimeout：设置未接收到新命令的超时时间，默认60s<br>如果60s内没有接收到新命令，appium会自动断开连接，如果我需要很长时间做driver之外的操作，可能延长接收新命令的超时时间<br>desired_caps[“newCommandTimeout”]=1800</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、常用识别元素的工具&quot;&gt;&lt;a href=&quot;#一、常用识别元素的工具&quot; class=&quot;headerlink&quot; title=&quot;一、常用识别元素的工具&quot;&gt;&lt;/a&gt;一、常用识别元素的工具&lt;/h2&gt;&lt;p&gt;uiautomator：Android SDK自带的一个工具，在tools目录下&lt;br&gt;monitor：Android SDK自带的一个工具，在tools目录下&lt;br&gt;Appium Inspector：Appium自带的一个功能，只有mac下可以使用该功能&lt;/p&gt;
&lt;p&gt;下面是用monitor抓取到的页面元素&lt;br&gt;&lt;img src=&quot;/assets/blogImg/Appium1.jpg&quot; alt=&quot;Appium&quot;&gt;   &lt;/p&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="APP测试" scheme="http://xyunlay.github.io/tags/APP%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Appium" scheme="http://xyunlay.github.io/tags/Appium/"/>
    
  </entry>
  
  <entry>
    <title>APP测试总结</title>
    <link href="http://xyunlay.github.io/2017/08/06/APP%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://xyunlay.github.io/2017/08/06/APP测试总结/</id>
    <published>2017-08-06T02:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.012Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 自动化脚本：</strong><br>UIAutomator : 只支持Java语言 ；只支持Android平台；<br>MonkeyRunner  ： 只支持Android平台；<br>TestComplete：商用软件收费；<br>Appium：跨平台；支持多种语言</p><p><strong> APP压力测试使用的知识：</strong><br>Adb命令<br>Monkey<br>Monkey Script<br>MonkeyRunner</p><h2 id="一-自动化实例"><a href="#一-自动化实例" class="headerlink" title="一 自动化实例"></a>一 自动化实例</h2><p>1 准备测试的app；准备测试环境；实现脚本；<br>2 测试app：只有登录功能<br>测试环境：</p><ul><li>Appium（Android/IOS）;</li><li>Android SDK;</li><li>Appium-Python-Client;</li><li>Selenium（Appium-Python-Client继承于Selenium); </li><li>UIAutomatorViewer</li><li>Pycharm<br>3 实现脚本<br>在Pycharm中编写脚本；<br>用UIAutomatorViewer进行定位；<br>借助Appium—Python—Client实现的api；<br>借助Appium—Python—Client的字典实现属性；<br>运行脚本之前要启动Appium并进行设置，<br>如果出现“新的session无法建立”的错误，请释放资源并重启Appium。</li></ul><a id="more"></a><h2 id="二压力测试"><a href="#二压力测试" class="headerlink" title="二压力测试"></a>二压力测试</h2><ul><li>针对APP服务器压力测试—-Jmeter  <a href="https://blog.csdn.net/mate_ge/article/details/78329482" target="_blank" rel="noopener">https://blog.csdn.net/mate_ge/article/details/78329482</a></li><li>针对APP前端压力测试—-安卓Monkey工具，iOS  UI AutoMonkey<br><strong> 安卓Monkey工具 </strong><br>对于安卓app，可以使用Monkey[MON01]工具，它是安卓软件开发工具包（SDK）。Monkey工具在物理设备或仿真器上都可以运行。运行时它生成虚拟随机的用户事件<br><strong> UI AutoMonkey </strong><br>对于iOS app来说，还可以使用一个类似的工具——UI AutoMonkey [UIA04]。UI AutoMonkey也能生成多个命令来对iOS app进行压力测试。要使用UI AutoMonkey，UIAutomation工具模板就要配置Xcode。配置好了之后，需要写一个JavaScript文件讲明压力测试期间需要执行多少以及哪些命令。<h3 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h3>手机系统中本身就存在Monkey，电脑终端通过USB与Android Debug Bridge（ADB）与手机的Monkey进行连接建立；通过ADB命令来向Monkey发送指令；<br>ADB是负责PC和手机系统的连接建立的，是调试手机上任何应用的入口.<br>MonkeyScript是一组可以被Monkey识别的命令集合；可以完成重复固定的操作；<br>MonkeyRunner提供了一系列API，可以完成模拟事件及截图操作；<br>Monkey与MonkeyRunner的区别：<br>1.Monkey压力测试工具，MonkeyRunner自动化测试工具<br>2.Monkey：在adb shell中，生成用户或系统的伪随机事件<br>3.MonkeyRunner：通过API定义特定命令和事件来控制设备<br>MonkeyRunner APIs:<br>1.MonkeyRunner ;用来连接设备或模拟器.<br>2.MonkeyDevice ：提供安装，卸载应用，发送模拟事件.<br>3.MonkeyImage ：完成图像保存，及对比的操作.<br>MonkeyRunner的测试类型： 多设备控制，功能测试，回归测试<br>压力测试结果：<br>1.CRASH：即崩溃，应用程序在使用过程中，非正常退出<br>2.ANR：Application Not Responding<h3 id="2-实践"><a href="#2-实践" class="headerlink" title="2.实践"></a>2.实践</h3>测试环境：Android SDK+python<br>测试步骤：<br>1.在手机开发者选项中，将USB调试选上；<br>2.确认手机与电脑已经成功连接（通过adb devices确认）；<br>3.安装测试APP（adb install package.apk）；<br>4.发送压力指令（adb shell monkey 1000）;   对手机上任何应用进行随机操作，没有指定应用<br>5.获取APP包名（adb logcat | grep START）;    cmp=(.?)/<br>6.给指定包发送压力指令（adb shell monkey -p package 1000）<h3 id="3-Monkey高级参数的应用"><a href="#3-Monkey高级参数的应用" class="headerlink" title="3.Monkey高级参数的应用"></a>3.Monkey高级参数的应用</h3><blockquote><p>adb shell monkey -v  1000   -v会列出执行的事件</p></blockquote></li></ul><p>1.throttle参数：指定事件之间的间隔   adb shell monkey –throttle <milliseconds> 1000<br>2.seed参数：指定随机生成数的seed值   adb shell monkey -s <seed> 1000<br>3.触摸事件： 设定触摸事件百分比  adb shell monkey –pct-touch <percent> 1000<br>4.动作事件 ：设定动作事件百分比  adb shell monkey –pct-motion <percent> 1000<br>5.轨迹球事件：设定轨迹球事件百分比  adb shell monkey –pct-trackball <percent> 1000<br>6.基本导航事件：设定基本导航事件百分比,输入设备的上下左右  adb shell monkey –pct-nav <percent> 1000<br>7.主要导航事件：设定主要导航事件百分比,兼容中间键，返回键，菜单按键  adb shell monkey –pct-majornav <percent> 1000<br>8.系统导航事件：设定系统导航事件百分比,HOME，BACK，拨号及音量键  adb shell monkey –pct-syskeys <percent> 1000<br>9.启动Activity事件：设定启动Activity事件百分比    adb shell monkey –pct-appswitch <percent> 1000<br>10.启动不常用事件：设定启动不常用事件百分比    adb shell monkey –pct-anyevent <percent> 1000<br>11.崩溃事件：忽略崩溃和异常     adb shell monkey –ignore-crashes 1000<br>12.超时事件：忽略超时事件（ANR）     adb shell monkey –ignore-timeouts 1000<br><strong> CRASH异常结果析取： </strong><br>在执行monkey命令中发现CRASH，可直接通过monkey的log析取<br><strong> ANR异常结果析取： </strong><br>1.在执行monkey命令中发现ANR，可直接通过ANR的log析取<br>2.手动点击出现ANR时，可通过exception的文件析取：</percent></percent></percent></percent></percent></percent></percent></percent></seed></milliseconds></p><blockquote><p> adb shell                    //进入手机<br>   cd /data/anr/      //进入anr目录<br>   ls                         //列出目录中的文件<br>   more traces.txt   //查看anr记录文本</p></blockquote><h3 id="4-MonkeyScript"><a href="#4-MonkeyScript" class="headerlink" title="4.MonkeyScript"></a>4.MonkeyScript</h3><h4 id="执行monkey脚本的命令"><a href="#执行monkey脚本的命令" class="headerlink" title="执行monkey脚本的命令"></a>执行monkey脚本的命令</h4><blockquote><p>adb shell monkey -f <scriptfile> <event-count></event-count></scriptfile></p></blockquote><p>需要注意的是，因为 adb shell 的运行环境是在待测试的 Android 设备上，所以需要将 MS 脚本 pull 到待测试的设备上，然后再进行运行。<br>通过 adb push 将其上传到待测试的设备中。<br>adb push monkey.mks /data/local/tmp/<br>然后通过 monkey -f 执行此脚本，例如下面执行 10 次。<br>adb shell monkey -f /data/local/tmp/monkey.mks 10</p><p>MS脚本，只要是文本即可，不关心后缀是什么。一般来说，会以.script 或者 .mks来作为后缀，标识它是一个Monkey脚本。</p><pre><code class="javascripte"># 控制 monkey 发送消息的 Monkey 头type=usercount=10speed=1.0start data&gt;&gt;# 在此之下，编写 monkey 脚本命令# …</code></pre><p>在脚本中，脚本头是一直不变动的，为了避免写错，可以直接复制粘贴最保险。在 start data&gt;&gt; 之后就可以正式开始编写 monkey 脚本了，在脚本中，使用 # 号，对单行进行注释。<br>接下来就开始利用 MS 提供的 API 进行脚本的编写。</p><h4 id="MonkeyScript常用的API"><a href="#MonkeyScript常用的API" class="headerlink" title="MonkeyScript常用的API"></a>MonkeyScript常用的API</h4><h5 id="1-轨迹球事件（DispatchTrackball）"><a href="#1-轨迹球事件（DispatchTrackball）" class="headerlink" title="1.轨迹球事件（DispatchTrackball）"></a>1.轨迹球事件（DispatchTrackball）</h5><p>DispatchTrackball命令用于向一个坐标点（即：x坐标，y坐标）发送跟踪球消息<br>DispatchTrackball(long downTime, long eventTime, int action, float x, float y, float pressure, float size, int metaState, float xPrecision, float yPrecision, int device, int edgeFlags)<br>参数介绍：<br>downTime //键最初被按下的时间<br>eventTime //事件发生的时间<br>action //ACTIVON事件类型比如ACTION_DOWN=0，ACTION_MOVE=1，ACTION_UP=2，ACTION_CANCEL=3<br>x //x坐标<br>y //y坐标<br>pressure //当前事件的压力，范围0-1<br>size //触摸的近似值，范围0-1<br>metaState //当前按下的meta键的标识<br>xPrecision //x坐标精确值<br>yPrecision //y坐标精确值<br>device //事件来源，范围0-x，0表示不来自物理设备<br>sedgeFlags // 通常写作0即可 </p><h5 id="2-点击事件（DispatchPointer）"><a href="#2-点击事件（DispatchPointer）" class="headerlink" title="2.点击事件（DispatchPointer）"></a>2.点击事件（DispatchPointer）</h5><p>DispatchPointer 命令用于向一个指定的坐标位置，发送单个手势消息，一般用它来模拟点击的操作。<br>它完整的方法签名是：<br>DispatchPointer ( downTime , eventTime , action , x , y , pressure , size , metaState , xPrecision , yPrecision , device , edgeFlags)<br>其实这么多参数，只需要关注action 、 x 、y 三个参数即可。</p><ul><li>action ：事件是按下还是抬起，0 表示按下，1 表示抬起。</li><li>x、y：表示当前事件触发的X轴和Y轴的坐标。<br>也就是说，两个 DispatchPointer 命令加在一起，分别表示 按下 和 抬起 ，这表示一次点击操作，其余的参数，统一设置为 0 即可。<h5 id="3-按键消息（DispatchKey）"><a href="#3-按键消息（DispatchKey）" class="headerlink" title="3.按键消息（DispatchKey）"></a>3.按键消息（DispatchKey）</h5>DispatchKey 主要是用于发送一些 Android 标准的 EventKey 按键消息。但是需要写对应的值。<br>具体的键值，可以通过官网查询：<br><a href="https://developer.android.com/reference/android/view/KeyEvent.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/view/KeyEvent.html</a><br>DispatchKey 消息的方法前面和 DispatchPointer 一样，所以同样也只需要关注 action、x、y 三个参数即可。<h5 id="4-输入字符串-DispatchString"><a href="#4-输入字符串-DispatchString" class="headerlink" title="4.输入字符串(DispatchString)"></a>4.输入字符串(DispatchString)</h5>DispatchString 命令用于向 Shell 输入一个字符串。<br>它的方法签名如下：<br>DispatchString( String text)<br>参数text:参数text不加引号，指输入字符串text到指定的输入框中。 但是 MS 对中文的支持并不好，所以尽量输入英文的测试数据。<h5 id="5-开启关闭软键盘（DispatchFlip）"><a href="#5-开启关闭软键盘（DispatchFlip）" class="headerlink" title="5.开启关闭软键盘（DispatchFlip）"></a>5.开启关闭软键盘（DispatchFlip）</h5>DispatchFlip 命令用于打开或者关闭软键盘。它的方法签名如下：<br>DispatchFlip (booleankeyboardOpen)<br>其中的参数，true 表示打开，false 表示关闭。<h5 id="6-打开指定的Activity（LaunchActivity）"><a href="#6-打开指定的Activity（LaunchActivity）" class="headerlink" title="6.打开指定的Activity（LaunchActivity）"></a>6.打开指定的Activity（LaunchActivity）</h5>LaunchActivity 命令用于打开任意应用的一个页面，但是前提条件是打开的Activity 需要属性 android:exported 被设定为true，才可以通过 LaunchActivity 打开。它的方法签名如下：<br>LaunchActivity ( pkg_name , act_name )<br>它的两个参数，分别表示打开的 App 的包名和打开的 Activity 的名称。<h5 id="7-等待（UserWait）"><a href="#7-等待（UserWait）" class="headerlink" title="7.等待（UserWait）"></a>7.等待（UserWait）</h5>UserWait 命令用于让脚本中断执行一段时间。因为是脚本执行，多个事件之间执行的速度会非常的快，有时候我们需要等待一些事件触发之后的结果返回，需要等待一段时间之后，再继续执行脚本，这个时候就可以使用 UserWait 。<br>它的方法签名如下：<br>UserWait ( sleepTime )<br>sleepTime 的单位是毫秒。<h5 id="8-运行-Shell-命令（RunCmd）"><a href="#8-运行-Shell-命令（RunCmd）" class="headerlink" title="8.运行 Shell 命令（RunCmd）"></a>8.运行 Shell 命令（RunCmd）</h5>RunCmd 命令用于在设备上运行 shell 命令。当然这些 shell 命令必须是当前待测试设备支持的 shell 命令。<br>它的方法签名如下：<br>RunCmd ( cmd )<br>参数 cmd 就是需要执行的 shell 命令。<h5 id="9-键盘事件（DispatchPress）"><a href="#9-键盘事件（DispatchPress）" class="headerlink" title="9.键盘事件（DispatchPress）"></a>9.键盘事件（DispatchPress）</h5>DispatchPress 命令用于模拟敲击键盘的事件。<br>它的方法签名如下：<br>DispatchPress( int keyCode)<br>参数：<br>keyCode:键对应的code值 ，比如回车键keyCode=66<h5 id="10-其他简介"><a href="#10-其他简介" class="headerlink" title="10.其他简介"></a>10.其他简介</h5>Tap(x, y, tapDuration)： 模拟一次手指单击事件。参数：x,y为控件坐标，tapDuration为点击的持续时间，此参数可省略。<br>LongPress()： 长按2秒。<br>PressAndHold(x, y, pressDuration)： 模拟长按事件。<br>Drag(xStart, yStart, xEnd, yEnd, stepCount)： 用于模拟一个拖拽操作。<br>RotateScreen(rotationDegree, persist)： 旋转屏幕。 参数：rotationDegree为旋转角度， e.g. 1代表90度；persist表示旋转之后是否固定，0表示旋转后恢复，非0则表示固定不变。<br>PinchZoom(x1Start, y1Start, x1End, y1End, x2Start, y2Start, x2End, y2End, stepCount)： 模拟缩放手势。<br>DeviceWakeUp()： 唤醒屏幕。<br>PowerLog(power_log_type, test_case_status)： 模拟电池电量信息。<br>WriteLog()： 将电池信息写入sd卡。<br>LaunchInstrumentation(test_name,runner_name)： 运行一个instrumentation测试用例。<br>ProfileWait： 等待5秒。<br>StartCaptureFramerate()：  获取帧率。<br>EndCaptureFramerate(input)： 结束获取帧率。</li></ul><p><strong> 控件坐标点的获取 </strong><br>网上很多推荐获取坐标点的方式，是使用 android-sdk/tools 目录下，提供的 uiautomatorviewer 工具来获取。但是这种方式非常的繁琐，而实际上，我们又不需要如此精确的坐标点，毕竟控件那么大，只要点击的坐标落在控件的位置上，即可。<br>那么我推荐另外一种更简单的方式，来获取当前你看见的，在待测试设备上的控件的坐标点的定位方式。那就是利用 Android 设备的开发者选项。<br>设置 → 开发者选项 → 指针位置 ，将这个属性开启之后，当手指在屏幕上滑动的时候，就可以在顶部看到当前触摸点的 X、Y 轴的坐标，这就是我们需要的。<br>开发者选项不是默认可见的，你需要自行开启开发者模式，之后再进行此操作。</p><h3 id="5-MonkeyRunner常用API"><a href="#5-MonkeyRunner常用API" class="headerlink" title="5.MonkeyRunner常用API"></a>5.MonkeyRunner常用API</h3><h5 id="1-watiForConnection：等待设备连接"><a href="#1-watiForConnection：等待设备连接" class="headerlink" title="1.watiForConnection：等待设备连接"></a>1.watiForConnection：等待设备连接</h5><p>waitForConnection(float fimeout,string deviceId)<br>参数介绍：<br>fimeout：超时时间，单位秒，浮点数。默认是无限期地等待。<br>deviceId：指定具体的设备id </p><h5 id="2-alert-弹出警告框"><a href="#2-alert-弹出警告框" class="headerlink" title="2.alert:弹出警告框"></a>2.alert:弹出警告框</h5><p>alert(string message,string title,string okTitle)<br>参数介绍：<br>mesage:弹出框内容<br>title：弹出框标题<br>okTitle：弹出框确认键内容 </p><h5 id="3-drag-滑动（拖动）屏幕"><a href="#3-drag-滑动（拖动）屏幕" class="headerlink" title="3.drag:滑动（拖动）屏幕"></a>3.drag:滑动（拖动）屏幕</h5><p>drag(tuple start,tuple end,float duration,integer steps)<br>参数介绍：<br>start：开始位置<br>end：结束<br>duration：手势持续时间<br>steps：执行次数或步数，默认为10 </p><h5 id="4-press-模块按键按下操作"><a href="#4-press-模块按键按下操作" class="headerlink" title="4.press:模块按键按下操作"></a>4.press:模块按键按下操作</h5><p>press(string keycode,dictionary type)<br>参数介绍：<br>keycode:按键code值，如menu键：KEYCODE_MENU，home键：KEYCODE_HOME，back键：KEYCODE_BACK，search键：KEYCODE_SEARCH等<br>type：类型：DOWN中UP，如果写DOWN_AND_UP则是按下和抬起两个动作 </p><h5 id="5-startActivity-启动Activity"><a href="#5-startActivity-启动Activity" class="headerlink" title="5.startActivity:启动Activity"></a>5.startActivity:启动Activity</h5><p>startActivity(pkgNmae+”/”+activityName)<br>参数介绍：<br>pkgNmae+”/”+activityName：指格式为应用包名+“/”+启动的Activity名，如”com.ldm.test/.activity.FirstActivity” </p><h5 id="6-touch-点击（触摸）操作"><a href="#6-touch-点击（触摸）操作" class="headerlink" title="6.touch:点击（触摸）操作"></a>6.touch:点击（触摸）操作</h5><p>touch(integer x,integer y,integer type)<br>参数介绍：<br>x:x坐标值<br>y:y坐标值<br>type:类型，DOWN,UP及DOWN_AND_UP </p><h5 id="7-type-输入内容操作"><a href="#7-type-输入内容操作" class="headerlink" title="7.type:输入内容操作"></a>7.type:输入内容操作</h5><p>type(string content)<br>参数介绍：<br>content:输入的内容 </p><h5 id="8-takeSnapshot-截屏操作"><a href="#8-takeSnapshot-截屏操作" class="headerlink" title="8.takeSnapshot:截屏操作"></a>8.takeSnapshot:截屏操作</h5><p>takeSnapshot() </p><h5 id="9-writeToFile-保存文件操作"><a href="#9-writeToFile-保存文件操作" class="headerlink" title="9.writeToFile:保存文件操作"></a>9.writeToFile:保存文件操作</h5><p>writeToFile（string path,string format）<br>参数介绍：<br>path：保存路径<br>format：保存格式，如PNG,JEPG等 </p><h5 id="10-sameAs：图像对比操作。"><a href="#10-sameAs：图像对比操作。" class="headerlink" title="10.sameAs：图像对比操作。"></a>10.sameAs：图像对比操作。</h5><p>sameAS(MonkeyImage other,float percent)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 自动化脚本：&lt;/strong&gt;&lt;br&gt;UIAutomator : 只支持Java语言 ；只支持Android平台；&lt;br&gt;MonkeyRunner  ： 只支持Android平台；&lt;br&gt;TestComplete：商用软件收费；&lt;br&gt;Appium：跨平台；支持多种语言&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; APP压力测试使用的知识：&lt;/strong&gt;&lt;br&gt;Adb命令&lt;br&gt;Monkey&lt;br&gt;Monkey Script&lt;br&gt;MonkeyRunner&lt;/p&gt;
&lt;h2 id=&quot;一-自动化实例&quot;&gt;&lt;a href=&quot;#一-自动化实例&quot; class=&quot;headerlink&quot; title=&quot;一 自动化实例&quot;&gt;&lt;/a&gt;一 自动化实例&lt;/h2&gt;&lt;p&gt;1 准备测试的app；准备测试环境；实现脚本；&lt;br&gt;2 测试app：只有登录功能&lt;br&gt;测试环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Appium（Android/IOS）;&lt;/li&gt;
&lt;li&gt;Android SDK;&lt;/li&gt;
&lt;li&gt;Appium-Python-Client;&lt;/li&gt;
&lt;li&gt;Selenium（Appium-Python-Client继承于Selenium); &lt;/li&gt;
&lt;li&gt;UIAutomatorViewer&lt;/li&gt;
&lt;li&gt;Pycharm&lt;br&gt;3 实现脚本&lt;br&gt;在Pycharm中编写脚本；&lt;br&gt;用UIAutomatorViewer进行定位；&lt;br&gt;借助Appium—Python—Client实现的api；&lt;br&gt;借助Appium—Python—Client的字典实现属性；&lt;br&gt;运行脚本之前要启动Appium并进行设置，&lt;br&gt;如果出现“新的session无法建立”的错误，请释放资源并重启Appium。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="APP测试" scheme="http://xyunlay.github.io/tags/APP%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter-Ant-Jenkins集成</title>
    <link href="http://xyunlay.github.io/2017/06/07/Jmeter-Ant-Jenkins%E9%9B%86%E6%88%90/"/>
    <id>http://xyunlay.github.io/2017/06/07/Jmeter-Ant-Jenkins集成/</id>
    <published>2017-06-07T02:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.013Z</updated>
    
    <content type="html"><![CDATA[<p>安装配置Java环境<br>安装Tomcat和Jenkins<br>安装Ant<br><a id="more"></a></p><h4 id="1-将Jmeter安装目录apache-jmeter-3-0-extras文件夹中的ant-jmeter-1-1-1-jar复制到Ant安装目录下的lib文件夹下。"><a href="#1-将Jmeter安装目录apache-jmeter-3-0-extras文件夹中的ant-jmeter-1-1-1-jar复制到Ant安装目录下的lib文件夹下。" class="headerlink" title="1.将Jmeter安装目录apache-jmeter-3.0\extras文件夹中的ant-jmeter-1.1.1.jar复制到Ant安装目录下的lib文件夹下。"></a>1.将Jmeter安装目录apache-jmeter-3.0\extras文件夹中的ant-jmeter-1.1.1.jar复制到Ant安装目录下的lib文件夹下。</h4><p><img src="/assets/blogImg/ant_jmeter_jenkins1.jpg" alt="Jmeter-Ant-Jenkins"></p><h4 id="2-修改Jmeter配置文件jmeter-properties"><a href="#2-修改Jmeter配置文件jmeter-properties" class="headerlink" title="2.修改Jmeter配置文件jmeter.properties"></a>2.修改Jmeter配置文件jmeter.properties</h4><ul><li>修改jtl文件格式<br><img src="/assets/blogImg/ant_jmeter_jenkins2.jpg" alt="Jmeter-Ant-Jenkins"><br><img src="/assets/blogImg/ant_jmeter_jenkins3.jpg" alt="Jmeter-Ant-Jenkins"></li><li>添加jtl文件结果参数<br><img src="/assets/blogImg/ant_jmeter_jenkins4.jpg" alt="Jmeter-Ant-Jenkins"></li></ul><h4 id="3-编写ant的build-xml"><a href="#3-编写ant的build-xml" class="headerlink" title="3.编写ant的build.xml"></a>3.编写ant的build.xml</h4><p><img src="/assets/blogImg/ant_jmeter_jenkins5.jpg" alt="Jmeter-Ant-Jenkins"><br><img src="/assets/blogImg/ant_jmeter_jenkins6.jpg" alt="Jmeter-Ant-Jenkins"><br><img src="/assets/blogImg/ant_jmeter_jenkins7.jpg" alt="Jmeter-Ant-Jenkins"></p><p>测试ant命令是否生效<br><img src="/assets/blogImg/ant_jmeter_jenkins8.jpg" alt="Jmeter-Ant-Jenkins"><br><img src="/assets/blogImg/ant_jmeter_jenkins9.jpg" alt="Jmeter-Ant-Jenkins"><br><img src="/assets/blogImg/ant_jmeter_jenkins10.jpg" alt="Jmeter-Ant-Jenkins"></p><p>不同的测试报告模板生成的HTML结果报告：<br>jmeter-results-detail-report_21.xsl<br>显示了用例数、成功率、响应时间<br><img src="/assets/blogImg/ant_jmeter_jenkins11.jpg" alt="Jmeter-Ant-Jenkins"><br>jmeter.results.shanhe.me.xsl<br>显示各请求的详细结果<br><img src="/assets/blogImg/ant_jmeter_jenkins12.jpg" alt="Jmeter-Ant-Jenkins"></p><h4 id="4-配置Jenkins"><a href="#4-配置Jenkins" class="headerlink" title="4.配置Jenkins"></a>4.配置Jenkins</h4><p>安装插件<br><img src="/assets/blogImg/ant_jmeter_jenkins13.jpg" alt="Jmeter-Ant-Jenkins"><br>全局工具配置<br><img src="/assets/blogImg/ant_jmeter_jenkins14.jpg" alt="Jmeter-Ant-Jenkins"></p><p>新建一个“构建一个自由风格的软件项目”<br><img src="/assets/blogImg/ant_jmeter_jenkins15.jpg" alt="Jmeter-Ant-Jenkins"><br><img src="/assets/blogImg/ant_jmeter_jenkins16.jpg" alt="Jmeter-Ant-Jenkins"><br><img src="/assets/blogImg/ant_jmeter_jenkins17.jpg" alt="Jmeter-Ant-Jenkins"><br><img src="/assets/blogImg/ant_jmeter_jenkins18.jpg" alt="Jmeter-Ant-Jenkins"><br><img src="/assets/blogImg/ant_jmeter_jenkins19.jpg" alt="Jmeter-Ant-Jenkins"><br><img src="/assets/blogImg/ant_jmeter_jenkins20.jpg" alt="Jmeter-Ant-Jenkins"><br><img src="/assets/blogImg/ant_jmeter_jenkins21.jpg" alt="Jmeter-Ant-Jenkins"><br><img src="/assets/blogImg/ant_jmeter_jenkins22.jpg" alt="Jmeter-Ant-Jenkins"><br><img src="/assets/blogImg/ant_jmeter_jenkins23.jpg" alt="Jmeter-Ant-Jenkins"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装配置Java环境&lt;br&gt;安装Tomcat和Jenkins&lt;br&gt;安装Ant&lt;br&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://xyunlay.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="jmeter" scheme="http://xyunlay.github.io/tags/jmeter/"/>
    
  </entry>
  
  <entry>
    <title>利用ant批量执行jmeter脚本</title>
    <link href="http://xyunlay.github.io/2017/06/06/%E5%88%A9%E7%94%A8ant%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8Cjmeter%E8%84%9A%E6%9C%AC/"/>
    <id>http://xyunlay.github.io/2017/06/06/利用ant批量执行jmeter脚本/</id>
    <published>2017-06-06T02:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载ant-contrib"><a href="#下载ant-contrib" class="headerlink" title="下载ant-contrib"></a>下载ant-contrib</h2><p>将该jar包ant的安装目录下（如果没有，需要在build.xml中指出路径）<br><a id="more"></a></p><h2 id="编写build-xml"><a href="#编写build-xml" class="headerlink" title="编写build.xml"></a>编写build.xml</h2><p><img src="/assets/blogImg/ant_jmeter1.jpg" alt="build.xml"><br><img src="/assets/blogImg/ant_jmeter2.jpg" alt="build.xml"><br><img src="/assets/blogImg/ant_jmeter3.jpg" alt="build.xml"><br><img src="/assets/blogImg/ant_jmeter4.jpg" alt="build.xml"><br><img src="/assets/blogImg/ant_jmeter5.jpg" alt="build.xml"></p><h2 id="测试ant"><a href="#测试ant" class="headerlink" title="测试ant"></a>测试ant</h2><p><img src="/assets/blogImg/ant_jmeter6.jpg" alt="测试ant"><br><img src="/assets/blogImg/ant_jmeter7.jpg" alt="测试ant"><br><img src="/assets/blogImg/ant_jmeter8.jpg" alt="测试ant"></p><h2 id="结果目录："><a href="#结果目录：" class="headerlink" title="结果目录："></a>结果目录：</h2><p><img src="/assets/blogImg/ant_jmeter9.jpg" alt="结果目录"><br><img src="/assets/blogImg/ant_jmeter10.jpg" alt="结果目录"><br><img src="/assets/blogImg/ant_jmeter11.jpg" alt="结果目录"></p><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>在192.168.1.244上的Jenkins运行add_repair_bill.jmx时报错<br><img src="/assets/blogImg/ant_jmeter12.jpg" alt="报错"></p><p>无法将jtl文件转换为HTML时报错<br><img src="/assets/blogImg/ant_jmeter13.jpg" alt="报错"></p><p><a href="http://www.blogjava.net/hyhos/archive/2008/11/30/154606.html" target="_blank" rel="noopener">http://www.blogjava.net/hyhos/archive/2008/11/30/154606.html</a><br><a href="https://www.ibm.com/support/knowledgecenter/zh/SSYKE2_8.0.0/com.ibm.java.lnx.80.doc/diag/appendixes/cmdline/Djdkxmltotalentitysizelimit.html" target="_blank" rel="noopener">https://www.ibm.com/support/knowledgecenter/zh/SSYKE2_8.0.0/com.ibm.java.lnx.80.doc/diag/appendixes/cmdline/Djdkxmltotalentitysizelimit.html</a></p><p>解决：在java目录lib中添加一个文件<br>jaxp.properties<br><img src="/assets/blogImg/ant_jmeter14.jpg" alt="jaxp.properties"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;下载ant-contrib&quot;&gt;&lt;a href=&quot;#下载ant-contrib&quot; class=&quot;headerlink&quot; title=&quot;下载ant-contrib&quot;&gt;&lt;/a&gt;下载ant-contrib&lt;/h2&gt;&lt;p&gt;将该jar包ant的安装目录下（如果没有，需要在build.xml中指出路径）&lt;br&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://xyunlay.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="jmeter" scheme="http://xyunlay.github.io/tags/jmeter/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter监听器数据分析</title>
    <link href="http://xyunlay.github.io/2017/05/16/Jmeter%E7%9B%91%E5%90%AC%E5%99%A8%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>http://xyunlay.github.io/2017/05/16/Jmeter监听器数据分析/</id>
    <published>2017-05-16T02:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先需要确保测试数据是有效的："><a href="#首先需要确保测试数据是有效的：" class="headerlink" title="首先需要确保测试数据是有效的："></a>首先需要确保测试数据是有效的：</h2><ul><li>确保整个测试执行期间，测试环境是稳定的（运行Jmeter的机器的性能）；</li><li>检查Jmeter测试脚本参数数据是否合理，检查Jmeter运行模式是否合理（大并发下不建议使用GUI模式；使用非GUI模式运行Jmeter，并使用简单保存数据记录测试数据）；测试时要关注Jmeter占用CPU和内存的情况</li><li>检查测试结果是否暴露出系统瓶颈（关注异常数据） 需考虑待测系统是否存在什么机制屏蔽了大部分压力</li></ul><h2 id="测试结果分析原则"><a href="#测试结果分析原则" class="headerlink" title="测试结果分析原则"></a>测试结果分析原则</h2><ul><li>用户响应时长</li><li>网络和服务器响应时长</li><li><p>组件级性能</p><a id="more"></a><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p><img src="/assets/blogImg/jmeter1.jpg" alt="Jmeter"></p><ul><li>平均采样响应时长曲线，一般随着并发压力的加大以及性能测试时间的延长，该曲线应该是平滑的，并大致平行于图形下边界<br>该曲线的几种可能：<br><img src="/assets/blogImg/jmeter2.jpg" alt="Jmeter"><br><img src="/assets/blogImg/jmeter3.jpg" alt="Jmeter"><br><img src="/assets/blogImg/jmeter4.jpg" alt="Jmeter"><br><img src="/assets/blogImg/jmeter5.jpg" alt="Jmeter"><br><img src="/assets/blogImg/jmeter6.jpg" alt="Jmeter"></li></ul></li></ul><ul><li>通过观察采样响应时长标准差，可以判断采样数据的分步是否均匀。采样数据分步不均时，提示可能存在性能缺陷</li></ul><p>这种判别处理原理及方法仅局限于对正态或近似正态分布的样本数据处理，它是以测量次数充分大为前提的，当测量次数的情形用准则剔除粗大误差是不够可靠的。因此，在测量次数较少的情况下，最好不要选用准则，而用其他准则。<br>在正态分布中σ代表标准差,μ代表均值。x=μ即为图像的对称轴<br>3σ原则为<br>数值分布在（μ-σ,μ+σ)中的概率为0.6826<br>数值分布在（μ-2σ,μ+2σ)中的概率为0.9544<br>数值分布在（μ-3σ,μ+3σ)中的概率为0.9974<br>可以认为，Y 的取值几乎全部集中在（μ-3σ,μ+3σ)区间内，超出这个范围的可能性仅占不到0.03%</p><ul><li>吞吐率表示服务器每分钟处理的实际采样数（samples）</li></ul><p>聚合报告<br><img src="/assets/blogImg/jmeter7.jpg" alt="Jmeter"><br><img src="/assets/blogImg/jmeter8.jpg" alt="Jmeter"><br><img src="/assets/blogImg/jmeter9.jpg" alt="Jmeter"><br><img src="/assets/blogImg/jmeter10.jpg" alt="Jmeter"><br><img src="/assets/blogImg/jmeter11.jpg" alt="Jmeter"></p><p>查看结果树<br>提供响应数据，可以检视响应结果，并利用正则表达式，从响应结果中提取数据<br><img src="/assets/blogImg/jmeter12.jpg" alt="Jmeter"></p><p>监视器结果（Tomcat）<br><img src="/assets/blogImg/jmeter13.jpg" alt="Jmeter"><br><img src="/assets/blogImg/jmeter14.jpg" alt="Jmeter"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;首先需要确保测试数据是有效的：&quot;&gt;&lt;a href=&quot;#首先需要确保测试数据是有效的：&quot; class=&quot;headerlink&quot; title=&quot;首先需要确保测试数据是有效的：&quot;&gt;&lt;/a&gt;首先需要确保测试数据是有效的：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;确保整个测试执行期间，测试环境是稳定的（运行Jmeter的机器的性能）；&lt;/li&gt;
&lt;li&gt;检查Jmeter测试脚本参数数据是否合理，检查Jmeter运行模式是否合理（大并发下不建议使用GUI模式；使用非GUI模式运行Jmeter，并使用简单保存数据记录测试数据）；测试时要关注Jmeter占用CPU和内存的情况&lt;/li&gt;
&lt;li&gt;检查测试结果是否暴露出系统瓶颈（关注异常数据） 需考虑待测系统是否存在什么机制屏蔽了大部分压力&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;测试结果分析原则&quot;&gt;&lt;a href=&quot;#测试结果分析原则&quot; class=&quot;headerlink&quot; title=&quot;测试结果分析原则&quot;&gt;&lt;/a&gt;测试结果分析原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用户响应时长&lt;/li&gt;
&lt;li&gt;网络和服务器响应时长&lt;/li&gt;
&lt;li&gt;&lt;p&gt;组件级性能&lt;/p&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://xyunlay.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://xyunlay.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="jmeter" scheme="http://xyunlay.github.io/tags/jmeter/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令大全</title>
    <link href="http://xyunlay.github.io/2017/04/16/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://xyunlay.github.io/2017/04/16/Linux命令大全/</id>
    <published>2017-04-16T02:55:00.000Z</published>
    <updated>2021-01-25T03:29:26.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><p>arch 显示机器的处理器架构(1)<br>uname -m 显示机器的处理器架构(2)<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS<br><a id="more"></a></p><h2 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a>关机 (系统的关机、重启以及登出 )</h2><p>shutdown -h now 关闭系统(1)<br>init 0 关闭系统(2)<br>telinit 0 关闭系统(3)<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启(1)<br>reboot 重启(2)<br>logout 注销 </p><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构(1)<br>lstree 显示文件和目录由根目录开始的树形结构(2)<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/<em> . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>find . -maxdepth 1 -name </em>.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) </p><h2 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h2><p>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ \; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径 </p><h2 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a>挂载一个文件系统</h2><p>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 </p><h2 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h2><p>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </p><h2 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h2><p>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 </p><h2 id="文件的权限-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的权限-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</h2><p>ls -lh 显示权限<br>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s /home/public 禁用一个目录的 SGID 位<br>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t /home/public 禁用一个目录的 STIKY 位 </p><h2 id="文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</h2><p>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩/解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性 </p><h2 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h2><p>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包 </p><h2 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a>RPM 包 - （Fedora, Redhat及类似系统）</h2><p>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 </p><h2 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h2><p>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件 </p><h2 id="DEB-包-Debian-Ubuntu-以及类似系统"><a href="#DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 以及类似系统)"></a>DEB 包 (Debian, Ubuntu 以及类似系统)</h2><p>dpkg -i package.deb 安装/更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 </p><h2 id="APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a>APT 软件工具 (Debian, Ubuntu 以及类似系统)</h2><p>apt-get install package_name 安装/更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 </p><h2 id="查看文件内容-cat-file1-从第一个字节开始正向查看文件的内容"><a href="#查看文件内容-cat-file1-从第一个字节开始正向查看文件的内容" class="headerlink" title="查看文件内容 cat file1 从第一个字节开始正向查看文件的内容"></a>查看文件内容 cat file1 从第一个字节开始正向查看文件的内容</h2><p>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容 </p><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><p>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>grep Aug -R /var/log/<em> 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”<br>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行<br>sed ‘/ </em>#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s/ <em>$//‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s/00</em>/0/g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 </p><h2 id="字符设置和文件格式转换"><a href="#字符设置和文件格式转换" class="headerlink" title="字符设置和文件格式转换"></a>字符设置和文件格式转换</h2><p>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>recode -l | more 显示所有允许的转换格式 </p><h2 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a>文件系统分析</h2><p>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 </p><h2 id="初始化一个文件系统"><a href="#初始化一个文件系统" class="headerlink" title="初始化一个文件系统"></a>初始化一个文件系统</h2><p>mkfs /dev/hda1 在hda1分区创建一个文件系统<br>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>fdformat -n /dev/fd0 格式化一个软盘<br>mkswap /dev/hda3 创建一个swap文件系统 </p><h2 id="SWAP文件系统"><a href="#SWAP文件系统" class="headerlink" title="SWAP文件系统"></a>SWAP文件系统</h2><p>mkswap /dev/hda3 创建一个swap文件系统<br>swapon /dev/hda3 启用一个新的swap文件系统<br>swapon /dev/hda2 /dev/hdb3 启用两个swap分区 </p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份<br>dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份<br>restore -if /tmp/home0.bak 还原一个交互式备份<br>rsync -rogpav –delete /home /tmp 同步两边的目录<br>rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync<br>rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录<br>rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录<br>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件<br>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作<br>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容<br>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录<br>tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>find /home/user1 -name ‘<em>.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录<br>find /var/log -name ‘</em>.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包<br>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 </p><h2 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h2><p>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容<br>mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件<br>cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件<br>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件<br>mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件<br>cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>cdrecord –scanbus 扫描总线以识别scsi通道<br>dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD </p><h2 id="网络-（以太网和WIFI无线）"><a href="#网络-（以太网和WIFI无线）" class="headerlink" title="网络 - （以太网和WIFI无线）"></a>网络 - （以太网和WIFI无线）</h2><p>ifconfig eth0 显示一个以太网卡的配置<br>ifup eth0 启用一个 ‘eth0’ 网络设备<br>ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)<br>dhclient eth0 以dhcp模式启用 ‘eth0’ </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;系统信息&quot;&gt;&lt;a href=&quot;#系统信息&quot; class=&quot;headerlink&quot; title=&quot;系统信息&quot;&gt;&lt;/a&gt;系统信息&lt;/h2&gt;&lt;p&gt;arch 显示机器的处理器架构(1)&lt;br&gt;uname -m 显示机器的处理器架构(2)&lt;br&gt;uname -r 显示正在使用的内核版本&lt;br&gt;dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)&lt;br&gt;hdparm -i /dev/hda 罗列一个磁盘的架构特性&lt;br&gt;hdparm -tT /dev/sda 在磁盘上执行测试性读取操作&lt;br&gt;cat /proc/cpuinfo 显示CPU info的信息&lt;br&gt;cat /proc/interrupts 显示中断&lt;br&gt;cat /proc/meminfo 校验内存使用&lt;br&gt;cat /proc/swaps 显示哪些swap被使用&lt;br&gt;cat /proc/version 显示内核的版本&lt;br&gt;cat /proc/net/dev 显示网络适配器及统计&lt;br&gt;cat /proc/mounts 显示已加载的文件系统&lt;br&gt;lspci -tv 罗列 PCI 设备&lt;br&gt;lsusb -tv 显示 USB 设备&lt;br&gt;date 显示系统日期&lt;br&gt;cal 2007 显示2007年的日历表&lt;br&gt;date 041217002007.00 设置日期和时间 - 月日时分年.秒&lt;br&gt;clock -w 将时间修改保存到 BIOS&lt;br&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://xyunlay.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://xyunlay.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MD语法入门</title>
    <link href="http://xyunlay.github.io/2017/03/04/MD%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <id>http://xyunlay.github.io/2017/03/04/MD语法入门/</id>
    <published>2017-03-04T14:52:00.000Z</published>
    <updated>2021-01-25T03:29:26.015Z</updated>
    
    <content type="html"><![CDATA[<p>.md即markdown文件的基本常用编写语法,是一种快速标记、快速排版语言，现在很多前段项目中的说明文件readme等都是用.md文件编写的，而且很多企业也在在鼓励使用这种编辑方式，特别作为一个前端从业者更要学会使用这种语言。下面就简单和大家分享一些.md基本语法</p><h2 id="一、基本符号：-gt"><a href="#一、基本符号：-gt" class="headerlink" title="一、基本符号：* - +. &gt;"></a>一、基本符号：* - +. &gt;</h2><p>基本上所有的markdown标记都是基于这四个符号或组合，需要注意的是，如果以基本符号开头的标记，注意基本符号后有一个用于分割标记符和内容的空格。</p><h2 id="二、标题"><a href="#二、标题" class="headerlink" title="二、标题"></a>二、标题</h2><p>1.前面带#号，后面带文字，分别表示h1-h6,只到h6，而且h1下面会有一条横线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure></p><p>2.相当于标签闭合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题 #</span><br><span class="line">## 二级标题 ##</span><br><span class="line">### 三级标题 ###</span><br><span class="line">#### 四级标题 ####</span><br><span class="line">##### 五级标题 #####</span><br><span class="line">###### 六级标题 #####</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>效果如下：<br><img src="/assets/blogImg/markdown1.jpg" alt="markdown "></p><h2 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h2><p>1.无序列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//形式一</span><br><span class="line">+ a</span><br><span class="line">+ b</span><br><span class="line">+ c</span><br><span class="line">//形式二</span><br><span class="line">- d</span><br><span class="line">- e</span><br><span class="line">- f</span><br><span class="line">//形式三</span><br><span class="line">* g</span><br><span class="line">* h</span><br><span class="line">* i</span><br></pre></td></tr></table></figure></p><p>以上三种形式，效果其实都是一样的：</p><p><img src="/assets/blogImg/markdown2.jpg" alt="markdown "></p><p>2.有序列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//正常形式</span><br><span class="line">1. abc</span><br><span class="line">2. bcd</span><br><span class="line">3. cde</span><br><span class="line">//错序效果</span><br><span class="line">2. fgh</span><br><span class="line">3. ghi</span><br><span class="line">5. hij</span><br></pre></td></tr></table></figure></p><p>效果图：<br><img src="/assets/blogImg/markdown3.jpg" alt="markdown "></p><blockquote><p>如图，注意，数字后面的点只能是英文的点，有序列表的序号是根据第一行列表的数字顺序来的，错序列表的序号本来是序号是乱的， 但是还是显示 2 3 5</p></blockquote><p>3.嵌套列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//无序列表嵌套</span><br><span class="line">+ 123</span><br><span class="line">    + abc</span><br><span class="line">    + bcd</span><br><span class="line">    + cde</span><br><span class="line">+ 465</span><br><span class="line">+ 789</span><br><span class="line">//有序列表嵌套</span><br><span class="line">1. abcd</span><br><span class="line">    1. abcde</span><br><span class="line">    2. abcde</span><br><span class="line">    3. abcde</span><br><span class="line">2. bcde</span><br><span class="line">3. cdef</span><br></pre></td></tr></table></figure></p><p>效果图：<br><img src="/assets/blogImg/markdown4.jpg" alt="markdown "></p><blockquote><p>列表可以嵌套，使用时在嵌套列表前按 tab 或 空格 来缩进,去控制列表的层数</p></blockquote><h2 id="四、引用说明区块"><a href="#四、引用说明区块" class="headerlink" title="四、引用说明区块"></a>四、引用说明区块</h2><p>对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语法。</p><p>1.正常形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用内容、说明内容。在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。</span><br></pre></td></tr></table></figure></p><p>效果图：<br><img src="/assets/blogImg/markdown5.jpg" alt="markdown "></p><p>2.嵌套区块<br>这里我只介绍一下我常用的方法，也是个人认为比较规范的一种方法，就是给区块的下一级区块多加一个右尖括号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 一级引用</span><br><span class="line">&gt;&gt; 二级引用</span><br><span class="line">&gt;&gt;&gt; 三级引用</span><br><span class="line">&gt;&gt;&gt;&gt; 四级引用</span><br><span class="line">&gt;&gt;&gt;&gt;&gt; 五级引用</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt; 六级引用</span><br></pre></td></tr></table></figure></p><p>效果图：</p><p><img src="/assets/blogImg/markdown6.jpg" alt="markdown "></p><h2 id="五、代码块"><a href="#五、代码块" class="headerlink" title="五、代码块"></a>五、代码块</h2><p>在发布一些技术文章会涉及展示代码的问题，这时候代码块就显得尤为重要。</p><p>1.少量代码，单行使用，直接用`包裹起来就行了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">` shaoliangdaima,danhangshiyong `</span><br></pre></td></tr></table></figure></p><p>效果图：<br><img src="/assets/blogImg/markdown7.jpg" alt="markdown "></p><p>2.大量代码，需要多行使用，用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">        daliangdaima,xuyaoduohangshiyong</span><br><span class="line">        daliangdaima,xuyaoduohangshiyong</span><br><span class="line">        daliangdaima,xuyaoduohangshiyong</span><br><span class="line">        daliangdaima,xuyaoduohangshiyong</span><br><span class="line">        daliangdaima,xuyaoduohangshiyong</span><br></pre></td></tr></table></figure></p><p>效果图：</p><p><img src="/assets/blogImg/markdown8.jpg" alt="markdown "></p><h2 id="六、链接"><a href="#六、链接" class="headerlink" title="六、链接"></a>六、链接</h2><p>1.行内式<br>链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[简书](https://www.jianshu.com &quot;创作你的创作&quot;),</span><br><span class="line">是一个创作社区,任何人均可以在其上进行创作。用户在简书上面可以方便的创作自己的作品,互相交流。</span><br></pre></td></tr></table></figure></p><p>2.参数式<br>链接的文字放在[]中，链接地址放在随后的:后，链接地址后面空一格，然后用引号引起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[简书]: https://www.jianshu.com &quot;创作你的创作&quot;</span><br><span class="line">[简书]是一个创作社区,任何人均可以在其上进行创作。用户在简书上面可以方便的创作自己的作品,互相交流。</span><br><span class="line">//参数定义的其他写法</span><br><span class="line">[简书]: https://www.jianshu.com &apos;创作你的创作&apos;</span><br><span class="line">[简书]: https://www.jianshu.com (创作你的创作)</span><br><span class="line">[简书]: &lt;https://www.jianshu.com&gt; &quot;创作你的创作&quot;</span><br></pre></td></tr></table></figure></p><p>以上两种方式其效果图都是一样的，如下：<br><img src="/assets/blogImg/markdown9.jpg" alt="markdown "></p><h2 id="七、图片"><a href="#七、图片" class="headerlink" title="七、图片"></a>七、图片</h2><p>1.行内式<br>和链接的形式差不多，图片的名字放在[]中，图片地址放在随后的()中，title属性（图片地址后面空一格，然后用引号引起来）,注意的是[]前要加上!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![my-logo.png](https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 &quot;my-logo&quot;)</span><br></pre></td></tr></table></figure></p><p>2.参数式<br>图片的文字放在[]中，图片地址放在随后的:后，title属性（图片地址后面空一格，然后用引号引起来）,注意引用图片的时候在[]前要加上!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[my-logo.png]: https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 &quot;my-logo&quot;</span><br><span class="line">![my-logo.png]</span><br><span class="line">//参数定义的其他写法</span><br><span class="line">[my-logo.png]: https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 &apos;my-logo&apos;</span><br><span class="line">[my-logo.png]: https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 (my-logo)</span><br><span class="line">[my-logo.png]: &lt;https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&gt; &quot;my-logo&quot;</span><br></pre></td></tr></table></figure></p><p>以上两种方式其效果图都是一样的，如下：<br><img src="/assets/blogImg/markdown10.jpg" alt="markdown "></p><h2 id="八、分割线"><a href="#八、分割线" class="headerlink" title="八、分割线"></a>八、分割线</h2><p>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- - -</span><br><span class="line">------</span><br><span class="line">***</span><br><span class="line">* * *</span><br><span class="line">******</span><br><span class="line">___</span><br><span class="line">_ _ _</span><br><span class="line">______</span><br></pre></td></tr></table></figure></p><p>以上代码的效果图均为：<br><img src="/assets/blogImg/markdown11.jpg" alt="markdown "></p><h2 id="九、其他"><a href="#九、其他" class="headerlink" title="九、其他"></a>九、其他</h2><p>1.强调字体<br>一个星号或者是一个下划线包起来，会转换为<em>倾斜，如果是2个，会转换为<strong>加粗<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*md*    </span><br><span class="line">**md**</span><br><span class="line">_md_   </span><br><span class="line"> __md__</span><br></pre></td></tr></table></figure></strong></em></p><p>效果图：<br><img src="/assets/blogImg/markdown12.jpg" alt="markdown "></p><p>2.转义<br>基本上和js转义一样,\加需要转义的字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\\</span><br><span class="line">\*</span><br><span class="line">\+</span><br><span class="line">\-</span><br><span class="line">\`</span><br><span class="line">\_</span><br></pre></td></tr></table></figure></p><p>3.删除线<br>用~~把需要显示删除线的字符包裹起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除~~</span><br></pre></td></tr></table></figure></p><p>效果图：<br><img src="/assets/blogImg/markdown13.jpg" alt="markdown "></p><h2 id="十、表格"><a href="#十、表格" class="headerlink" title="十、表格"></a>十、表格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//例子一</span><br><span class="line">|123|234|345|</span><br><span class="line">|:-|:-:|-:|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">//例子二</span><br><span class="line">|123|234|345|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">//例子三</span><br><span class="line">123|234|345</span><br><span class="line">:-|:-:|-:</span><br><span class="line">abc|bcd|cde</span><br><span class="line">abc|bcd|cde</span><br><span class="line">abc|bcd|cde</span><br></pre></td></tr></table></figure><blockquote><p>上面三个例子的效果一样，由此可得：</p><ol><li>表格的格式不一定要对的非常起，但是为了良好的变成风格，尽量对齐是最好的</li><li>分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中</li></ol></blockquote><p>效果图如下：<br><img src="/assets/blogImg/markdown14.jpg" alt="markdown "></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.md即markdown文件的基本常用编写语法,是一种快速标记、快速排版语言，现在很多前段项目中的说明文件readme等都是用.md文件编写的，而且很多企业也在在鼓励使用这种编辑方式，特别作为一个前端从业者更要学会使用这种语言。下面就简单和大家分享一些.md基本语法&lt;/p&gt;
&lt;h2 id=&quot;一、基本符号：-gt&quot;&gt;&lt;a href=&quot;#一、基本符号：-gt&quot; class=&quot;headerlink&quot; title=&quot;一、基本符号：* - +. &amp;gt;&quot;&gt;&lt;/a&gt;一、基本符号：* - +. &amp;gt;&lt;/h2&gt;&lt;p&gt;基本上所有的markdown标记都是基于这四个符号或组合，需要注意的是，如果以基本符号开头的标记，注意基本符号后有一个用于分割标记符和内容的空格。&lt;/p&gt;
&lt;h2 id=&quot;二、标题&quot;&gt;&lt;a href=&quot;#二、标题&quot; class=&quot;headerlink&quot; title=&quot;二、标题&quot;&gt;&lt;/a&gt;二、标题&lt;/h2&gt;&lt;p&gt;1.前面带#号，后面带文字，分别表示h1-h6,只到h6，而且h1下面会有一条横线&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 一级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 二级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 三级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 四级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;##### 五级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;###### 六级标题&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2.相当于标签闭合&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 一级标题 #&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 二级标题 ##&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 三级标题 ###&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 四级标题 ####&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;##### 五级标题 #####&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;###### 六级标题 #####&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://xyunlay.github.io/tags/web/"/>
    
      <category term="markdown" scheme="http://xyunlay.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>instagram图片拉取小经验</title>
    <link href="http://xyunlay.github.io/2017/03/03/instagram%E5%9B%BE%E7%89%87%E6%8B%89%E5%8F%96/"/>
    <id>http://xyunlay.github.io/2017/03/03/instagram图片拉取/</id>
    <published>2017-03-03T14:52:00.000Z</published>
    <updated>2021-01-25T03:29:26.017Z</updated>
    
    <content type="html"><![CDATA[<p>最近喜欢上了instagram，分享一下获取照片的经验。<br><a id="more"></a></p><h3 id="一、三“步”曲"><a href="#一、三“步”曲" class="headerlink" title="一、三“步”曲"></a>一、三“步”曲</h3><p>instagram开放了API，授权遵循Oauth2.0协议。        </p><h4 id="1、注册client-id"><a href="#1、注册client-id" class="headerlink" title="1、注册client id"></a>1、注册client id</h4><p>到<a href="http://instagram.com/developer/clients/manage/" target="_blank" rel="noopener">管理客户端页面</a>，选择“注册新客户端”。<br>这时会提示你填手机号，接着会收到短信验证码。经过验证，就到达了下面的界面：<br><img src="/assets/blogImg/instagram1.jpg" alt="填写信息"><br>按照字面意思填写完毕，client id就注册完毕了。                 </p><p><img src="/assets/blogImg/instagram2.jpg" alt="获得client_id">         </p><h4 id="2、用client-id去换取token"><a href="#2、用client-id去换取token" class="headerlink" title="2、用client_id去换取token"></a>2、用client_id去换取token</h4><p>在浏览器中请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://instagram.com/oauth/authorize/?client_id=&#123;CLIENT_ID&#125;&amp;redirect_uri=&#123;REDIRECT_URI&#125;&amp;response_type=token</span><br></pre></td></tr></table></figure></p><p>花括号里面的值，对应上一步最终得到的<code>client_id</code>和自己设定的<code>redirect_uri</code>。<br>请求到的是一个授权页面，授权完毕后，则重定向到你的redirect_uri。注意看授权成功后的url，hash部分会附带给你的token。至此，token成功获取。</p><h4 id="3、用token去调用API"><a href="#3、用token去调用API" class="headerlink" title="3、用token去调用API"></a>3、用token去调用API</h4><p>拿到token，就等于拿到仓库的钥匙了！<br>赶紧试着用token调用api查看自己的图片吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.instagram.com/v1/users/&#123;USER_ID&#125;/media/recent/?access_token=&#123;TOKEN&#125;</span><br></pre></td></tr></table></figure></p><p>这时，你会发现似乎…被instagram api坑了一道。user_id是个啥？机智如我，果断填上了自己的用户名。<br>结果错了。</p><p>后来发现有这个的网站：<a href="http://jelled.com/instagram/lookup-user-id" target="_blank" rel="noopener">lookup-user-id</a>，通过此业界良心，成功获取到user_id，摆平了上面的请求。</p><h3 id="二、参考"><a href="#二、参考" class="headerlink" title="二、参考"></a>二、参考</h3><ol><li>更多功能可参考<a href="http://instagram.com/developer/endpoints/users/" target="_blank" rel="noopener">api文档</a></li><li>如果想了解Oauth授权，<a href="/blog/2013/08/20/oauth-rabbit/">点此</a></li></ol><h3 id="三、再说两句"><a href="#三、再说两句" class="headerlink" title="三、再说两句"></a>三、再说两句</h3><p>图片分享的网站万万千，instagram却只有一个。我不是此产品的脑残粉，只是觉得社区氛围这种东西，可意会而不可言传，它是社交产品的灵魂。不是每个功能相近的产品都能营造的。</p><p>事实上，instagram有很多限制，或者大家称之“功能不完善”的地方。比如，在pc上浏览网站，居然不能发图片，不能看自己关注的人，或者有哪些粉丝。这都限制死了，何以称为社交？但换个角度来想，这样就“强迫”用户去用手机操作instagram，因为产品最想想表达的，就是用摄影去快速记录生活，而已。</p><p>不用拓展业务的噱头去损坏产品的思想表达，不刻意向老板汇报我们新增了多少用户量。</p><p><strong>“你想做什么，你就会进入什么样的圈子”</strong>，这句话，不单单是对用户而言，每个创造者心中都应有这样的思考。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近喜欢上了instagram，分享一下获取照片的经验。&lt;br&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://xyunlay.github.io/tags/web/"/>
    
      <category term="经验" scheme="http://xyunlay.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="产品" scheme="http://xyunlay.github.io/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
</feed>
